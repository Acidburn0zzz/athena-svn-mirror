/*
 * This file was generated by orbit-idl-2 - DO NOT EDIT!
 */

#include <string.h>
#define ORBIT2_STUBS_API
#include "GNOME_VFS_Daemon.h"

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_DaemonMonitor(POA_GNOME_VFS_DaemonMonitor * servant,
				       const char *opname, gpointer * m_data,
				       gpointer * impl)
{
   switch (opname[0]) {
     case 'C':
	if (strcmp((opname + 1), "ancel"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_DaemonMonitor_epv->Cancel;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonMonitor__iinterface.methods.
	   _buffer[0];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonMonitor_Cancel;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_DaemonMonitor__init(PortableServer_Servant servant,
				  CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL,
(ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_DaemonMonitor, "IDL:GNOME/VFS/DaemonMonitor:1.0",
&GNOME_VFS_DaemonMonitor__classid, NULL, &GNOME_VFS_DaemonMonitor__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_DaemonMonitor__fini,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_DaemonMonitor__vepv,
			      GNOME_VFS_DaemonMonitor_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_DaemonMonitor__vepv,
			      Bonobo_Unknown_epv), (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_DaemonMonitor__fini(PortableServer_Servant servant,
				  CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_Client(POA_GNOME_VFS_Client * servant,
				const char *opname, gpointer * m_data,
				gpointer * impl)
{
   switch (opname[0]) {
     case 'D':
	switch (opname[1]) {
	  case 'r':
	     switch (opname[2]) {
	       case 'i':
		  switch (opname[3]) {
		    case 'v':
		       switch (opname[4]) {
			 case 'e':
			    switch (opname[5]) {
			      case 'C':
				 if (strcmp((opname + 6), "onnected"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_VFS_Client_epv->DriveConnected;
				 *m_data =
				    (gpointer) & GNOME_VFS_Client__iinterface.
				    methods._buffer[4];
				 return (ORBitSmallSkeleton)
				    _ORBIT_skel_small_GNOME_VFS_Client_DriveConnected;
				 break;
			      case 'D':
				 if (strcmp((opname + 6), "isconnected"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_VFS_Client_epv->DriveDisconnected;
				 *m_data =
				    (gpointer) & GNOME_VFS_Client__iinterface.
				    methods._buffer[5];
				 return (ORBitSmallSkeleton)
				    _ORBIT_skel_small_GNOME_VFS_Client_DriveDisconnected;
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'M':
	if (strcmp((opname + 1), "onitorCallback"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Client_epv->MonitorCallback;
	*m_data =
	   (gpointer) & GNOME_VFS_Client__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_Client_MonitorCallback;
	break;
     case 'V':
	switch (opname[1]) {
	  case 'o':
	     switch (opname[2]) {
	       case 'l':
		  switch (opname[3]) {
		    case 'u':
		       switch (opname[4]) {
			 case 'm':
			    switch (opname[5]) {
			      case 'e':
				 switch (opname[6]) {
				   case 'M':
				      if (strcmp((opname + 7), "ounted"))
					 break;
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_Client_epv->VolumeMounted;
				      *m_data =
					 (gpointer) &
					 GNOME_VFS_Client__iinterface.methods.
					 _buffer[1];
				      return (ORBitSmallSkeleton)
					 _ORBIT_skel_small_GNOME_VFS_Client_VolumeMounted;
				      break;
				   case 'P':
				      if (strcmp((opname + 7), "reUnmount"))
					 break;
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_Client_epv->
					 VolumePreUnmount;
				      *m_data =
					 (gpointer) &
					 GNOME_VFS_Client__iinterface.methods.
					 _buffer[2];
				      return (ORBitSmallSkeleton)
					 _ORBIT_skel_small_GNOME_VFS_Client_VolumePreUnmount;
				      break;
				   case 'U':
				      if (strcmp((opname + 7), "nmounted"))
					 break;
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_Client_epv->
					 VolumeUnmounted;
				      *m_data =
					 (gpointer) &
					 GNOME_VFS_Client__iinterface.methods.
					 _buffer[3];
				      return (ORBitSmallSkeleton)
					 _ORBIT_skel_small_GNOME_VFS_Client_VolumeUnmounted;
				      break;
				   default:
				      break;
				 }
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_Client__init(PortableServer_Servant servant,
			   CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL, (ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_Client,
"IDL:GNOME/VFS/Client:1.0", &GNOME_VFS_Client__classid, NULL, &GNOME_VFS_Client__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_Client__fini,
			     ORBIT_VEPV_OFFSET(POA_GNOME_VFS_Client__vepv,
					       GNOME_VFS_Client_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET(POA_GNOME_VFS_Client__vepv,
					       Bonobo_Unknown_epv),
			     (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_Client__fini(PortableServer_Servant servant,
			   CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_ClientCall(POA_GNOME_VFS_ClientCall * servant,
				    const char *opname, gpointer * m_data,
				    gpointer * impl)
{
   switch (opname[0]) {
     case 'M':
	if (strcmp((opname + 1), "oduleCallbackInvoke"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_ClientCall_epv->
	   ModuleCallbackInvoke;
	*m_data =
	   (gpointer) & GNOME_VFS_ClientCall__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_ClientCall_ModuleCallbackInvoke;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_ClientCall__init(PortableServer_Servant servant,
			       CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL, (ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_ClientCall,
"IDL:GNOME/VFS/ClientCall:1.0", &GNOME_VFS_ClientCall__classid, NULL, &GNOME_VFS_ClientCall__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_ClientCall__fini,
			     ORBIT_VEPV_OFFSET(POA_GNOME_VFS_ClientCall__vepv,
					       GNOME_VFS_ClientCall_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET(POA_GNOME_VFS_ClientCall__vepv,
					       Bonobo_Unknown_epv),
			     (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_ClientCall__fini(PortableServer_Servant servant,
			       CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_DaemonHandle(POA_GNOME_VFS_DaemonHandle * servant,
				      const char *opname, gpointer * m_data,
				      gpointer * impl)
{
   switch (opname[0]) {
     case 'C':
	if (strcmp((opname + 1), "lose"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->Close;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonHandle_Close;
	break;
     case 'G':
	if (strcmp((opname + 1), "etFileInfo"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->GetFileInfo;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods._buffer[5];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonHandle_GetFileInfo;
	break;
     case 'R':
	if (strcmp((opname + 1), "ead"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->Read;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonHandle_Read;
	break;
     case 'S':
	if (strcmp((opname + 1), "eek"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->Seek;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods._buffer[3];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonHandle_Seek;
	break;
     case 'T':
	switch (opname[1]) {
	  case 'e':
	     if (strcmp((opname + 2), "ll"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->Tell;
	     *m_data =
		(gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods.
		_buffer[4];
	     return (ORBitSmallSkeleton)
		_ORBIT_skel_small_GNOME_VFS_DaemonHandle_Tell;
	     break;
	  case 'r':
	     if (strcmp((opname + 2), "uncate"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->
		Truncate;
	     *m_data =
		(gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods.
		_buffer[6];
	     return (ORBitSmallSkeleton)
		_ORBIT_skel_small_GNOME_VFS_DaemonHandle_Truncate;
	     break;
	  default:
	     break;
	}
	break;
     case 'W':
	if (strcmp((opname + 1), "rite"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_DaemonHandle_epv->Write;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonHandle__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonHandle_Write;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_DaemonHandle__init(PortableServer_Servant servant,
				 CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL,
(ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_DaemonHandle, "IDL:GNOME/VFS/DaemonHandle:1.0",
&GNOME_VFS_DaemonHandle__classid, NULL, &GNOME_VFS_DaemonHandle__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_DaemonHandle__fini,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_DaemonHandle__vepv,
			      GNOME_VFS_DaemonHandle_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_DaemonHandle__vepv,
			      Bonobo_Unknown_epv), (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_DaemonHandle__fini(PortableServer_Servant servant,
				 CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_DaemonDirHandle(POA_GNOME_VFS_DaemonDirHandle *
					 servant, const char *opname,
					 gpointer * m_data, gpointer * impl)
{
   switch (opname[0]) {
     case 'C':
	if (strcmp((opname + 1), "lose"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_DaemonDirHandle_epv->Close;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonDirHandle__iinterface.methods.
	   _buffer[0];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonDirHandle_Close;
	break;
     case 'R':
	if (strcmp((opname + 1), "ead"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_DaemonDirHandle_epv->Read;
	*m_data =
	   (gpointer) & GNOME_VFS_DaemonDirHandle__iinterface.methods.
	   _buffer[1];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_DaemonDirHandle_Read;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_DaemonDirHandle__init(PortableServer_Servant servant,
				    CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL,
(ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_DaemonDirHandle, "IDL:GNOME/VFS/DaemonDirHandle:1.0",
&GNOME_VFS_DaemonDirHandle__classid, NULL, &GNOME_VFS_DaemonDirHandle__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_DaemonDirHandle__fini,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_DaemonDirHandle__vepv,
			      GNOME_VFS_DaemonDirHandle_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_DaemonDirHandle__vepv,
			      Bonobo_Unknown_epv), (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_DaemonDirHandle__fini(PortableServer_Servant servant,
				    CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_Daemon(POA_GNOME_VFS_Daemon * servant,
				const char *opname, gpointer * m_data,
				gpointer * impl)
{
   switch (opname[0]) {
     case 'd':
	switch (opname[1]) {
	  case 'e':
	     switch (opname[2]) {
	       case 'R':
		  switch (opname[3]) {
		    case 'e':
		       switch (opname[4]) {
			 case 'g':
			    switch (opname[5]) {
			      case 'i':
				 switch (opname[6]) {
				   case 's':
				      switch (opname[7]) {
					case 't':
					   switch (opname[8]) {
					     case 'e':
						switch (opname[9]) {
						  case 'r':
						     switch (opname[10]) {
						       case 'C':
							  if (strcmp
							      ((opname + 11),
							       "lient"))
							     break;
							  *impl =
							     (gpointer)
							     servant->vepv->
							     GNOME_VFS_Daemon_epv->
							     deRegisterClient;
							  *m_data =
							     (gpointer) &
							     GNOME_VFS_Daemon__iinterface.
							     methods.
							     _buffer[1];
							  return
							     (ORBitSmallSkeleton)
							     _ORBIT_skel_small_GNOME_VFS_Daemon_deRegisterClient;
							  break;
						       case 'V':
							  if (strcmp
							      ((opname + 11),
							       "olumeMonitor"))
							     break;
							  *impl =
							     (gpointer)
							     servant->vepv->
							     GNOME_VFS_Daemon_epv->
							     deRegisterVolumeMonitor;
							  *m_data =
							     (gpointer) &
							     GNOME_VFS_Daemon__iinterface.
							     methods.
							     _buffer[3];
							  return
							     (ORBitSmallSkeleton)
							     _ORBIT_skel_small_GNOME_VFS_Daemon_deRegisterVolumeMonitor;
							  break;
						       default:
							  break;
						     }
						     break;
						  default:
						     break;
						}
						break;
					     default:
						break;
					   }
					   break;
					default:
					   break;
				      }
				      break;
				   default:
				      break;
				 }
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'e':
	if (strcmp((opname + 1), "mitPreUnmountVolume"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Daemon_epv->
	   emitPreUnmountVolume;
	*m_data =
	   (gpointer) & GNOME_VFS_Daemon__iinterface.methods._buffer[6];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_Daemon_emitPreUnmountVolume;
	break;
     case 'f':
	if (strcmp((opname + 1), "orceProbe"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Daemon_epv->forceProbe;
	*m_data =
	   (gpointer) & GNOME_VFS_Daemon__iinterface.methods._buffer[7];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_Daemon_forceProbe;
	break;
     case 'g':
	switch (opname[1]) {
	  case 'e':
	     switch (opname[2]) {
	       case 't':
		  switch (opname[3]) {
		    case 'D':
		       if (strcmp((opname + 4), "rives"))
			  break;
		       *impl =
			  (gpointer) servant->vepv->GNOME_VFS_Daemon_epv->
			  getDrives;
		       *m_data =
			  (gpointer) & GNOME_VFS_Daemon__iinterface.methods.
			  _buffer[5];
		       return (ORBitSmallSkeleton)
			  _ORBIT_skel_small_GNOME_VFS_Daemon_getDrives;
		       break;
		    case 'V':
		       if (strcmp((opname + 4), "olumes"))
			  break;
		       *impl =
			  (gpointer) servant->vepv->GNOME_VFS_Daemon_epv->
			  getVolumes;
		       *m_data =
			  (gpointer) & GNOME_VFS_Daemon__iinterface.methods.
			  _buffer[4];
		       return (ORBitSmallSkeleton)
			  _ORBIT_skel_small_GNOME_VFS_Daemon_getVolumes;
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	switch (opname[1]) {
	  case 'e':
	     switch (opname[2]) {
	       case 'f':
		  if (strcmp((opname + 3), ""))
		     break;
		  *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
		  *m_data =
		     (gpointer) & Bonobo_Unknown__iinterface.methods.
		     _buffer[0];
		  return (ORBitSmallSkeleton)
		     _ORBIT_skel_small_Bonobo_Unknown_ref;
		  break;
	       case 'g':
		  switch (opname[3]) {
		    case 'i':
		       switch (opname[4]) {
			 case 's':
			    switch (opname[5]) {
			      case 't':
				 switch (opname[6]) {
				   case 'e':
				      switch (opname[7]) {
					case 'r':
					   switch (opname[8]) {
					     case 'C':
						if (strcmp
						    ((opname + 9), "lient"))
						   break;
						*impl =
						   (gpointer) servant->vepv->
						   GNOME_VFS_Daemon_epv->
						   registerClient;
						*m_data =
						   (gpointer) &
						   GNOME_VFS_Daemon__iinterface.
						   methods._buffer[0];
						return (ORBitSmallSkeleton)
						   _ORBIT_skel_small_GNOME_VFS_Daemon_registerClient;
						break;
					     case 'V':
						if (strcmp
						    ((opname + 9),
						     "olumeMonitor"))
						   break;
						*impl =
						   (gpointer) servant->vepv->
						   GNOME_VFS_Daemon_epv->
						   registerVolumeMonitor;
						*m_data =
						   (gpointer) &
						   GNOME_VFS_Daemon__iinterface.
						   methods._buffer[2];
						return (ORBitSmallSkeleton)
						   _ORBIT_skel_small_GNOME_VFS_Daemon_registerVolumeMonitor;
						break;
					     default:
						break;
					   }
					   break;
					default:
					   break;
				      }
				      break;
				   default:
				      break;
				 }
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_Daemon__init(PortableServer_Servant servant,
			   CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL, (ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_Daemon,
"IDL:GNOME/VFS/Daemon:1.0", &GNOME_VFS_Daemon__classid, NULL, &GNOME_VFS_Daemon__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_Daemon__fini,
			     ORBIT_VEPV_OFFSET(POA_GNOME_VFS_Daemon__vepv,
					       GNOME_VFS_Daemon_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET(POA_GNOME_VFS_Daemon__vepv,
					       Bonobo_Unknown_epv),
			     (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_Daemon__fini(PortableServer_Servant servant,
			   CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSmallSkeleton
get_skel_small_GNOME_VFS_AsyncDaemon(POA_GNOME_VFS_AsyncDaemon * servant,
				     const char *opname, gpointer * m_data,
				     gpointer * impl)
{
   switch (opname[0]) {
     case 'C':
	switch (opname[1]) {
	  case 'a':
	     if (strcmp((opname + 2), "ncel"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->Cancel;
	     *m_data =
		(gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods.
		_buffer[0];
	     return (ORBitSmallSkeleton)
		_ORBIT_skel_small_GNOME_VFS_AsyncDaemon_Cancel;
	     break;
	  case 'h':
	     if (strcmp((opname + 2), "eckSameFS"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->
		CheckSameFS;
	     *m_data =
		(gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods.
		_buffer[12];
	     return (ORBitSmallSkeleton)
		_ORBIT_skel_small_GNOME_VFS_AsyncDaemon_CheckSameFS;
	     break;
	  case 'r':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'a':
		       switch (opname[4]) {
			 case 't':
			    switch (opname[5]) {
			      case 'e':
				 switch (opname[6]) {
				   case '\0':
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_AsyncDaemon_epv->Create;
				      *m_data =
					 (gpointer) &
					 GNOME_VFS_AsyncDaemon__iinterface.
					 methods._buffer[2];
				      return (ORBitSmallSkeleton)
					 _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_Create;
				      break;
				   case 'S':
				      if (strcmp((opname + 7), "ymbolicLink"))
					 break;
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_AsyncDaemon_epv->
					 CreateSymbolicLink;
				      *m_data =
					 (gpointer) &
					 GNOME_VFS_AsyncDaemon__iinterface.
					 methods._buffer[14];
				      return (ORBitSmallSkeleton)
					 _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_CreateSymbolicLink;
				      break;
				   default:
				      break;
				 }
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'F':
	if (strcmp((opname + 1), "indDirectory"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->FindDirectory;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[7];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_FindDirectory;
	break;
     case 'G':
	if (strcmp((opname + 1), "etFileInfo"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->GetFileInfo;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[4];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_GetFileInfo;
	break;
     case 'I':
	if (strcmp((opname + 1), "sLocal"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->IsLocal;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[6];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_IsLocal;
	break;
     case 'M':
	switch (opname[1]) {
	  case 'a':
	     if (strcmp((opname + 2), "keDirectory"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->
		MakeDirectory;
	     *m_data =
		(gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods.
		_buffer[8];
	     return (ORBitSmallSkeleton)
		_ORBIT_skel_small_GNOME_VFS_AsyncDaemon_MakeDirectory;
	     break;
	  case 'o':
	     switch (opname[2]) {
	       case 'n':
		  if (strcmp((opname + 3), "itorAdd"))
		     break;
		  *impl =
		     (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->
		     MonitorAdd;
		  *m_data =
		     (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods.
		     _buffer[15];
		  return (ORBitSmallSkeleton)
		     _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_MonitorAdd;
		  break;
	       case 'v':
		  if (strcmp((opname + 3), "e"))
		     break;
		  *impl =
		     (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->
		     Move;
		  *m_data =
		     (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods.
		     _buffer[10];
		  return (ORBitSmallSkeleton)
		     _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_Move;
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'O':
	switch (opname[1]) {
	  case 'p':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'n':
		       switch (opname[4]) {
			 case '\0':
			    *impl =
			       (gpointer) servant->vepv->
			       GNOME_VFS_AsyncDaemon_epv->Open;
			    *m_data =
			       (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.
			       methods._buffer[1];
			    return (ORBitSmallSkeleton)
			       _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_Open;
			    break;
			 case 'D':
			    if (strcmp((opname + 5), "irectory"))
			       break;
			    *impl =
			       (gpointer) servant->vepv->
			       GNOME_VFS_AsyncDaemon_epv->OpenDirectory;
			    *m_data =
			       (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.
			       methods._buffer[3];
			    return (ORBitSmallSkeleton)
			       _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_OpenDirectory;
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'R':
	if (strcmp((opname + 1), "emoveDirectory"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->
	   RemoveDirectory;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[9];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_RemoveDirectory;
	break;
     case 'S':
	if (strcmp((opname + 1), "etFileInfo"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->SetFileInfo;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[13];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_SetFileInfo;
	break;
     case 'T':
	if (strcmp((opname + 1), "runcate"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->Truncate;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[5];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_Truncate;
	break;
     case 'U':
	if (strcmp((opname + 1), "nlink"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_AsyncDaemon_epv->Unlink;
	*m_data =
	   (gpointer) & GNOME_VFS_AsyncDaemon__iinterface.methods._buffer[11];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_GNOME_VFS_AsyncDaemon_Unlink;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[2];
	return (ORBitSmallSkeleton)
	   _ORBIT_skel_small_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[0];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	*m_data = (gpointer) & Bonobo_Unknown__iinterface.methods._buffer[1];
	return (ORBitSmallSkeleton) _ORBIT_skel_small_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

void
POA_GNOME_VFS_AsyncDaemon__init(PortableServer_Servant servant,
				CORBA_Environment * env)
{
   static PortableServer_ClassInfo class_info =
      { NULL,
(ORBit_small_impl_finder) & get_skel_small_GNOME_VFS_AsyncDaemon, "IDL:GNOME/VFS/AsyncDaemon:1.0",
&GNOME_VFS_AsyncDaemon__classid, NULL, &GNOME_VFS_AsyncDaemon__iinterface };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBit_skel_class_register(&class_info,
			     servant, POA_GNOME_VFS_AsyncDaemon__fini,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_AsyncDaemon__vepv,
			      GNOME_VFS_AsyncDaemon_epv),
			     (CORBA_unsigned_long) Bonobo_Unknown__classid,
			     ORBIT_VEPV_OFFSET
			     (POA_GNOME_VFS_AsyncDaemon__vepv,
			      Bonobo_Unknown_epv), (CORBA_unsigned_long) 0);
}

void
POA_GNOME_VFS_AsyncDaemon__fini(PortableServer_Servant servant,
				CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}
