/* note to self :
   clean out expect_level stuff
*/

{
  guint j;

  guint stop_sample = num_samples;	/* meaning : don't stop */
  char direction;			/* are we rising or falling ? 
					   = sign of rise */
  register double *plevel = &filter->level;
  double increase = filter->increase;
  double rise;
  double expect_level;			/* level expected at end */
  double block_length;
  guint rate = 44100 /* filter->rate */ ;
  
  /*
   * process data here  
   * input sample data enters in *in_data as 8 or 16 bit data
   * samples for left and right channel are interleaved
   * so num_samples is for both channels combined
   */

  if (filter->envelope_active)
  {
    increase = filter->increase;

    if (increase > 0.0) { direction = 1; }
    else if (increase < 0.0) { direction = -1; }
    else { direction = 0; }
    expect_level = filter->level + increase * num_samples / 2;
    block_length = (double) num_samples / (2 * rate);

//    printf ("DEBUG : direction %d, expect_level %f\n", direction, expect_level);
//    if (direction * expect_level > direction * filter->next_level)
    if (block_length > filter->next_time - filter->run_time)
    {
//      printf ("DEBUG : block_length %f, stop coming\n", block_length);
      stop_sample = 2 * (filter->next_level - filter->level) /
                    increase;
      stop_sample = 2 * (guint) (rate * (filter->next_time -
filter->run_time));
      GST_DEBUG (MSG_E_IDX, "control point at sample %d",
	         stop_sample);
    }

    if (filter->level > 1.0)
    {
      /* a level > 1.0 could cause distortion if your input samples
	 can be full-range */
      printf ("ERROR : level is %f at %f\n",
	         filter->level, filter->run_time);
      GST_DEBUG (MSG_E_IDX, "\t rise is %f, increase %e",
	         filter->rise, filter->increase);
      print_volume_envelope (filter);
      filter->level = 1.0;
      filter->increase = 0.0;
    }

    if (filter->run_time > filter->next_time)
    {
      printf ("ERROR : evenlope control points were not supplied in the right order !\n");
    }
  }

  /* if stop_sample is smaller than num_samples, we should split the loop */
  if (stop_sample < num_samples)
  {
    for (j = 0; j < stop_sample; j += 2)
    {
       (*out_data)[j] = in_data[j] * (*plevel);
       (*out_data)[j + 1] = in_data[j + 1] * (*plevel);
       *plevel += increase;
    }
    increase = 0.0;

    *plevel = filter->next_level;
    GST_DEBUG (MSG_E_IDX, "volenv : loop split at sample %d : level is %f", stop_sample, *plevel);
    filter->increase = 0.0;

    {
      double *pnt, *pnl;

      GST_DEBUG (MSG_E_IDX, "reached cp at %f, level  %f",
		 filter->next_time,
	         filter->level);

      /* next control point has been reached; update variables */

      /* first, update next pointer */
      filter->next_cp = g_list_next (g_list_next (filter->next_cp));
      if (filter->next_cp != NULL)
      {
        /* end has not been reached yet */
        pnt = filter->next_cp->data;
        pnl = filter->next_cp->next->data;
        filter->next_time = *pnt;
        filter->next_level = *pnl;

        /* next, calculate rise */
        rise = (*pnl - filter->level) / (*pnt - filter->run_time);
      }
      else
      {
        GST_DEBUG (MSG_E_IDX, "volenv : reached last control point.");
        filter->envelope_active = FALSE;
	rise = 0.0;
      }
//      printf ("New rise : %lf\n", rise);
      g_object_set(G_OBJECT(filter), "rise", rise, NULL); 
      increase = filter->increase;
    }

    for (j = stop_sample; j < num_samples; j += 2)
    {
       (*out_data)[j] = in_data[j] * (*plevel);
       (*out_data)[j + 1] = in_data[j + 1] * (*plevel);
    }
  }
  else
  {
    for (j = 0; j < num_samples; j += 2) {
       if (j > stop_sample) { printf ("level : %f\n", *plevel); }
       (*out_data)[j] = in_data[j] * (*plevel);
       (*out_data)[j + 1] = in_data[j + 1] * (*plevel);
       *plevel += increase;
    }
  }
}

