/*
 * This file was generated by orbit-idl - DO NOT EDIT!
 */

#include <string.h>
#include "Editor.h"

void
_ORBIT_GNOME_GtkHTML_Editor_Resolver_NotFound_marshal(GIOPSendBuffer *
						      _ORBIT_send_buffer,
						      CORBA_Environment * ev)
{
}

void
_ORBIT_skel_GNOME_GtkHTML_Editor_Resolver_loadURL
   (POA_GNOME_GtkHTML_Editor_Resolver * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_loadURL) (PortableServer_Servant _servant,
			   const Bonobo_ProgressiveDataSink sink,
			   const CORBA_char * url, CORBA_Environment * ev))
{
   Bonobo_ProgressiveDataSink sink;
   CORBA_char *url;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 sink =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 url = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(url[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      } else {
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 sink =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 url = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(url[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      }
   }
   _impl_loadURL(_ORBIT_servant, sink, url, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else if (ev->_major == CORBA_USER_EXCEPTION) {
	    static const ORBit_exception_marshal_info _ORBIT_user_exceptions[]
	       =
	       { {(const CORBA_TypeCode)
		  &TC_GNOME_GtkHTML_Editor_Resolver_NotFound_struct,
		  (gpointer)
		  _ORBIT_GNOME_GtkHTML_Editor_Resolver_NotFound_marshal},
	       {CORBA_OBJECT_NIL, NULL} };
	    ORBit_send_user_exception(_ORBIT_send_buffer, ev,
				      _ORBIT_user_exceptions);
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      CORBA_Object_release((CORBA_Object) sink, ev);
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Listener_event
   (POA_GNOME_GtkHTML_Editor_Listener * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_any * (*_impl_event) (PortableServer_Servant _servant,
				const CORBA_char * name,
				const CORBA_any * arg,
				CORBA_Environment * ev))
{
   CORBA_any *_ORBIT_retval;
   CORBA_char *name;
   CORBA_any arg = { NULL, NULL, CORBA_FALSE };

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(name[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 ORBit_demarshal_any(_ORBIT_recv_buffer, &(arg), CORBA_TRUE,
			     (((ORBit_ObjectKey *) _ORBIT_servant->_private)->
			      object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(name[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 ORBit_demarshal_any(_ORBIT_recv_buffer, &(arg), CORBA_TRUE,
			     (((ORBit_ObjectKey *) _ORBIT_servant->_private)->
			      object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      }
   }
   _ORBIT_retval = _impl_event(_ORBIT_servant, name, &(arg), ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    ORBit_marshal_any(_ORBIT_send_buffer, &((*_ORBIT_retval)));
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      if (ev->_major == CORBA_NO_EXCEPTION)
	 CORBA_free(_ORBIT_retval);
      CORBA_any__free(&arg, NULL, CORBA_FALSE);
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine__get_listener
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    GNOME_GtkHTML_Editor_Listener(*_impl__get_listener)
    (PortableServer_Servant _servant, CORBA_Environment * ev))
{
   GNOME_GtkHTML_Editor_Listener _ORBIT_retval;

   _ORBIT_retval = _impl__get_listener(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    ORBit_marshal_object(_ORBIT_send_buffer, _ORBIT_retval);
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      if (ev->_major == CORBA_NO_EXCEPTION)
	 CORBA_Object_release(_ORBIT_retval, ev);
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine__set_listener
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl__set_listener) (PortableServer_Servant _servant,
				 const GNOME_GtkHTML_Editor_Listener value,
				 CORBA_Environment * ev))
{
   GNOME_GtkHTML_Editor_Listener value;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 value =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      } else {
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 value =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      }
   }
   _impl__set_listener(_ORBIT_servant, value, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      CORBA_Object_release((CORBA_Object) value, ev);
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_runCommand
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_boolean(*_impl_runCommand) (PortableServer_Servant _servant,
				      const CORBA_char * command,
				      CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_char *command;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 command = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(command[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 command = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(command[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      }
   }
   _ORBIT_retval = _impl_runCommand(_ORBIT_servant, command, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_getParagraphData
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_char * (*_impl_getParagraphData) (PortableServer_Servant _servant,
					    const CORBA_char * key,
					    CORBA_Environment * ev))
{
   CORBA_char *_ORBIT_retval;
   CORBA_char *key;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      }
   }
   _ORBIT_retval = _impl_getParagraphData(_ORBIT_servant, key, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    register CORBA_unsigned_long _ORBIT_tmpvar_2;
	    CORBA_unsigned_long _ORBIT_tmpvar_3;

	    _ORBIT_tmpvar_3 = strlen(_ORBIT_retval) + 1;
	    giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
					     (_ORBIT_send_buffer), 4);
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_tmpvar_3));
	       memcpy(_ORBIT_t, &(_ORBIT_tmpvar_3), sizeof(_ORBIT_tmpvar_3));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_tmpvar_3));
	    }
	    giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					   (_ORBIT_send_buffer),
					   (_ORBIT_retval),
					   sizeof(_ORBIT_retval
						  [_ORBIT_tmpvar_2]) *
					   _ORBIT_tmpvar_3);
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      if (ev->_major == CORBA_NO_EXCEPTION)
	 CORBA_free(_ORBIT_retval);
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_setParagraphData
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_setParagraphData) (PortableServer_Servant _servant,
				    const CORBA_char * key,
				    const CORBA_char * value,
				    CORBA_Environment * ev))
{
   CORBA_char *key;
   CORBA_char *value;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_4;
      CORBA_unsigned_long _ORBIT_tmpvar_5;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_5))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 value = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(value[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 value = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(value[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      }
   }
   _impl_setParagraphData(_ORBIT_servant, key, value, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_setObjectDataByType
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_setObjectDataByType) (PortableServer_Servant _servant,
				       const CORBA_char * type_name,
				       const CORBA_char * key,
				       const CORBA_char * data,
				       CORBA_Environment * ev))
{
   CORBA_char *type_name;
   CORBA_char *key;
   CORBA_char *data;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;
      register CORBA_unsigned_long _ORBIT_tmpvar_8;
      CORBA_unsigned_long _ORBIT_tmpvar_9;
      register CORBA_unsigned_long _ORBIT_tmpvar_10;
      CORBA_unsigned_long _ORBIT_tmpvar_11;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 type_name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(type_name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_9))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_8]) * _ORBIT_tmpvar_9;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_11))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 data = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(data[_ORBIT_tmpvar_10]) * _ORBIT_tmpvar_11;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 type_name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(type_name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_9 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_8]) * _ORBIT_tmpvar_9;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_11 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 data = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(data[_ORBIT_tmpvar_10]) * _ORBIT_tmpvar_11;
      }
   }
   _impl_setObjectDataByType(_ORBIT_servant, type_name, key, data, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_searchByData
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_boolean(*_impl_searchByData) (PortableServer_Servant _servant,
					const CORBA_long level,
					const CORBA_char * klass,
					const CORBA_char * key,
					const CORBA_char * value,
					CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_long level;
   CORBA_char *klass;
   CORBA_char *key;
   CORBA_char *value;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;
      register CORBA_unsigned_long _ORBIT_tmpvar_8;
      CORBA_unsigned_long _ORBIT_tmpvar_9;
      register CORBA_unsigned_long _ORBIT_tmpvar_10;
      CORBA_unsigned_long _ORBIT_tmpvar_11;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (level))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 klass = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(klass[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_9))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_8]) * _ORBIT_tmpvar_9;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_11))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 value = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(value[_ORBIT_tmpvar_10]) * _ORBIT_tmpvar_11;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 level = *((CORBA_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 klass = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(klass[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_9 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 key = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(key[_ORBIT_tmpvar_8]) * _ORBIT_tmpvar_9;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_11 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 value = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(value[_ORBIT_tmpvar_10]) * _ORBIT_tmpvar_11;
      }
   }
   _ORBIT_retval =
      _impl_searchByData(_ORBIT_servant, level, klass, key, value, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_boolean(*_impl_isParagraphEmpty) (PortableServer_Servant _servant,
					    CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;

   _ORBIT_retval = _impl_isParagraphEmpty(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_boolean(*_impl_isPreviousParagraphEmpty) (PortableServer_Servant
						    _servant,
						    CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;

   _ORBIT_retval = _impl_isPreviousParagraphEmpty(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_insertHTML
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_insertHTML) (PortableServer_Servant _servant,
			      const CORBA_char * html,
			      CORBA_Environment * ev))
{
   CORBA_char *html;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 html = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(html[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 html = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(html[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      }
   }
   _impl_insertHTML(_ORBIT_servant, html, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_freeze(POA_GNOME_GtkHTML_Editor_Engine
					       * _ORBIT_servant,
					       GIOPRecvBuffer *
					       _ORBIT_recv_buffer,
					       CORBA_Environment * ev,
					       void (*_impl_freeze)
					       (PortableServer_Servant
						_servant,
						CORBA_Environment * ev))
{
   _impl_freeze(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_thaw(POA_GNOME_GtkHTML_Editor_Engine *
					     _ORBIT_servant,
					     GIOPRecvBuffer *
					     _ORBIT_recv_buffer,
					     CORBA_Environment * ev,
					     void (*_impl_thaw)
					     (PortableServer_Servant _servant,
					      CORBA_Environment * ev))
{
   _impl_thaw(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_undo_begin
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_undo_begin) (PortableServer_Servant _servant,
			      const CORBA_char * undo_name,
			      const CORBA_char * redo_name,
			      CORBA_Environment * ev))
{
   CORBA_char *undo_name;
   CORBA_char *redo_name;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_4;
      CORBA_unsigned_long _ORBIT_tmpvar_5;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_5))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 undo_name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(undo_name[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 redo_name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(redo_name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 undo_name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(undo_name[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 redo_name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(redo_name[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      }
   }
   _impl_undo_begin(_ORBIT_servant, undo_name, redo_name, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_undo_end
   (POA_GNOME_GtkHTML_Editor_Engine * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_undo_end) (PortableServer_Servant _servant,
			    CORBA_Environment * ev))
{
   _impl_undo_end(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
static ORBitSkeleton
get_skel_GNOME_GtkHTML_Editor_Resolver(POA_GNOME_GtkHTML_Editor_Resolver *
				       servant,
				       GIOPRecvBuffer * _ORBIT_recv_buffer,
				       gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'l':
	if (strcmp((opname + 1), "oadURL"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Resolver_epv->
	   loadURL;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_GtkHTML_Editor_Resolver_loadURL;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_GtkHTML_Editor_Resolver(CORBA_Object obj,
						POA_GNOME_GtkHTML_Editor_Resolver
						* servant)
{
   obj->vepv[Bonobo_Unknown__classid] = servant->vepv->Bonobo_Unknown_epv;
   obj->vepv[GNOME_GtkHTML_Editor_Resolver__classid] =
      servant->vepv->GNOME_GtkHTML_Editor_Resolver_epv;
}

void
POA_GNOME_GtkHTML_Editor_Resolver__init(PortableServer_Servant servant,
					CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_GtkHTML_Editor_Resolver,
"IDL:GNOME/GtkHTML/Editor/Resolver:1.0",
(ORBit_local_objref_init) & init_local_objref_GNOME_GtkHTML_Editor_Resolver };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_GtkHTML_Editor_Resolver__classid)
      GNOME_GtkHTML_Editor_Resolver__classid =
	 ORBit_register_class(&class_info);
}

void
POA_GNOME_GtkHTML_Editor_Resolver__fini(PortableServer_Servant servant,
					CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSkeleton
get_skel_GNOME_GtkHTML_Editor_Listener(POA_GNOME_GtkHTML_Editor_Listener *
				       servant,
				       GIOPRecvBuffer * _ORBIT_recv_buffer,
				       gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'e':
	if (strcmp((opname + 1), "vent"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Listener_epv->event;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_GtkHTML_Editor_Listener_event;
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	if (strcmp((opname + 1), "ef"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_ref;
	break;
     case 'u':
	if (strcmp((opname + 1), "nref"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_unref;
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_GtkHTML_Editor_Listener(CORBA_Object obj,
						POA_GNOME_GtkHTML_Editor_Listener
						* servant)
{
   obj->vepv[Bonobo_Unknown__classid] = servant->vepv->Bonobo_Unknown_epv;
   obj->vepv[GNOME_GtkHTML_Editor_Listener__classid] =
      servant->vepv->GNOME_GtkHTML_Editor_Listener_epv;
}

void
POA_GNOME_GtkHTML_Editor_Listener__init(PortableServer_Servant servant,
					CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_GtkHTML_Editor_Listener,
"IDL:GNOME/GtkHTML/Editor/Listener:1.0",
(ORBit_local_objref_init) & init_local_objref_GNOME_GtkHTML_Editor_Listener };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_GtkHTML_Editor_Listener__classid)
      GNOME_GtkHTML_Editor_Listener__classid =
	 ORBit_register_class(&class_info);
}

void
POA_GNOME_GtkHTML_Editor_Listener__fini(PortableServer_Servant servant,
					CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSkeleton
get_skel_GNOME_GtkHTML_Editor_Engine(POA_GNOME_GtkHTML_Editor_Engine *
				     servant,
				     GIOPRecvBuffer * _ORBIT_recv_buffer,
				     gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case '_':
	switch (opname[1]) {
	  case 'g':
	     if (strcmp((opname + 2), "et_listener"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
		_get_listener;
	     return (ORBitSkeleton)
		_ORBIT_skel_GNOME_GtkHTML_Editor_Engine__get_listener;
	     break;
	  case 's':
	     if (strcmp((opname + 2), "et_listener"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
		_set_listener;
	     return (ORBitSkeleton)
		_ORBIT_skel_GNOME_GtkHTML_Editor_Engine__set_listener;
	     break;
	  default:
	     break;
	}
	break;
     case 'f':
	if (strcmp((opname + 1), "reeze"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->freeze;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_freeze;
	break;
     case 'g':
	if (strcmp((opname + 1), "etParagraphData"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
	   getParagraphData;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_getParagraphData;
	break;
     case 'i':
	switch (opname[1]) {
	  case 'n':
	     if (strcmp((opname + 2), "sertHTML"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
		insertHTML;
	     return (ORBitSkeleton)
		_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_insertHTML;
	     break;
	  case 's':
	     switch (opname[2]) {
	       case 'P':
		  switch (opname[3]) {
		    case 'a':
		       if (strcmp((opname + 4), "ragraphEmpty"))
			  break;
		       *impl =
			  (gpointer) servant->vepv->
			  GNOME_GtkHTML_Editor_Engine_epv->isParagraphEmpty;
		       return (ORBitSkeleton)
			  _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_isParagraphEmpty;
		       break;
		    case 'r':
		       if (strcmp((opname + 4), "eviousParagraphEmpty"))
			  break;
		       *impl =
			  (gpointer) servant->vepv->
			  GNOME_GtkHTML_Editor_Engine_epv->
			  isPreviousParagraphEmpty;
		       return (ORBitSkeleton)
			  _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_isPreviousParagraphEmpty;
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'q':
	if (strcmp((opname + 1), "ueryInterface"))
	   break;
	*impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->queryInterface;
	return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_queryInterface;
	break;
     case 'r':
	switch (opname[1]) {
	  case 'e':
	     if (strcmp((opname + 2), "f"))
		break;
	     *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->ref;
	     return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_ref;
	     break;
	  case 'u':
	     if (strcmp((opname + 2), "nCommand"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->
		runCommand;
	     return (ORBitSkeleton)
		_ORBIT_skel_GNOME_GtkHTML_Editor_Engine_runCommand;
	     break;
	  default:
	     break;
	}
	break;
     case 's':
	switch (opname[1]) {
	  case 'e':
	     switch (opname[2]) {
	       case 'a':
		  if (strcmp((opname + 3), "rchByData"))
		     break;
		  *impl =
		     (gpointer) servant->vepv->
		     GNOME_GtkHTML_Editor_Engine_epv->searchByData;
		  return (ORBitSkeleton)
		     _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_searchByData;
		  break;
	       case 't':
		  switch (opname[3]) {
		    case 'O':
		       if (strcmp((opname + 4), "bjectDataByType"))
			  break;
		       *impl =
			  (gpointer) servant->vepv->
			  GNOME_GtkHTML_Editor_Engine_epv->
			  setObjectDataByType;
		       return (ORBitSkeleton)
			  _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_setObjectDataByType;
		       break;
		    case 'P':
		       if (strcmp((opname + 4), "aragraphData"))
			  break;
		       *impl =
			  (gpointer) servant->vepv->
			  GNOME_GtkHTML_Editor_Engine_epv->setParagraphData;
		       return (ORBitSkeleton)
			  _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_setParagraphData;
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 't':
	if (strcmp((opname + 1), "haw"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_GtkHTML_Editor_Engine_epv->thaw;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_thaw;
	break;
     case 'u':
	switch (opname[1]) {
	  case 'n':
	     switch (opname[2]) {
	       case 'd':
		  switch (opname[3]) {
		    case 'o':
		       switch (opname[4]) {
			 case '_':
			    switch (opname[5]) {
			      case 'b':
				 if (strcmp((opname + 6), "egin"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_GtkHTML_Editor_Engine_epv->
				    undo_begin;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_undo_begin;
				 break;
			      case 'e':
				 if (strcmp((opname + 6), "nd"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_GtkHTML_Editor_Engine_epv->undo_end;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_GtkHTML_Editor_Engine_undo_end;
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       case 'r':
		  if (strcmp((opname + 3), "ef"))
		     break;
		  *impl = (gpointer) servant->vepv->Bonobo_Unknown_epv->unref;
		  return (ORBitSkeleton) _ORBIT_skel_Bonobo_Unknown_unref;
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_GtkHTML_Editor_Engine(CORBA_Object obj,
					      POA_GNOME_GtkHTML_Editor_Engine
					      * servant)
{
   obj->vepv[Bonobo_Unknown__classid] = servant->vepv->Bonobo_Unknown_epv;
   obj->vepv[GNOME_GtkHTML_Editor_Engine__classid] =
      servant->vepv->GNOME_GtkHTML_Editor_Engine_epv;
}

void
POA_GNOME_GtkHTML_Editor_Engine__init(PortableServer_Servant servant,
				      CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_GtkHTML_Editor_Engine,
"IDL:GNOME/GtkHTML/Editor/Engine:1.0", (ORBit_local_objref_init) & init_local_objref_GNOME_GtkHTML_Editor_Engine };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   POA_Bonobo_Unknown__init(servant, env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_GtkHTML_Editor_Engine__classid)
      GNOME_GtkHTML_Editor_Engine__classid =
	 ORBit_register_class(&class_info);
}

void
POA_GNOME_GtkHTML_Editor_Engine__fini(PortableServer_Servant servant,
				      CORBA_Environment * env)
{
   POA_Bonobo_Unknown__fini(servant, env);
   PortableServer_ServantBase__fini(servant, env);
}
