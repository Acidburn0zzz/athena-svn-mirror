/*
 * kautils.h:
 * This file is automatically generated; please do not edit it.
 */
/* Including kautils.p.h at beginning of kautils.h file. */

/* Copyright (C) 1990, 1989 Transarc Corporation - All rights reserved */
/*
 * P_R_P_Q_# (C) COPYRIGHT IBM CORPORATION 1988, 1989
 * LICENSED MATERIALS - PROPERTY OF IBM
 * REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER G120-2083
 */

/* $Header: /afs/dev.mit.edu/source/repository/third/afsbin/arch/sun4x_56/include/afs/kautils.h,v 1.1.1.1 1998-02-20 21:35:28 ghudson Exp $ */

/* $Log: not supported by cvs2svn $
 * Revision 2.11  1997/01/15  22:28:42  zumach
 * This delta implements integrated login for AFS on Digital Unix 4.0. This
 * is a checkpoint of the delta where many things work. Included are:
 * 1) basic login, telnet and ftp using vendor's programs.
 * 2) groups command returns correct group list.
 * 3) integrated login gets a token.
 *
 * The CDE lock feature partially works. The test-reauth program included here
 * does the basic re-auth call. However, when trying to unlock the window,
 * I get the AFS mechanism to succeed and then dtlogin dumps core. To
 * implement this, I've added a ka_VerifyUserPassword call. This call gets the
 * ticket from the kaserver by the usual means, but does not put a token
 * in the client. This is so we don't extend token lifetimes as a side effect
 * (or possibly get a new token, if the old one has expired). These should
 * always be explicit actions.
 *
 * To do:
 * 1) Fix the CDE lock.
 * 2) Fix the src/Makefile to not build things we no longer need.
 * 3) Modify the afs startup script. It starts after DCE, and so we can
 *    ensure that DCE is before AFS in the matrix. This means that DCE can
 *    set pwd if it wants to.
 * 4) Test DCE and AFS interaction.
 * 5) Numerous other tests:
 *    rsh
 *    rcp
 *    what happens when the user is not in the passwd file?
 *
 *
 * More documentation is coming.
 *
 * Add new flag KA_USERAUTH_ONLY_VERIFY for ka_UserAuthenticateGeneral.
 * [from r2.9 by delta zumach-afs3.4-8287-add.SIA.mechanism.for.dux40, r1.1]
 *
 * Revision 2.2  1990/09/27  13:51:37  ota
 * Declare (char *) returning function ka_timestr().
 * Cleanups.
 *
 * Revision 2.1  90/08/07  19:11:51  hines
 * Start with clean version to sync test and dev trees.
 * */
/* See RCS log for older history. */

#ifndef __KAUTILS__
#define __KAUTILS__

#include <des.h>
#include <afs/auth.h>

#ifndef KAMAJORVERSION
    /* just to be on the safe side, get these two first */
#include <sys/types.h>
#include <rx/xdr.h>

    /* get installed .h file only if not included already from local dir */
#ifndef _RXGEN_KAUTH_
#include <afs/kauth.h>
#endif

#endif

#ifndef INADDR_LOOPBACK
#define INADDR_LOOPBACK 0x7f000001	/* in host order */
#endif

extern char *ka_LocalCell();
extern char *ka_timestr();
extern char *ucstring();
extern char *lcstring();

#define KA_USERAUTH_VERSION 1
#define KA_USERAUTH_VERSION_MASK	0x00ffff
#define KA_USERAUTH_DOSETPAG		0x010000
#define KA_USERAUTH_DOSETPAG2		0x020000
#define KA_USERAUTH_ONLY_VERIFY		0x040000
#define ka_UserAuthenticate(n,i,r,p,d,rP) \
    ka_UserAuthenticateGeneral \
        (KA_USERAUTH_VERSION + ((d) ? KA_USERAUTH_DOSETPAG : 0), \
	 n,i,r,p, /*lifetime*/0, /*spare1,2*/0,0, rP)
#define ka_UserAuthenticateLife(f,n,i,r,p,l,rP) \
    ka_UserAuthenticateGeneral \
        (KA_USERAUTH_VERSION + (f), n,i,r,p,l, /*spare1,2*/0,0, rP)

extern int32 KAM_CreateUser();
extern int32 KAM_DeleteUser();
extern int32 KAA_ChangePassword();
extern int32 KAM_SetPassword();
extern int32 KAA_Authenticate(), KAA_AuthenticateV2();
extern int32 KAT_GetTicket();
extern int32 KAM_SetFields();
#define KA_REUSEPW 1
#define KA_NOREUSEPW 2
#define KA_ISLOCKED 4                

extern int32 KAM_GetEntry();
extern int32 KAM_ListEntry();
extern int32 KAM_GetStats();
extern int32 KAM_GetPassword();
extern int32 KAM_GetRandomKey();
extern int32 KAM_Debug();
extern int32 KAM_Unlock();
extern int32 KAM_LockStatus();

#define KA_AUTHENTICATION_SERVICE 731
#define KA_TICKET_GRANTING_SERVICE 732
#define KA_MAINTENANCE_SERVICE 733

#define RX_SCINDEX_NULL	0		/* No security */
#define RX_SCINDEX_VAB 	1		/* vice tokens, with bcrypt */
#define RX_SCINDEX_KAD	2		/* Kerberos/DES */

#define KA_TGS_NAME "krbtgt"
	/* realm is TGS instance */
#define KA_ADMIN_NAME "AuthServer"
#define KA_ADMIN_INST "Admin"

#define KA_LABELSIZE 4
#define KA_GETTGT_REQ_LABEL "gTGS"
#define KA_GETTGT_ANS_LABEL "tgsT"
#define KA_GETADM_REQ_LABEL "gADM"
#define KA_GETADM_ANS_LABEL "admT"
#define KA_CPW_REQ_LABEL "CPWl"
#define KA_CPW_ANS_LABEL "Pass"
#define KA_GETTICKET_ANS_LABEL "gtkt"

struct ka_gettgtRequest {			/* format of request */
    Date time;				/* time of request */
    char label[KA_LABELSIZE];		/* label to verify correct decrypt */
};

/* old interface: see ka_ticketAnswer instead */
struct ka_gettgtAnswer {		/* format of response */
    Date time;				/* the time of the request plus one */
    struct ktc_encryptionKey
         sessionkey;			/* the session key in the ticket */
    int32 kvno;				/* version # of tkt encrypting key */
    int32 ticket_len;			/* the ticket's length */
    char ticket[MAXKTCTICKETLEN];	/* the ticket itself (no padding) */
    char label[KA_LABELSIZE];		/* label to verify correct decrypt */
};

struct ka_ticketAnswer {		/* format of response */
    int32 cksum;				/* function to be defined */
    Date challenge;			/* the time of the request plus one */
    struct ktc_encryptionKey
         sessionKey;			/* the session key in the ticket */
    Date startTime;
    Date endTime;
    int32 kvno;				/* version of ticket encrypting key */
    int32 ticketLen;			/* the ticket's length */
    char name[MAXKTCNAMELEN];
    char instance[MAXKTCNAMELEN];
    char cell[MAXKTCNAMELEN];
    char sname[MAXKTCNAMELEN];
    char sinstance[MAXKTCNAMELEN];
    char ticket[MAXKTCTICKETLEN];	/* the ticket (no extra chars) */
    char label[KA_LABELSIZE];		/* for detecting decryption errors */
};

struct ka_cpwRequest {			/* format of request */
    Date time;				/* time of request */
    struct ktc_encryptionKey
	 newpw;				/* new key */
    int32 kvno;				/* version number of key */
    int32 spare;				/* must be zero */
    char label[KA_LABELSIZE];		/* label to verify correct decrypt */
};

struct ka_cpwAnswer {			/* format of response */
    Date time;				/* the time of the request plus one */
    char label[KA_LABELSIZE];		/* label to verify correct decrypt */
};

struct ka_getTicketTimes {
    Date start;
    Date end;
};

/* old interface: see ka_ticketAnswer instead */
struct ka_getTicketAnswer {
    struct ktc_encryptionKey sessionKey;
    Date startTime;
    Date endTime;
    int32 kvno;
    int32 ticketLen;
    char name[MAXKTCNAMELEN];
    char instance[MAXKTCNAMELEN];
    char cell[MAXKTCNAMELEN];
    char sname[MAXKTCNAMELEN];
    char sinstance[MAXKTCNAMELEN];
    char ticket[MAXKTCTICKETLEN];
};

#if 1
#ifndef ERROR_TABLE_BASE_ka
#define ka_ErrorString error_message
#undef  KAMINERROR
#define KAMINERROR ERROR_TABLE_BASE_ka
#define KAMAXERROR (KAMINERROR+255)
#endif

#else
/* begin error table */
/* end error table */
#endif

#endif

/* End of prolog file kautils.p.h. */

#define KADATABASEINCONSISTENT                   (180480L)
#define KAEXIST                                  (180481L)
#define KAIO                                     (180482L)
#define KACREATEFAIL                             (180483L)
#define KANOENT                                  (180484L)
#define KAEMPTY                                  (180485L)
#define KABADNAME                                (180486L)
#define KABADINDEX                               (180487L)
#define KANOAUTH                                 (180488L)
#define KAANSWERTOOLONG                          (180489L)
#define KABADREQUEST                             (180490L)
#define KAOLDINTERFACE                           (180491L)
#define KABADARGUMENT                            (180492L)
#define KABADCMD                                 (180493L)
#define KANOKEYS                                 (180494L)
#define KAREADPW                                 (180495L)
#define KABADKEY                                 (180496L)
#define KAUBIKINIT                               (180497L)
#define KAUBIKCALL                               (180498L)
#define KABADPROTOCOL                            (180499L)
#define KANOCELLS                                (180500L)
#define KANOCELL                                 (180501L)
#define KATOOMANYUBIKS                           (180502L)
#define KATOOMANYKEYS                            (180503L)
#define KABADTICKET                              (180504L)
#define KAUNKNOWNKEY                             (180505L)
#define KAKEYCACHEINVALID                        (180506L)
#define KABADSERVER                              (180507L)
#define KABADUSER                                (180508L)
#define KABADCPW                                 (180509L)
#define KABADCREATE                              (180510L)
#define KANOTICKET                               (180511L)
#define KAASSOCUSER                              (180512L)
#define KANOTSPECIAL                             (180513L)
#define KACLOCKSKEW                              (180514L)
#define KANORECURSE                              (180515L)
#define KARXFAIL                                 (180516L)
#define KANULLPASSWORD                           (180517L)
#define KAINTERNALERROR                          (180518L)
#define KAPWEXPIRED                              (180519L)
#define KAREUSED                                 (180520L)
#define KATOOSOON                                (180521L)
#define KALOCKED                                 (180522L)
extern void initialize_ka_error_table ();
#define ERROR_TABLE_BASE_ka (180480L)

/* for compatibility with older versions... */
#define init_ka_err_tbl initialize_ka_error_table
#define ka_err_base ERROR_TABLE_BASE_ka
