/*
 * This file was generated by orbit-idl - DO NOT EDIT!
 */

#include <string.h>
#include "gnome-vfs-slave.h"

void
_ORBIT_skel_GNOME_VFS_Slave_Request_open(POA_GNOME_VFS_Slave_Request *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_open)
					 (PortableServer_Servant _servant,
					  const CORBA_char * uri,
					  const GNOME_VFS_OpenMode open_mode,
					  CORBA_Environment * ev))
{
   CORBA_char *uri;
   GNOME_VFS_OpenMode open_mode;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (open_mode))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 open_mode = *((GNOME_VFS_OpenMode *) _ORBIT_curptr);
      }
   }
   _impl_open(_ORBIT_servant, uri, open_mode, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_open_as_channel
   (POA_GNOME_VFS_Slave_Request * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_open_as_channel) (PortableServer_Servant _servant,
				   const CORBA_char * uri,
				   const GNOME_VFS_OpenMode open_mode,
				   const CORBA_unsigned_long
				   advised_block_size,
				   CORBA_Environment * ev))
{
   CORBA_char *uri;
   GNOME_VFS_OpenMode open_mode;
   CORBA_unsigned_long advised_block_size;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (open_mode))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 (*((guint32 *) & (advised_block_size))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 open_mode = *((GNOME_VFS_OpenMode *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 advised_block_size = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _impl_open_as_channel(_ORBIT_servant, uri, open_mode, advised_block_size,
			 ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_create(POA_GNOME_VFS_Slave_Request *
					   _ORBIT_servant,
					   GIOPRecvBuffer *
					   _ORBIT_recv_buffer,
					   CORBA_Environment * ev,
					   void (*_impl_create)
					   (PortableServer_Servant _servant,
					    const CORBA_char * uri,
					    const GNOME_VFS_OpenMode
					    open_mode,
					    const CORBA_boolean exclusive,
					    const GNOME_VFS_Permission perm,
					    CORBA_Environment * ev))
{
   CORBA_char *uri;
   GNOME_VFS_OpenMode open_mode;
   CORBA_boolean exclusive;
   GNOME_VFS_Permission perm;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (open_mode))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 exclusive = *((CORBA_boolean *) _ORBIT_curptr);
	 _ORBIT_curptr += 1;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (perm))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 open_mode = *((GNOME_VFS_OpenMode *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 exclusive = *((CORBA_boolean *) _ORBIT_curptr);
	 _ORBIT_curptr += 1;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 perm = *((GNOME_VFS_Permission *) _ORBIT_curptr);
      }
   }
   _impl_create(_ORBIT_servant, uri, open_mode, exclusive, perm, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_create_as_channel
   (POA_GNOME_VFS_Slave_Request * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_create_as_channel) (PortableServer_Servant _servant,
				     const CORBA_char * uri,
				     const GNOME_VFS_OpenMode open_mode,
				     const CORBA_boolean exclusive,
				     const GNOME_VFS_Permission perm,
				     CORBA_Environment * ev))
{
   CORBA_char *uri;
   GNOME_VFS_OpenMode open_mode;
   CORBA_boolean exclusive;
   GNOME_VFS_Permission perm;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (open_mode))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 exclusive = *((CORBA_boolean *) _ORBIT_curptr);
	 _ORBIT_curptr += 1;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (perm))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 open_mode = *((GNOME_VFS_OpenMode *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 exclusive = *((CORBA_boolean *) _ORBIT_curptr);
	 _ORBIT_curptr += 1;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 perm = *((GNOME_VFS_Permission *) _ORBIT_curptr);
      }
   }
   _impl_create_as_channel(_ORBIT_servant, uri, open_mode, exclusive, perm,
			   ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_get_file_info(POA_GNOME_VFS_Slave_Request
						  * _ORBIT_servant,
						  GIOPRecvBuffer *
						  _ORBIT_recv_buffer,
						  CORBA_Environment * ev,
						  void (*_impl_get_file_info)
						  (PortableServer_Servant
						   _servant,
						   const
						   GNOME_VFS_Slave_URIList *
						   uri,
						   const
						   GNOME_VFS_Slave_FileInfoOptions
						   info_options,
						   CORBA_Environment * ev))
{
   GNOME_VFS_Slave_URIList uri = { 0, 0, NULL, CORBA_FALSE };
   GNOME_VFS_Slave_FileInfoOptions info_options;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_3;
      register CORBA_unsigned_long _ORBIT_tmpvar_4;
      CORBA_unsigned_long _ORBIT_tmpvar_5;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (uri._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 uri._buffer =
	    alloca(sizeof(uri._buffer[_ORBIT_tmpvar_3]) * uri._length);
	 uri._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_3 = 0; _ORBIT_tmpvar_3 < uri._length;
	      _ORBIT_tmpvar_3++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_5))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    uri._buffer[_ORBIT_tmpvar_3] = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(uri._buffer[_ORBIT_tmpvar_3][_ORBIT_tmpvar_4]) *
	       _ORBIT_tmpvar_5;
	 }

	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (info_options))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 uri._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 uri._buffer =
	    alloca(sizeof(uri._buffer[_ORBIT_tmpvar_3]) * uri._length);
	 uri._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_3 = 0; _ORBIT_tmpvar_3 < uri._length;
	      _ORBIT_tmpvar_3++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    uri._buffer[_ORBIT_tmpvar_3] = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(uri._buffer[_ORBIT_tmpvar_3][_ORBIT_tmpvar_4]) *
	       _ORBIT_tmpvar_5;
	 }

	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 info_options = *((GNOME_VFS_Slave_FileInfoOptions *) _ORBIT_curptr);
      }
   }
   _impl_get_file_info(_ORBIT_servant, &(uri), info_options, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_load_directory(POA_GNOME_VFS_Slave_Request
						   * _ORBIT_servant,
						   GIOPRecvBuffer *
						   _ORBIT_recv_buffer,
						   CORBA_Environment * ev,
						   void
						   (*_impl_load_directory)
						   (PortableServer_Servant
						    _servant,
						    const CORBA_char * uri,
						    const
						    GNOME_VFS_Slave_FileInfoOptions
						    info_options,
						    const
						    GNOME_VFS_Slave_DirectoryFilter
						    * filter,
						    const CORBA_unsigned_long
						    items_per_notification,
						    CORBA_Environment * ev))
{
   CORBA_char *uri;
   GNOME_VFS_Slave_FileInfoOptions info_options;
   GNOME_VFS_Slave_DirectoryFilter filter;
   CORBA_unsigned_long items_per_notification;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_4;
      CORBA_unsigned_long _ORBIT_tmpvar_5;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_5))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (info_options))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 (*((guint16 *) & (filter.type))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (filter.options))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 filter.pattern = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(filter.pattern[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (items_per_notification))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(uri[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 info_options = *((GNOME_VFS_Slave_FileInfoOptions *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 filter.type =
	    *((GNOME_VFS_Slave_DirectoryFilterType *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 filter.options =
	    *((GNOME_VFS_Slave_DirectoryFilterOptions *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 filter.pattern = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(filter.pattern[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 items_per_notification = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _impl_load_directory(_ORBIT_servant, uri, info_options, &(filter),
			items_per_notification, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_xfer(POA_GNOME_VFS_Slave_Request *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_xfer)
					 (PortableServer_Servant _servant,
					  const GNOME_VFS_Slave_URIList *
					  source_names,
					  const GNOME_VFS_Slave_URIList *
					  target_names,
					  const GNOME_VFS_Slave_XferOptions
					  options,
					  const
					  GNOME_VFS_Slave_XferOverwriteMode
					  overwrite_mode,
					  CORBA_Environment * ev))
{
   GNOME_VFS_Slave_URIList source_names = { 0, 0, NULL, CORBA_FALSE };
   GNOME_VFS_Slave_URIList target_names = { 0, 0, NULL, CORBA_FALSE };
   GNOME_VFS_Slave_XferOptions options;
   GNOME_VFS_Slave_XferOverwriteMode overwrite_mode;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      register CORBA_unsigned_long _ORBIT_tmpvar_7;
      CORBA_unsigned_long _ORBIT_tmpvar_8;
      register CORBA_unsigned_long _ORBIT_tmpvar_9;
      register CORBA_unsigned_long _ORBIT_tmpvar_10;
      CORBA_unsigned_long _ORBIT_tmpvar_11;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (source_names._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 source_names._buffer =
	    alloca(sizeof(source_names._buffer[_ORBIT_tmpvar_6]) *
		   source_names._length);
	 source_names._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_6 = 0; _ORBIT_tmpvar_6 < source_names._length;
	      _ORBIT_tmpvar_6++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_8))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    source_names._buffer[_ORBIT_tmpvar_6] = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(source_names.
		      _buffer[_ORBIT_tmpvar_6][_ORBIT_tmpvar_7]) *
	       _ORBIT_tmpvar_8;
	 }

	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (target_names._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 target_names._buffer =
	    alloca(sizeof(target_names._buffer[_ORBIT_tmpvar_9]) *
		   target_names._length);
	 target_names._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_9 = 0; _ORBIT_tmpvar_9 < target_names._length;
	      _ORBIT_tmpvar_9++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_11))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    target_names._buffer[_ORBIT_tmpvar_9] = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(target_names.
		      _buffer[_ORBIT_tmpvar_9][_ORBIT_tmpvar_10]) *
	       _ORBIT_tmpvar_11;
	 }

	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (options))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 (*((guint16 *) & (overwrite_mode))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 source_names._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 source_names._buffer =
	    alloca(sizeof(source_names._buffer[_ORBIT_tmpvar_6]) *
		   source_names._length);
	 source_names._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_6 = 0; _ORBIT_tmpvar_6 < source_names._length;
	      _ORBIT_tmpvar_6++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_8 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    source_names._buffer[_ORBIT_tmpvar_6] = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(source_names.
		      _buffer[_ORBIT_tmpvar_6][_ORBIT_tmpvar_7]) *
	       _ORBIT_tmpvar_8;
	 }

	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 target_names._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 target_names._buffer =
	    alloca(sizeof(target_names._buffer[_ORBIT_tmpvar_9]) *
		   target_names._length);
	 target_names._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_9 = 0; _ORBIT_tmpvar_9 < target_names._length;
	      _ORBIT_tmpvar_9++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_11 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    target_names._buffer[_ORBIT_tmpvar_9] = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(target_names.
		      _buffer[_ORBIT_tmpvar_9][_ORBIT_tmpvar_10]) *
	       _ORBIT_tmpvar_11;
	 }

	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 options = *((GNOME_VFS_Slave_XferOptions *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 overwrite_mode =
	    *((GNOME_VFS_Slave_XferOverwriteMode *) _ORBIT_curptr);
      }
   }
   _impl_xfer(_ORBIT_servant, &(source_names), &(target_names), options,
	      overwrite_mode, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_stop(POA_GNOME_VFS_Slave_Request *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_stop)
					 (PortableServer_Servant _servant,
					  CORBA_Environment * ev))
{
   _impl_stop(_ORBIT_servant, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_reset(POA_GNOME_VFS_Slave_Request *
					  _ORBIT_servant,
					  GIOPRecvBuffer * _ORBIT_recv_buffer,
					  CORBA_Environment * ev,
					  void (*_impl_reset)
					  (PortableServer_Servant _servant,
					   CORBA_Environment * ev))
{
   _impl_reset(_ORBIT_servant, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Request_die(POA_GNOME_VFS_Slave_Request *
					_ORBIT_servant,
					GIOPRecvBuffer * _ORBIT_recv_buffer,
					CORBA_Environment * ev,
					void (*_impl_die)
					(PortableServer_Servant _servant,
					 CORBA_Environment * ev))
{
   _impl_die(_ORBIT_servant, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_FileHandle_read(POA_GNOME_VFS_Slave_FileHandle *
					    _ORBIT_servant,
					    GIOPRecvBuffer *
					    _ORBIT_recv_buffer,
					    CORBA_Environment * ev,
					    void (*_impl_read)
					    (PortableServer_Servant _servant,
					     const CORBA_unsigned_long count,
					     CORBA_Environment * ev))
{
   CORBA_unsigned_long count;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (count))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 count = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _impl_read(_ORBIT_servant, count, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_FileHandle_write(POA_GNOME_VFS_Slave_FileHandle *
					     _ORBIT_servant,
					     GIOPRecvBuffer *
					     _ORBIT_recv_buffer,
					     CORBA_Environment * ev,
					     void (*_impl_write)
					     (PortableServer_Servant _servant,
					      const GNOME_VFS_Buffer * buffer,
					      CORBA_Environment * ev))
{
   GNOME_VFS_Buffer buffer = { 0, 0, NULL, CORBA_FALSE };

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_1;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (buffer._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 buffer._buffer = (CORBA_octet *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(buffer._buffer[_ORBIT_tmpvar_1]) * buffer._length;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 buffer._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 buffer._buffer = (CORBA_octet *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(buffer._buffer[_ORBIT_tmpvar_1]) * buffer._length;
      }
   }
   _impl_write(_ORBIT_servant, &(buffer), ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_FileHandle_close(POA_GNOME_VFS_Slave_FileHandle *
					     _ORBIT_servant,
					     GIOPRecvBuffer *
					     _ORBIT_recv_buffer,
					     CORBA_Environment * ev,
					     void (*_impl_close)
					     (PortableServer_Servant _servant,
					      CORBA_Environment * ev))
{
   _impl_close(_ORBIT_servant, ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Notify_open(POA_GNOME_VFS_Slave_Notify *
					_ORBIT_servant,
					GIOPRecvBuffer * _ORBIT_recv_buffer,
					CORBA_Environment * ev,
					void (*_impl_open)
					(PortableServer_Servant _servant,
					 const GNOME_VFS_Result result,
					 const GNOME_VFS_Slave_FileHandle
					 handle, CORBA_Environment * ev))
{
   GNOME_VFS_Result result;
   GNOME_VFS_Slave_FileHandle handle;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 handle =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey
				      *) _ORBIT_servant->_private)->object->
				    orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 handle =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey
				      *) _ORBIT_servant->_private)->object->
				    orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      }
   }
   _impl_open(_ORBIT_servant, result, handle, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      CORBA_Object_release(handle, ev);
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_open_as_channel(POA_GNOME_VFS_Slave_Notify
						   * _ORBIT_servant,
						   GIOPRecvBuffer *
						   _ORBIT_recv_buffer,
						   CORBA_Environment * ev,
						   void
						   (*_impl_open_as_channel)
						   (PortableServer_Servant
						    _servant,
						    const GNOME_VFS_Result
						    result,
						    const CORBA_char *
						    channel_path,
						    CORBA_Environment * ev))
{
   GNOME_VFS_Result result;
   CORBA_char *channel_path;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 channel_path = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(channel_path[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 channel_path = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(channel_path[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
      }
   }
   _impl_open_as_channel(_ORBIT_servant, result, channel_path, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_close(POA_GNOME_VFS_Slave_Notify *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_close)
					 (PortableServer_Servant _servant,
					  const GNOME_VFS_Result result,
					  CORBA_Environment * ev))
{
   GNOME_VFS_Result result;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
      }
   }
   _impl_close(_ORBIT_servant, result, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_read(POA_GNOME_VFS_Slave_Notify *
					_ORBIT_servant,
					GIOPRecvBuffer * _ORBIT_recv_buffer,
					CORBA_Environment * ev,
					void (*_impl_read)
					(PortableServer_Servant _servant,
					 const GNOME_VFS_Result result,
					 const GNOME_VFS_Buffer * data,
					 CORBA_Environment * ev))
{
   GNOME_VFS_Result result;
   GNOME_VFS_Buffer data = { 0, 0, NULL, CORBA_FALSE };

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_1;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (data._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 data._buffer = (CORBA_octet *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(data._buffer[_ORBIT_tmpvar_1]) * data._length;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 data._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 data._buffer = (CORBA_octet *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(data._buffer[_ORBIT_tmpvar_1]) * data._length;
      }
   }
   _impl_read(_ORBIT_servant, result, &(data), ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_write(POA_GNOME_VFS_Slave_Notify *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_write)
					 (PortableServer_Servant _servant,
					  const GNOME_VFS_Result result,
					  const CORBA_unsigned_long
					  bytes_written,
					  CORBA_Environment * ev))
{
   GNOME_VFS_Result result;
   CORBA_unsigned_long bytes_written;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (bytes_written))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 bytes_written = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _impl_write(_ORBIT_servant, result, bytes_written, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_load_directory(POA_GNOME_VFS_Slave_Notify *
						  _ORBIT_servant,
						  GIOPRecvBuffer *
						  _ORBIT_recv_buffer,
						  CORBA_Environment * ev,
						  void (*_impl_load_directory)
						  (PortableServer_Servant
						   _servant,
						   const GNOME_VFS_Result
						   result,
						   const
						   GNOME_VFS_Slave_FileInfoList
						   * files,
						   CORBA_Environment * ev))
{
   GNOME_VFS_Result result;
   GNOME_VFS_Slave_FileInfoList files = { 0, 0, NULL, CORBA_FALSE };

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_8;
      register CORBA_unsigned_long _ORBIT_tmpvar_9;
      register CORBA_unsigned_long _ORBIT_tmpvar_10;
      CORBA_unsigned_long _ORBIT_tmpvar_11;
      register CORBA_unsigned_long _ORBIT_tmpvar_12;
      CORBA_unsigned_long _ORBIT_tmpvar_13;
      register CORBA_unsigned_long _ORBIT_tmpvar_14;
      CORBA_unsigned_long _ORBIT_tmpvar_15;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (files._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 files._buffer =
	    alloca(sizeof(files._buffer[_ORBIT_tmpvar_8]) * files._length);
	 files._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_8 = 0; _ORBIT_tmpvar_8 < files._length;
	      _ORBIT_tmpvar_8++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*
	     ((guint32 *) & (files._buffer[_ORBIT_tmpvar_8].data._length))) =
	   GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].data._buffer =
	       (CORBA_octet *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].data.
		      _buffer[_ORBIT_tmpvar_9]) *
	       files._buffer[_ORBIT_tmpvar_8].data._length;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_11))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].name = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].name[_ORBIT_tmpvar_10]) *
	       _ORBIT_tmpvar_11;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_13))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].symlink_name =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].
		      symlink_name[_ORBIT_tmpvar_12]) * _ORBIT_tmpvar_13;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_15))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].mime_type = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].
		      mime_type[_ORBIT_tmpvar_14]) * _ORBIT_tmpvar_15;
	 }

      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 files._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 files._buffer =
	    alloca(sizeof(files._buffer[_ORBIT_tmpvar_8]) * files._length);
	 files._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_8 = 0; _ORBIT_tmpvar_8 < files._length;
	      _ORBIT_tmpvar_8++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    files._buffer[_ORBIT_tmpvar_8].data._length =
	       *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].data._buffer =
	       (CORBA_octet *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].data.
		      _buffer[_ORBIT_tmpvar_9]) *
	       files._buffer[_ORBIT_tmpvar_8].data._length;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_11 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].name = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].name[_ORBIT_tmpvar_10]) *
	       _ORBIT_tmpvar_11;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_13 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].symlink_name =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].
		      symlink_name[_ORBIT_tmpvar_12]) * _ORBIT_tmpvar_13;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_15 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    files._buffer[_ORBIT_tmpvar_8].mime_type = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(files._buffer[_ORBIT_tmpvar_8].
		      mime_type[_ORBIT_tmpvar_14]) * _ORBIT_tmpvar_15;
	 }

      }
   }
   _impl_load_directory(_ORBIT_servant, result, &(files), ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Notify_get_file_info(POA_GNOME_VFS_Slave_Notify *
						 _ORBIT_servant,
						 GIOPRecvBuffer *
						 _ORBIT_recv_buffer,
						 CORBA_Environment * ev,
						 void (*_impl_get_file_info)
						 (PortableServer_Servant
						  _servant,
						  const
						  GNOME_VFS_Slave_GetFileInfoResultList
						  * results,
						  CORBA_Environment * ev))
{
   GNOME_VFS_Slave_GetFileInfoResultList results =

      { 0, 0, NULL, CORBA_FALSE };
   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_10;
      register CORBA_unsigned_long _ORBIT_tmpvar_11;
      CORBA_unsigned_long _ORBIT_tmpvar_12;
      register CORBA_unsigned_long _ORBIT_tmpvar_13;
      register CORBA_unsigned_long _ORBIT_tmpvar_14;
      CORBA_unsigned_long _ORBIT_tmpvar_15;
      register CORBA_unsigned_long _ORBIT_tmpvar_16;
      CORBA_unsigned_long _ORBIT_tmpvar_17;
      register CORBA_unsigned_long _ORBIT_tmpvar_18;
      CORBA_unsigned_long _ORBIT_tmpvar_19;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (results._length))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 results._buffer =
	    alloca(sizeof(results._buffer[_ORBIT_tmpvar_10]) *
		   results._length);
	 results._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_10 = 0; _ORBIT_tmpvar_10 < results._length;
	      _ORBIT_tmpvar_10++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_12))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].uri = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].
		      uri[_ORBIT_tmpvar_11]) * _ORBIT_tmpvar_12;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	    
	       (*((guint16 *) & (results._buffer[_ORBIT_tmpvar_10].result))) =
	       GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*
	     ((guint32 *) &
	   (results._buffer[_ORBIT_tmpvar_10].file_info.data._length))) =
GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.data._buffer =
	       (CORBA_octet *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.data.
		      _buffer[_ORBIT_tmpvar_13]) *
	       results._buffer[_ORBIT_tmpvar_10].file_info.data._length;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_15))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.name =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.
		      name[_ORBIT_tmpvar_14]) * _ORBIT_tmpvar_15;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_17))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.symlink_name =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.
		      symlink_name[_ORBIT_tmpvar_16]) * _ORBIT_tmpvar_17;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    
	       (*((guint32 *) & (_ORBIT_tmpvar_19))) =
	       GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.mime_type =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.
		      mime_type[_ORBIT_tmpvar_18]) * _ORBIT_tmpvar_19;
	 }

      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 results._length = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 results._buffer =
	    alloca(sizeof(results._buffer[_ORBIT_tmpvar_10]) *
		   results._length);
	 results._release = CORBA_FALSE;
	 for (_ORBIT_tmpvar_10 = 0; _ORBIT_tmpvar_10 < results._length;
	      _ORBIT_tmpvar_10++) {
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_12 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].uri = (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].
		      uri[_ORBIT_tmpvar_11]) * _ORBIT_tmpvar_12;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	    results._buffer[_ORBIT_tmpvar_10].result =
	       *((GNOME_VFS_Result *) _ORBIT_curptr);
	    _ORBIT_curptr += 2;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    results._buffer[_ORBIT_tmpvar_10].file_info.data._length =
	       *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.data._buffer =
	       (CORBA_octet *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.data.
		      _buffer[_ORBIT_tmpvar_13]) *
	       results._buffer[_ORBIT_tmpvar_10].file_info.data._length;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_15 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.name =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.
		      name[_ORBIT_tmpvar_14]) * _ORBIT_tmpvar_15;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_17 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.symlink_name =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.
		      symlink_name[_ORBIT_tmpvar_16]) * _ORBIT_tmpvar_17;
	    _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	    _ORBIT_tmpvar_19 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	    _ORBIT_curptr += 4;
	    results._buffer[_ORBIT_tmpvar_10].file_info.mime_type =
	       (void *) _ORBIT_curptr;
	    _ORBIT_curptr +=
	       sizeof(results._buffer[_ORBIT_tmpvar_10].file_info.
		      mime_type[_ORBIT_tmpvar_18]) * _ORBIT_tmpvar_19;
	 }

      }
   }
   _impl_get_file_info(_ORBIT_servant, &(results), ev);
}

void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_start(POA_GNOME_VFS_Slave_Notify *
					      _ORBIT_servant,
					      GIOPRecvBuffer *
					      _ORBIT_recv_buffer,
					      CORBA_Environment * ev,
					      CORBA_boolean(*_impl_xfer_start)
					      (PortableServer_Servant
					       _servant,
					       const CORBA_unsigned_long
					       files_total,
					       const CORBA_unsigned_long
					       bytes_total,
					       CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_unsigned_long files_total;
   CORBA_unsigned_long bytes_total;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (files_total))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 (*((guint32 *) & (bytes_total))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 files_total = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 bytes_total = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _ORBIT_retval =
      _impl_xfer_start(_ORBIT_servant, files_total, bytes_total, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_file_start(POA_GNOME_VFS_Slave_Notify
						   * _ORBIT_servant,
						   GIOPRecvBuffer *
						   _ORBIT_recv_buffer,
						   CORBA_Environment * ev,
						   CORBA_boolean
						   (*_impl_xfer_file_start)
						   (PortableServer_Servant
						    _servant,
						    const CORBA_char *
						    source_uri,
						    const CORBA_char *
						    target_uri,
						    const CORBA_unsigned_long
						    bytes_to_copy,
						    CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_char *source_uri;
   CORBA_char *target_uri;
   CORBA_unsigned_long bytes_to_copy;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_4;
      CORBA_unsigned_long _ORBIT_tmpvar_5;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_5))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 source_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(source_uri[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 target_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(target_uri[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (bytes_to_copy))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 source_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(source_uri[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 target_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(target_uri[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 bytes_to_copy = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _ORBIT_retval =
      _impl_xfer_file_start(_ORBIT_servant, source_uri, target_uri,
			    bytes_to_copy, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_file_progress
   (POA_GNOME_VFS_Slave_Notify * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_boolean(*_impl_xfer_file_progress) (PortableServer_Servant _servant,
					      const CORBA_unsigned_long
					      bytes_copied,
					      const CORBA_unsigned_long
					      total_bytes_copied,
					      CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_unsigned_long bytes_copied;
   CORBA_unsigned_long total_bytes_copied;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (bytes_copied))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	    _ORBIT_curptr += 4;
	 (*((guint32 *) & (total_bytes_copied))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 bytes_copied = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 total_bytes_copied = *((CORBA_unsigned_long *) _ORBIT_curptr);
      }
   }
   _ORBIT_retval =
      _impl_xfer_file_progress(_ORBIT_servant, bytes_copied,
			       total_bytes_copied, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_file_done(POA_GNOME_VFS_Slave_Notify *
						  _ORBIT_servant,
						  GIOPRecvBuffer *
						  _ORBIT_recv_buffer,
						  CORBA_Environment * ev,
						  CORBA_boolean
						  (*_impl_xfer_file_done)
						  (PortableServer_Servant
						   _servant,
						   CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;

   _ORBIT_retval = _impl_xfer_file_done(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_done(POA_GNOME_VFS_Slave_Notify *
					     _ORBIT_servant,
					     GIOPRecvBuffer *
					     _ORBIT_recv_buffer,
					     CORBA_Environment * ev,
					     void (*_impl_xfer_done)
					     (PortableServer_Servant _servant,
					      CORBA_Environment * ev))
{
   _impl_xfer_done(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_error(POA_GNOME_VFS_Slave_Notify *
					      _ORBIT_servant,
					      GIOPRecvBuffer *
					      _ORBIT_recv_buffer,
					      CORBA_Environment * ev,
					      void (*_impl_xfer_error)
					      (PortableServer_Servant
					       _servant,
					       const GNOME_VFS_Result result,
					       CORBA_Environment * ev))
{
   GNOME_VFS_Result result;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
      }
   }
   _impl_xfer_error(_ORBIT_servant, result, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_query_for_error
   (POA_GNOME_VFS_Slave_Notify * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_unsigned_short(*_impl_xfer_query_for_error) (PortableServer_Servant
						       _servant,
						       const GNOME_VFS_Result
						       result,
						       const
						       GNOME_VFS_Slave_XferPhase
						       phase,
						       CORBA_Environment *
						       ev))
{
   CORBA_unsigned_short _ORBIT_retval;
   GNOME_VFS_Result result;
   GNOME_VFS_Slave_XferPhase phase;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 
	    (*((guint16 *) & (result))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));
	    _ORBIT_curptr += 2;
	 (*((guint16 *) & (phase))) =
	    GUINT16_SWAP_LE_BE(*((guint16 *) _ORBIT_curptr));} else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 2);
	 result = *((GNOME_VFS_Result *) _ORBIT_curptr);
	 _ORBIT_curptr += 2;
	 phase = *((GNOME_VFS_Slave_XferPhase *) _ORBIT_curptr);
      }
   }
   _ORBIT_retval =
      _impl_xfer_query_for_error(_ORBIT_servant, result, phase, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
					     (_ORBIT_send_buffer), 2);
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_query_for_overwrite
   (POA_GNOME_VFS_Slave_Notify * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    CORBA_unsigned_short(*_impl_xfer_query_for_overwrite)
    (PortableServer_Servant _servant, const CORBA_char * source_uri,
     const CORBA_char * target_uri, CORBA_Environment * ev))
{
   CORBA_unsigned_short _ORBIT_retval;
   CORBA_char *source_uri;
   CORBA_char *target_uri;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_4;
      CORBA_unsigned_long _ORBIT_tmpvar_5;
      register CORBA_unsigned_long _ORBIT_tmpvar_6;
      CORBA_unsigned_long _ORBIT_tmpvar_7;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_5))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 source_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(source_uri[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 
	    (*((guint32 *) & (_ORBIT_tmpvar_7))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 target_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(target_uri[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_5 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 source_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(source_uri[_ORBIT_tmpvar_4]) * _ORBIT_tmpvar_5;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_7 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 target_uri = (void *) _ORBIT_curptr;
	 _ORBIT_curptr +=
	    sizeof(target_uri[_ORBIT_tmpvar_6]) * _ORBIT_tmpvar_7;
      }
   }
   _ORBIT_retval =
      _impl_xfer_query_for_overwrite(_ORBIT_servant, source_uri, target_uri,
				     ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
					     (_ORBIT_send_buffer), 2);
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_stop(POA_GNOME_VFS_Slave_Notify *
					_ORBIT_servant,
					GIOPRecvBuffer * _ORBIT_recv_buffer,
					CORBA_Environment * ev,
					void (*_impl_stop)
					(PortableServer_Servant _servant,
					 CORBA_Environment * ev))
{
   _impl_stop(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_reset(POA_GNOME_VFS_Slave_Notify *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_reset)
					 (PortableServer_Servant _servant,
					  CORBA_Environment * ev))
{
   _impl_reset(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_VFS_Slave_Notify_dying(POA_GNOME_VFS_Slave_Notify *
					 _ORBIT_servant,
					 GIOPRecvBuffer * _ORBIT_recv_buffer,
					 CORBA_Environment * ev,
					 void (*_impl_dying)
					 (PortableServer_Servant _servant,
					  CORBA_Environment * ev))
{
   _impl_dying(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
static ORBitSkeleton
get_skel_GNOME_VFS_Slave_Request(POA_GNOME_VFS_Slave_Request * servant,
				 GIOPRecvBuffer * _ORBIT_recv_buffer,
				 gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'c':
	switch (opname[1]) {
	  case 'r':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'a':
		       switch (opname[4]) {
			 case 't':
			    switch (opname[5]) {
			      case 'e':
				 switch (opname[6]) {
				   case '\0':
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_Slave_Request_epv->create;
				      return (ORBitSkeleton)
					 _ORBIT_skel_GNOME_VFS_Slave_Request_create;
				      break;
				   case '_':
				      if (strcmp((opname + 7), "as_channel"))
					 break;
				      *impl =
					 (gpointer) servant->vepv->
					 GNOME_VFS_Slave_Request_epv->
					 create_as_channel;
				      return (ORBitSkeleton)
					 _ORBIT_skel_GNOME_VFS_Slave_Request_create_as_channel;
				      break;
				   default:
				      break;
				 }
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'd':
	if (strcmp((opname + 1), "ie"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Request_epv->die;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Request_die;
	break;
     case 'g':
	if (strcmp((opname + 1), "et_file_info"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_Request_epv->
	   get_file_info;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_VFS_Slave_Request_get_file_info;
	break;
     case 'l':
	if (strcmp((opname + 1), "oad_directory"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_Request_epv->
	   load_directory;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_VFS_Slave_Request_load_directory;
	break;
     case 'o':
	switch (opname[1]) {
	  case 'p':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'n':
		       switch (opname[4]) {
			 case '\0':
			    *impl =
			       (gpointer) servant->vepv->
			       GNOME_VFS_Slave_Request_epv->open;
			    return (ORBitSkeleton)
			       _ORBIT_skel_GNOME_VFS_Slave_Request_open;
			    break;
			 case '_':
			    if (strcmp((opname + 5), "as_channel"))
			       break;
			    *impl =
			       (gpointer) servant->vepv->
			       GNOME_VFS_Slave_Request_epv->open_as_channel;
			    return (ORBitSkeleton)
			       _ORBIT_skel_GNOME_VFS_Slave_Request_open_as_channel;
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'r':
	if (strcmp((opname + 1), "eset"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Request_epv->reset;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Request_reset;
	break;
     case 's':
	if (strcmp((opname + 1), "top"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Request_epv->stop;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Request_stop;
	break;
     case 'x':
	if (strcmp((opname + 1), "fer"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Request_epv->xfer;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Request_xfer;
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_VFS_Slave_Request(CORBA_Object obj,
					  POA_GNOME_VFS_Slave_Request *
					  servant)
{
   obj->vepv[GNOME_VFS_Slave_Request__classid] =
      servant->vepv->GNOME_VFS_Slave_Request_epv;
}

void
POA_GNOME_VFS_Slave_Request__init(PortableServer_Servant servant,
				  CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_VFS_Slave_Request,
	 "IDL:GNOME/VFS/Slave/Request:1.0",
	 (ORBit_local_objref_init) & init_local_objref_GNOME_VFS_Slave_Request

      };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_VFS_Slave_Request__classid)
      GNOME_VFS_Slave_Request__classid = ORBit_register_class(&class_info);
}

void
POA_GNOME_VFS_Slave_Request__fini(PortableServer_Servant servant,
				  CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSkeleton
get_skel_GNOME_VFS_Slave_FileHandle(POA_GNOME_VFS_Slave_FileHandle * servant,
				    GIOPRecvBuffer * _ORBIT_recv_buffer,
				    gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'c':
	if (strcmp((opname + 1), "lose"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_FileHandle_epv->close;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_FileHandle_close;
	break;
     case 'r':
	if (strcmp((opname + 1), "ead"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_FileHandle_epv->read;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_FileHandle_read;
	break;
     case 'w':
	if (strcmp((opname + 1), "rite"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_FileHandle_epv->write;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_FileHandle_write;
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_VFS_Slave_FileHandle(CORBA_Object obj,
					     POA_GNOME_VFS_Slave_FileHandle *
					     servant)
{
   obj->vepv[GNOME_VFS_Slave_FileHandle__classid] =
      servant->vepv->GNOME_VFS_Slave_FileHandle_epv;
}

void
POA_GNOME_VFS_Slave_FileHandle__init(PortableServer_Servant servant,
				     CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_VFS_Slave_FileHandle,
	 "IDL:GNOME/VFS/Slave/FileHandle:1.0",
	 (ORBit_local_objref_init) &

	 init_local_objref_GNOME_VFS_Slave_FileHandle };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_VFS_Slave_FileHandle__classid)
      GNOME_VFS_Slave_FileHandle__classid = ORBit_register_class(&class_info);
}

void
POA_GNOME_VFS_Slave_FileHandle__fini(PortableServer_Servant servant,
				     CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSkeleton
get_skel_GNOME_VFS_Slave_Notify(POA_GNOME_VFS_Slave_Notify * servant,
				GIOPRecvBuffer * _ORBIT_recv_buffer,
				gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'c':
	if (strcmp((opname + 1), "lose"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->close;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Notify_close;
	break;
     case 'd':
	if (strcmp((opname + 1), "ying"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->dying;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Notify_dying;
	break;
     case 'g':
	if (strcmp((opname + 1), "et_file_info"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->
	   get_file_info;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_VFS_Slave_Notify_get_file_info;
	break;
     case 'l':
	if (strcmp((opname + 1), "oad_directory"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->
	   load_directory;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_VFS_Slave_Notify_load_directory;
	break;
     case 'o':
	switch (opname[1]) {
	  case 'p':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'n':
		       switch (opname[4]) {
			 case '\0':
			    *impl =
			       (gpointer) servant->vepv->
			       GNOME_VFS_Slave_Notify_epv->open;
			    return (ORBitSkeleton)
			       _ORBIT_skel_GNOME_VFS_Slave_Notify_open;
			    break;
			 case '_':
			    if (strcmp((opname + 5), "as_channel"))
			       break;
			    *impl =
			       (gpointer) servant->vepv->
			       GNOME_VFS_Slave_Notify_epv->open_as_channel;
			    return (ORBitSkeleton)
			       _ORBIT_skel_GNOME_VFS_Slave_Notify_open_as_channel;
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'r':
	switch (opname[1]) {
	  case 'e':
	     switch (opname[2]) {
	       case 'a':
		  if (strcmp((opname + 3), "d"))
		     break;
		  *impl =
		     (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->
		     read;
		  return (ORBitSkeleton)
		     _ORBIT_skel_GNOME_VFS_Slave_Notify_read;
		  break;
	       case 's':
		  if (strcmp((opname + 3), "et"))
		     break;
		  *impl =
		     (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->
		     reset;
		  return (ORBitSkeleton)
		     _ORBIT_skel_GNOME_VFS_Slave_Notify_reset;
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 's':
	if (strcmp((opname + 1), "top"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->stop;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Notify_stop;
	break;
     case 'w':
	if (strcmp((opname + 1), "rite"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_VFS_Slave_Notify_epv->write;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_VFS_Slave_Notify_write;
	break;
     case 'x':
	switch (opname[1]) {
	  case 'f':
	     switch (opname[2]) {
	       case 'e':
		  switch (opname[3]) {
		    case 'r':
		       switch (opname[4]) {
			 case '_':
			    switch (opname[5]) {
			      case 'd':
				 if (strcmp((opname + 6), "one"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_VFS_Slave_Notify_epv->xfer_done;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_done;
				 break;
			      case 'e':
				 if (strcmp((opname + 6), "rror"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_VFS_Slave_Notify_epv->xfer_error;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_error;
				 break;
			      case 'f':
				 switch (opname[6]) {
				   case 'i':
				      switch (opname[7]) {
					case 'l':
					   switch (opname[8]) {
					     case 'e':
						switch (opname[9]) {
						  case '_':
						     switch (opname[10]) {
						       case 'd':
							  if (strcmp
							      ((opname + 11),
							       "one"))
							     break;
							  *impl =
							     (gpointer)
							     servant->vepv->
							     GNOME_VFS_Slave_Notify_epv->
							     xfer_file_done;
							  return
							     (ORBitSkeleton)
							     _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_file_done;
							  break;
						       case 'p':
							  if (strcmp
							      ((opname + 11),
							       "rogress"))
							     break;
							  *impl =
							     (gpointer)
							     servant->vepv->
							     GNOME_VFS_Slave_Notify_epv->
							     xfer_file_progress;
							  return
							     (ORBitSkeleton)
							     _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_file_progress;
							  break;
						       case 's':
							  if (strcmp
							      ((opname + 11),
							       "tart"))
							     break;
							  *impl =
							     (gpointer)
							     servant->vepv->
							     GNOME_VFS_Slave_Notify_epv->
							     xfer_file_start;
							  return
							     (ORBitSkeleton)
							     _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_file_start;
							  break;
						       default:
							  break;
						     }
						     break;
						  default:
						     break;
						}
						break;
					     default:
						break;
					   }
					   break;
					default:
					   break;
				      }
				      break;
				   default:
				      break;
				 }
				 break;
			      case 'q':
				 switch (opname[6]) {
				   case 'u':
				      switch (opname[7]) {
					case 'e':
					   switch (opname[8]) {
					     case 'r':
						switch (opname[9]) {
						  case 'y':
						     switch (opname[10]) {
						       case '_':
							  switch (opname[11]) {
							    case 'f':
							       switch (opname
								       [12]) {
								 case 'o':
								    switch
								       (opname
									[13])
								      {
									 case
								      'r':
									 switch
									    (opname
									     [14])
									   {
									      case
									   '_':
									      switch
										 (opname
										  [15])
										{
										   case
										'e':
										   if
										      (strcmp
										       (
											(opname
											 +
											 16),
											"rror"))
											 break;
										   *impl
										      =
										      (gpointer)
										      servant->
										      vepv->
										      GNOME_VFS_Slave_Notify_epv->
										      xfer_query_for_error;
										   return
										      (ORBitSkeleton)
										      _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_query_for_error;
										   break;
										   case
										'o':
										   if
										      (strcmp
										       (
											(opname
											 +
											 16),
											"verwrite"))
											 break;
										   *impl
										      =
										      (gpointer)
										      servant->
										      vepv->
										      GNOME_VFS_Slave_Notify_epv->
										      xfer_query_for_overwrite;
										   return
										      (ORBitSkeleton)
										      _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_query_for_overwrite;
										   break;
										default:
										   break;
									      }
									      break;
									   default:
									      break;
									 }
									 break;
								      default:
									 break;
								    }
								    break;
								 default:
								    break;
							       }
							       break;
							    default:
							       break;
							  }
							  break;
						       default:
							  break;
						     }
						     break;
						  default:
						     break;
						}
						break;
					     default:
						break;
					   }
					   break;
					default:
					   break;
				      }
				      break;
				   default:
				      break;
				 }
				 break;
			      case 's':
				 if (strcmp((opname + 6), "tart"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_VFS_Slave_Notify_epv->xfer_start;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_VFS_Slave_Notify_xfer_start;
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_VFS_Slave_Notify(CORBA_Object obj,
					 POA_GNOME_VFS_Slave_Notify * servant)
{
   obj->vepv[GNOME_VFS_Slave_Notify__classid] =
      servant->vepv->GNOME_VFS_Slave_Notify_epv;
}

void
POA_GNOME_VFS_Slave_Notify__init(PortableServer_Servant servant,
				 CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_VFS_Slave_Notify,
	 "IDL:GNOME/VFS/Slave/Notify:1.0",
	 (ORBit_local_objref_init) & init_local_objref_GNOME_VFS_Slave_Notify

      };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_VFS_Slave_Notify__classid)
      GNOME_VFS_Slave_Notify__classid = ORBit_register_class(&class_info);
}

void
POA_GNOME_VFS_Slave_Notify__fini(PortableServer_Servant servant,
				 CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}
