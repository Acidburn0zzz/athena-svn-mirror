/*
 * This file was generated by orbit-idl-2 - DO NOT EDIT!
 */

#include <string.h>
#define ORBIT2_STUBS_API
#include "GNOME_Media_CDDBSlave2.h"

void
GNOME_Media_CDDBTrackEditor_setDiscID(GNOME_Media_CDDBTrackEditor _obj,
				      const CORBA_char * discid,
				      CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBTrackEditor__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBTrackEditor__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBTrackEditor__classid))->setDiscID) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setDiscID(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBTrackEditor__iinterface.
				methods, 0, NULL, _args, NULL, ev);

   }
}
void
GNOME_Media_CDDBTrackEditor_showWindow(GNOME_Media_CDDBTrackEditor _obj,
				       CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBTrackEditor__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBTrackEditor__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBTrackEditor__classid))->
       showWindow) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->showWindow(ORBIT_STUB_GetServant(_obj), ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBTrackEditor__iinterface.
				methods, 1, NULL, NULL, NULL, ev);

   }
}
void
GNOME_Media_CDDBSlave2_query(GNOME_Media_CDDBSlave2 _obj,
			     const CORBA_char * discid,
			     const CORBA_short ntrks,
			     const CORBA_char * offsets,
			     const CORBA_long nsecs, const CORBA_char * name,
			     const CORBA_char * version,
			     CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->query) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->query(ORBIT_STUB_GetServant(_obj), discid, ntrks, offsets,
			nsecs, name, version, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) & ntrks, (gpointer) & offsets,
	    (gpointer) & nsecs, (gpointer) & name, (gpointer) & version
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				0, NULL, _args, NULL, ev);

   }
}
void
GNOME_Media_CDDBSlave2_save(GNOME_Media_CDDBSlave2 _obj,
			    const CORBA_char * discid, CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->save) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->save(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				1, NULL, _args, NULL, ev);

   }
}
CORBA_string
GNOME_Media_CDDBSlave2_getArtist(GNOME_Media_CDDBSlave2 _obj,
				 const CORBA_char * discid,
				 CORBA_Environment * ev)
{
   CORBA_string _ORBIT_retval;
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->getArtist) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_retval =
	 _ORBIT_epv->getArtist(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				2, &_ORBIT_retval, _args, NULL, ev);

   }
   return _ORBIT_retval;
}

void
GNOME_Media_CDDBSlave2_setArtist(GNOME_Media_CDDBSlave2 _obj,
				 const CORBA_char * discid,
				 const CORBA_char * artist,
				 CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->setArtist) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setArtist(ORBIT_STUB_GetServant(_obj), discid, artist, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) & artist
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				3, NULL, _args, NULL, ev);

   }
}
CORBA_string
GNOME_Media_CDDBSlave2_getDiscTitle(GNOME_Media_CDDBSlave2 _obj,
				    const CORBA_char * discid,
				    CORBA_Environment * ev)
{
   CORBA_string _ORBIT_retval;
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->getDiscTitle) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_retval =
	 _ORBIT_epv->getDiscTitle(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				4, &_ORBIT_retval, _args, NULL, ev);

   }
   return _ORBIT_retval;
}

void
GNOME_Media_CDDBSlave2_setDiscTitle(GNOME_Media_CDDBSlave2 _obj,
				    const CORBA_char * discid,
				    const CORBA_char * disctitle,
				    CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->setDiscTitle) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setDiscTitle(ORBIT_STUB_GetServant(_obj), discid, disctitle,
			       ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) & disctitle
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				5, NULL, _args, NULL, ev);

   }
}
CORBA_short
GNOME_Media_CDDBSlave2_getNTrks(GNOME_Media_CDDBSlave2 _obj,
				const CORBA_char * discid,
				CORBA_Environment * ev)
{
   CORBA_short _ORBIT_retval;
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->getNTrks) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_retval =
	 _ORBIT_epv->getNTrks(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				6, &_ORBIT_retval, _args, NULL, ev);

   }
   return _ORBIT_retval;
}

void
GNOME_Media_CDDBSlave2_getAllTracks(GNOME_Media_CDDBSlave2 _obj,
				    const CORBA_char * discid,
				    GNOME_Media_CDDBSlave2_TrackList ** names,
				    CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->getAllTracks) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->getAllTracks(ORBIT_STUB_GetServant(_obj), discid, names,
			       ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, names
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				7, NULL, _args, NULL, ev);

   }
}
void
GNOME_Media_CDDBSlave2_setAllTracks(GNOME_Media_CDDBSlave2 _obj,
				    const CORBA_char * discid,
				    const GNOME_Media_CDDBSlave2_TrackList *
				    names, CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->setAllTracks) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setAllTracks(ORBIT_STUB_GetServant(_obj), discid, names,
			       ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) names
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				8, NULL, _args, NULL, ev);

   }
}
CORBA_string
GNOME_Media_CDDBSlave2_getComment(GNOME_Media_CDDBSlave2 _obj,
				  const CORBA_char * discid,
				  CORBA_Environment * ev)
{
   CORBA_string _ORBIT_retval;
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->getComment) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_retval =
	 _ORBIT_epv->getComment(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				9, &_ORBIT_retval, _args, NULL, ev);

   }
   return _ORBIT_retval;
}

void
GNOME_Media_CDDBSlave2_setComment(GNOME_Media_CDDBSlave2 _obj,
				  const CORBA_char * discid,
				  const CORBA_char * comment,
				  CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj,
			  GNOME_Media_CDDBSlave2__classid))->setComment) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setComment(ORBIT_STUB_GetServant(_obj), discid, comment,
			     ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) & comment
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				10, NULL, _args, NULL, ev);

   }
}
CORBA_short
GNOME_Media_CDDBSlave2_getYear(GNOME_Media_CDDBSlave2 _obj,
			       const CORBA_char * discid,
			       CORBA_Environment * ev)
{
   CORBA_short _ORBIT_retval;
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->getYear) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_retval =
	 _ORBIT_epv->getYear(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				11, &_ORBIT_retval, _args, NULL, ev);

   }
   return _ORBIT_retval;
}

void
GNOME_Media_CDDBSlave2_setYear(GNOME_Media_CDDBSlave2 _obj,
			       const CORBA_char * discid,
			       const CORBA_short year, CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->setYear) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setYear(ORBIT_STUB_GetServant(_obj), discid, year, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) & year
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				12, NULL, _args, NULL, ev);

   }
}
CORBA_string
GNOME_Media_CDDBSlave2_getGenre(GNOME_Media_CDDBSlave2 _obj,
				const CORBA_char * discid,
				CORBA_Environment * ev)
{
   CORBA_string _ORBIT_retval;
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->getGenre) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_retval =
	 _ORBIT_epv->getGenre(ORBIT_STUB_GetServant(_obj), discid, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				13, &_ORBIT_retval, _args, NULL, ev);

   }
   return _ORBIT_retval;
}

void
GNOME_Media_CDDBSlave2_setGenre(GNOME_Media_CDDBSlave2 _obj,
				const CORBA_char * discid,
				const CORBA_char * genre,
				CORBA_Environment * ev)
{
   POA_GNOME_Media_CDDBSlave2__epv *_ORBIT_epv;

   if (ORBit_small_flags & ORBIT_SMALL_FAST_LOCALS &&
       ORBIT_STUB_IsBypass(_obj, GNOME_Media_CDDBSlave2__classid) &&
       (_ORBIT_epv =
	ORBIT_STUB_GetEpv(_obj, GNOME_Media_CDDBSlave2__classid))->setGenre) {
      ORBIT_STUB_PreCall(_obj);
      _ORBIT_epv->setGenre(ORBIT_STUB_GetServant(_obj), discid, genre, ev);
      ORBIT_STUB_PostCall(_obj);
   } else {			/* remote marshal */
      gpointer _args[] = {
	 (gpointer) & discid, (gpointer) & genre
      };

      ORBit_small_invoke_stub_n(_obj,
				&GNOME_Media_CDDBSlave2__iinterface.methods,
				14, NULL, _args, NULL, ev);

   }
}
