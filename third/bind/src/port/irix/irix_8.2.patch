diff -rc include/arpa/inet.h.orig include/arpa/inet.h
*** include/arpa/inet.h.orig	Mon Oct 26 15:45:41 1998
--- include/arpa/inet.h	Mon Mar  8 12:50:44 1999
***************
*** 100,106 ****
  int		 inet_net_pton __P((int, const char *, void *, size_t));
  char		*inet_cidr_ntop __P((int, const void *, int, char *, size_t));
  int		 inet_cidr_pton __P((int, const char *, void *, int *));
! const char	*inet_ntoa __P((struct in_addr));
  int		 inet_pton __P((int, const char *, void *));
  const char	*inet_ntop __P((int, const void *, char *, size_t));
  u_int		 inet_nsap_addr __P((const char *, u_char *, int));
--- 100,106 ----
  int		 inet_net_pton __P((int, const char *, void *, size_t));
  char		*inet_cidr_ntop __P((int, const void *, int, char *, size_t));
  int		 inet_cidr_pton __P((int, const char *, void *, int *));
! char		*inet_ntoa __P((struct in_addr));
  int		 inet_pton __P((int, const char *, void *));
  const char	*inet_ntop __P((int, const void *, char *, size_t));
  u_int		 inet_nsap_addr __P((const char *, u_char *, int));
diff -rc lib/inet/inet_ntoa.c.orig lib/inet/inet_ntoa.c
*** lib/inet/inet_ntoa.c.orig	Wed Sep 16 10:07:12 1998
--- lib/inet/inet_ntoa.c	Mon Mar  8 12:51:58 1999
***************
*** 52,58 ****
   * Convert network-format internet address
   * to base 256 d.d.d.d representation.
   */
! const char *
  inet_ntoa(struct in_addr in) {
  	static char ret[18];
  
--- 52,58 ----
   * Convert network-format internet address
   * to base 256 d.d.d.d representation.
   */
! char *
  inet_ntoa(struct in_addr in) {
  	static char ret[18];
  
diff -cr bin/named/ns_main.c.orig bin/named/ns_main.c
*** bin/named/ns_main.c.orig	Mon Jan 18 14:21:44 1999
--- bin/named/ns_main.c	Tue Feb 16 16:18:46 1999
***************
*** 1076,1082 ****
--- 1076,1090 ----
  				"memget(interface)", NULL);
  		ifc.ifc_len = bufsiz;
  		ifc.ifc_buf = buf;
+ #ifdef IRIX_EMUL_IOCTL_SIOCGIFCONF
+ 		/* This is a fix for IRIX OS in which the call to ioctl with
+ 		 * the flag SIOCGIFCONF may not return an entry for all the
+ 		 * interfaces like most falvors of Unix.
+ 		 */
+ 		if (emul_ioctl(&ifc) >= 0)
+ #else
  		if (ioctl(s, SIOCGIFCONF, (char *)&ifc) >= 0)
+ #endif
  			break;
  		if (errno != EINVAL)
  			ns_panic(ns_log_default, 1,
diff -cr port/irix/include/port_before.h.orig port/irix/include/port_before.h
*** port/irix/include/port_before.h.orig	Mon Nov  9 20:24:57 1998
--- port/irix/include/port_before.h	Tue Feb 16 14:33:11 1999
***************
*** 9,11 ****
--- 9,24 ----
  #endif
  
  #include <limits.h>	/* _POSIX_PATH_MAX */
+ 
+ #define IRIX_EMUL_IOCTL_SIOCGIFCONF
+ 
+ #ifdef IRIX_EMUL_IOCTL_SIOCGIFCONF
+ #include <sys/types.h>
+ #include <net/if.h>	
+ 		/* struct ifconf, struct if_msghdr, struct ifa_msghdr,
+ 		 * struct ifreq
+ 		 */
+ 
+ int emul_ioctl(	struct ifconf * ifc );
+ 
+ #endif	/* #ifdef IRIX_EMUL_IOCTL_SIOCGIFCONF */
diff -cr port/irix/noop.c.orig port/irix/noop.c
*** port/irix/noop.c.orig	Thu Apr 24 14:48:06 1997
--- port/irix/noop.c	Tue Feb 16 17:04:46 1999
***************
*** 1,4 ****
--- 1,203 ----
+ #include <port_before.h>
+ #include <port_after.h>
+ 
  void
  __bind_noop() {
  	/* NOOP */
  }
+ 
+ #ifdef IRIX_EMUL_IOCTL_SIOCGIFCONF
+ 
+ #include <stdio.h>		/* NULL */
+ #include <sys/types.h>
+ #include <sys/sysctl.h>		/* sysctl() */
+ #include <sys/socket.h>		/* sysctl(), struct sockaddr */
+ #include <stdlib.h>		/* malloc() */
+ #include <net/route.h>		/* RTM_* */
+ #include <net/if_dl.h>		/* struct sockaddr_dl */
+ #include <string.h>		/* memcpy(), memset() */
+ #include <errno.h>		/* setoserror() */
+ 
+ #define ROUNDUP( sz ) (( (sz) > 0 ) ?\
+ 			( 1 + (((sz) - 1) | (sizeof(__uint64_t) - 1))) :\
+ 			0)
+ 
+ #ifdef _HAVE_SA_LEN
+ #define ADVANCE( ptr, sa ) ptr += ROUNDUP( (sa)->sa_len ) 
+ #else
+ #define ADVANCE( ptr, sa ) ptr += ROUNDUP( _FAKE_SA_LEN_DST(sa) ) 
+ #endif
+ 
+ int
+ emul_ioctl( struct ifconf * ifc )
+ {
+     size_t		bufsz, used_sz;
+     char		*buf, *ptr, *end_ptr;
+     int			mib[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
+     struct if_msghdr	*ifmsghdr;		/* Iface info */
+     struct ifa_msghdr	*ifamsghdr;		/* Iface address info */
+     char		if_name[IFNAMSIZ];	/* Interface name */
+     struct sockaddr_dl	*if_addr;		/* Interface name struct */
+     char		*addr_ptr;		/* Next address */
+     struct ifreq	*ifreq_ptr;		/* current ifreq */
+     struct sockaddr	*curr_addr;
+ 
+     /* Check parameter */
+ 
+     if ( (ifc == NULL) || (ifc->ifc_len <= 0) || (ifc->ifc_buf == NULL) )
+     {
+ 
+ 	setoserror(EINVAL);
+ 	return -1;
+ 
+     }
+ 
+     /* Get size of buffer needed */
+ 
+     if (sysctl(mib, 6, NULL, &bufsz, NULL, 0) < 0)
+     {
+ 
+ 	return -1;
+ 
+     }
+ 
+ 
+     /* Allocate memmory and retrieve info */
+ 
+     if ((buf = (char *)malloc(bufsz)) == NULL)
+     {
+ 
+ 	return -1;
+ 	
+     }
+ 	
+     if (sysctl(mib, 6, buf, &bufsz, NULL, 0) < 0)
+     {
+ 	
+ 	free(buf);
+ 	return -1;
+ 
+     }
+ 
+     /* Place info in ifconf structure */
+ 
+     for ( ptr = buf, end_ptr = buf + bufsz, if_name[0] = '\0', used_sz = 0,\
+ 	      ifreq_ptr = (struct ifreq *)(ifc->ifc_buf);\
+ 	  ptr < end_ptr;\
+ 	  ptr += ifmsghdr->ifm_msglen )
+     {
+ 	
+ 	ifmsghdr = (struct if_msghdr *)ptr;
+ 
+ 	if ( ifmsghdr->ifm_type == RTM_IFINFO )
+ 	{
+ 
+ 	    memset( if_name, 0, IFNAMSIZ );
+ 
+ 	    /* We only get interface name from this message */
+ 
+ 	    if ( ifmsghdr->ifm_addrs & RTA_IFP )
+ 	    {
+ 
+ #ifdef _IGNORE_DOWN_IFACES
+ 		if (!(IFF_UP & ifcmsghdr->ifm_flags))
+ 		{
+ 		    
+ 		    /* Skip if iface is down */
+ 		    continue;
+ 		    
+ 		}
+ #endif
+ 		
+ 		if_addr = (struct sockaddr_dl *)(ifmsghdr + 1);
+ 		memcpy( if_name, if_addr->sdl_data,\
+ 			MIN( (size_t)(if_addr->sdl_nlen), IFNAMSIZ ) );
+ 
+ 	    }/* if ( ifmsghdr->ifm_addrs & RTA_IFP ) */
+ 
+ 	}
+ 	else if ( ifmsghdr->ifm_type == RTM_NEWADDR )
+ 	{
+ 
+ 	    if ( if_name[0] == '\0' )
+ 	    {
+ 
+ 		/* No iface name for this address ignore */
+ 		continue;
+ 
+ 	    }
+ 
+ 	    /* Here we get the address info and create an entry in ifc */
+ 
+ 	    ifamsghdr = (struct ifa_msghdr *)ptr;	/* Correct format */
+ 	    addr_ptr = (char *)(ifamsghdr + 1);
+ 	    curr_addr= (struct sockaddr *)addr_ptr;
+ 
+ 	    if ( ifamsghdr->ifam_addrs & RTA_NETMASK )
+ 	    {
+ 
+ 		/* Mask address present, skip it */
+ 
+ 		ADVANCE( addr_ptr, curr_addr );
+ 		curr_addr = (struct sockaddr *)addr_ptr;
+ 
+ 	    }/* if ( ifamsghdr->ifam_addrs & RTA_NETMASK ) */
+ 
+ 
+ 	    if ( ifamsghdr->ifam_addrs & RTA_IFA )
+ 	    {
+ 
+ 		/* Get interface address and create ifc entry */
+ 
+ 		used_sz += sizeof(struct ifreq);
+ 
+ 		if ( used_sz > ifc->ifc_len )
+ 		{
+ 
+ 		    /* Return whatever we were able to retrieve with given
+ 		     * buffer.
+ 		     */
+ 
+ 		    free(buf);
+ 		    ifc->ifc_len = used_sz - sizeof(struct ifreq);
+ 		    setoserror( EINVAL );
+ 		    return -1;
+ 
+ 		}
+ 		
+ 		memcpy( ifreq_ptr->ifr_name, if_name, IFNAMSIZ );
+ 
+ #ifdef _HAVE_SA_LEN
+ 		memcpy( &(ifreq_ptr->ifr_addr), curr_addr, curr_addr->sa_len );
+ #else
+ 		memcpy( &(ifreq_ptr->ifr_addr), curr_addr,\
+ 			_FAKE_SA_LEN_DST(curr_addr));
+ #endif
+ 		ifreq_ptr++;
+ 		
+ 	    }
+ 	 	    
+ 	}
+ 	
+ 	/* The RTM_DELADDR message is ignored */
+ 	
+     }/* for ( ptr = buf, end_ptr = buf + bufsz, if_name[0] = '\0',...) */
+ 
+     if ( ptr < end_ptr ) 
+     {
+ 	
+ 	/* Not enough memory to place all interfaces */
+ 	free(buf);
+ 	setoserror(EINVAL);
+ 	return -1;
+ 
+     }
+ 
+     ifc->ifc_len = used_sz;
+     
+     free(buf);
+     return 0;
+ 
+ }/* int emul_ioctl() */
+ 
+ #endif	/* #ifdef IRIX_EMUL_IOCTL_SIOCGIFCONF */
