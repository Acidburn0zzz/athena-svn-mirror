@x limbo
\def\pdfTeX{pdf\TeX}
@y
\def\pdfTeX{pdf\TeX}
\def\pdfeTeX{pdf\eTeX}
@z

@x [1]
@d banner=='This is pdfTeX, Version 3.14159','-',pdftex_version_string 
{printed when \pdfTeX\ starts}
@y
@d banner=='This is pdfeTeX, Version 3.14159','-',pdftex_version_string,'-',eTeX_version_string
{printed when \pdfeTeX\ starts}
@z

@x [1]
@d eTeX_version_string=='3.14159-2.1' {current \eTeX\ version}
@y
@d eTeX_version_string=='2.1' {current \eTeX\ version}
@z

@x [17]
@d pdf_font_prefix_loc=local_base+9 {points to token list for \.{\\pdffontprefix}}
@d pdf_form_prefix_loc=local_base+10 {points to token list for \.{\\pdfformprefix}}
@d pdf_image_prefix_loc=local_base+11 {points to token list for \.{\\pdfimageprefix}}
@d pdf_page_attr_loc=local_base+12 {points to token list for \.{\\pdfpageattr}}
@d pdf_pages_attr_loc=local_base+13 {points to token list for \.{\\pdfpagesattr}}
@d pdf_form_attr_loc=local_base+14 {points to token list for \.{\\pdfformattr}}
@d pdf_image_attr_loc=local_base+15 {points to token list for \.{\\pdfimageattr}}
@d err_help_loc=local_base+16 {points to token list for \.{\\errhelp}}
@d toks_base=local_base+17 {table of 256 token list registers}
@y
@d pdf_font_prefix_loc=token_base+9 {points to token list for \.{\\pdffontprefix}}
@d pdf_form_prefix_loc=token_base+10 {points to token list for \.{\\pdfformprefix}}
@d pdf_image_prefix_loc=token_base+11 {points to token list for \.{\\pdfimageprefix}}
@d pdf_page_attr_loc=token_base+12 {points to token list for \.{\\pdfpageattr}}
@d pdf_pages_attr_loc=token_base+13 {points to token list for \.{\\pdfpagesattr}}
@d pdf_form_attr_loc=token_base+14 {points to token list for \.{\\pdfformattr}}
@d pdf_image_attr_loc=token_base+15 {points to token list for \.{\\pdfimageattr}}
@d err_help_loc=token_base+16 {points to token list for \.{\\errhelp}}
@d toks_base=token_base+17 {table of 256 token list registers}
@z

@x [22]
@d write_text=15 {|token_type| code for \.{\\write}}
@d pdf_font_prefix_text=16 {|token_type| code for \.{\\pdffontprefix}}
@d pdf_form_prefix_text=17 {|token_type| code for \.{\\pdfformprefix}}
@d pdf_image_prefix_text=18 {|token_type| code for \.{\\pdfimageprefix}}
@d pdf_page_attr_text=19 {|token_type| code for \.{\\pdfpageattr}}
@d pdf_pages_attr_text=20 {|token_type| code for \.{\\pdfpagesattr}}
@d pdf_form_attr_text=21 {|token_type| code for \.{\\pdfformattr}}
@d pdf_image_attr_text=22 {|token_type| code for \.{\\pdfimageattr}}
@y
@d write_text=16 {|token_type| code for \.{\\write}}
@d pdf_font_prefix_text=17 {|token_type| code for \.{\\pdffontprefix}}
@d pdf_form_prefix_text=18 {|token_type| code for \.{\\pdfformprefix}}
@d pdf_image_prefix_text=19 {|token_type| code for \.{\\pdfimageprefix}}
@d pdf_page_attr_text=20 {|token_type| code for \.{\\pdfpageattr}}
@d pdf_pages_attr_text=21 {|token_type| code for \.{\\pdfpagesattr}}
@d pdf_form_attr_text=22 {|token_type| code for \.{\\pdfformattr}}
@d pdf_image_attr_text=23 {|token_type| code for \.{\\pdfimageattr}}
@z

@x
@d pdftex_revision_code=6 {command code for \.{\\pdftexrevision}}
@d pdf_fontname_code=7 {command code for \.{\\pdffontname}}
@y
{|@d eTeX_revision_code=6| already defined by eTeX}
@d pdftex_revision_code=7 {command code for \.{\\pdftexrevision}}
@d pdf_fontname_code=8 {command code for \.{\\pdffontname}}
@z

@x [26]
|glue_val|, |input_line_no_code|, |badness_code|, or |pdftex_version_code|.

@d input_line_no_code=glue_val+1 {code for \.{\\inputlineno}}
@d badness_code=glue_val+2 {code for \.{\\badness}}
@d pdftex_version_code=glue_val+3 {code for \.{\\pdftexversion}}
@y
|glue_val|, |last_node_type_code|, |input_line_no_code|, |badness_code|,
|eTeX_version_code|, one of the other codes for \eTeX\ extensions, 
or |pdftex_version_code|.

@d last_node_type_code=glue_val+1 {code for \.{\\lastnodetype}}
@d input_line_no_code=glue_val+2 {code for \.{\\inputlineno}}
@d badness_code=glue_val+3 {code for \.{\\badness}}
@d pdftex_version_code=glue_val+4 {code for \.{\\pdftexversion}}
@d eTeX_int=glue_val+5 {first of \eTeX\ codes for integers}
@d eTeX_dim=eTeX_int+8 {first of \eTeX\ codes for dimensions}
@d eTeX_glue=eTeX_dim+9 {first of \eTeX\ codes for glue}
@d eTeX_mu=eTeX_glue+1 {first of \eTeX\ codes for muglue}
@d eTeX_expr=eTeX_mu+1 {first of \eTeX\ codes for expressions}
@z

@x [26]
if cur_chr>glue_val then
  begin case cur_chr of
  input_line_no_code: cur_val:=line;
  badness_code: cur_val:=last_badness;
  pdftex_version_code: cur_val:=pdftex_version;
  endcases;
@y
if m>last_node_type_code then
 if m>=eTeX_glue then @<Process an expression and |return|@>@;
 else if m>=eTeX_dim then
  begin case m of
  @/@<Cases for fetching a dimension value@>@/
  end; {there are no other cases}
  cur_val_level:=dimen_val;
  end
 else begin case m of
  input_line_no_code: cur_val:=line;
  badness_code: cur_val:=last_badness;
  pdftex_version_code: cur_val:=pdftex_version;
  @/@<Cases for fetching an integer value@>@/
  end; {there are no other cases}
@z

@x [32f]
@!g_order: glue_ord; {applicable order of infinity for glue}
@y
@z

@x [32f]
@!edge:scaled; {left edge of sub-box, or right edge of leader space}
@y
@!edge:scaled; {right edge of sub-box or leader space}
@!prev_p:pointer; {one step behind |p|}
@z

@x [32f]
begin this_box:=temp_ptr; g_order:=glue_order(this_box);
@y
begin this_box:=temp_ptr;
@z

@x [32f]
base_line:=cur_v; left_edge:=cur_h;
@y
base_line:=cur_v;
prev_p:=this_box+list_offset;
if eTeX_ex then
  begin @<Initialize the LR stack@>;
  if subtype(this_box)=dlist then
    if cur_dir=right_to_left then
      begin cur_dir:=left_to_right; cur_h:=cur_h-width(this_box);
      end
    else subtype(this_box):=min_quarterword;
  if (cur_dir=right_to_left)and(subtype(this_box)<>reversed) then
    @<Reverse the complete hlist and set the subtype to |reversed|@>;
  end;
left_edge:=cur_h;
@z

@x [32f]
decr(cur_s);
@y
if eTeX_ex then
  begin @<Check for LR anomalies at the end of |hlist_out|@>;
  if subtype(this_box)=dlist then cur_dir:=right_to_left;
  end;
decr(cur_s);
@z

@x [32f]
  p:=link(p);
@y
  prev_p:=link(prev_p); {N.B.: not |prev_p:=p|, |p| might be |lig_trick|}
  p:=link(p);
@z

@x [32f]
kern_node,math_node:cur_h:=cur_h+width(p);
@y
kern_node:cur_h:=cur_h+width(p);
math_node:begin if eTeX_ex then
    @<Adjust \(t)the LR stack for the |hlist_out| routine; if necessary
      reverse an hlist segment and |goto reswitch|@>;
  cur_h:=cur_h+width(p);
  end;
@z

@x [32f]
othercases do_nothing
@y
@/@<Cases of |hlist_out| that arise in mixed direction text only@>@;
othercases do_nothing
@z

@x [32f]
next_p:p:=link(p);
@y
next_p:prev_p:=p; p:=link(p);
@z

@x [32f]
  temp_ptr:=p; edge:=cur_h;
@y
  temp_ptr:=p; edge:=cur_h+width(p);
  if cur_dir=right_to_left then cur_h:=edge;
@z

@x [32f]
  cur_h:=edge+width(p); cur_v:=base_line;
@y
  cur_h:=edge; cur_v:=base_line;
@z

@x [32f]
  begin if g_sign=stretching then
    begin if stretch_order(g)=g_order then
      rule_wd:=rule_wd+round(float(glue_set(this_box))*stretch(g));
@^real multiplication@>
    end
  else  begin if shrink_order(g)=g_order then
      rule_wd:=rule_wd-round(float(glue_set(this_box))*shrink(g));
    end;
  end;
@y
  add_glue(rule_wd);
@z

@x [32f]
  edge:=cur_h+rule_wd; lx:=0;
@y
  if cur_dir=right_to_left then cur_h:=cur_h-10;
  edge:=cur_h+rule_wd; lx:=0;
@z

@x [32f]
  cur_h:=edge-10; goto next_p;
@y
  if cur_dir=right_to_left then cur_h:=edge
  else cur_h:=edge-10;
  goto next_p;
@z

@x [32f]
save_h:=cur_h; temp_ptr:=leader_box;
@y
save_h:=cur_h; temp_ptr:=leader_box;
if cur_dir=right_to_left then cur_h:=cur_h+leader_wd;
@z

@x [32f]
@!g_order: glue_ord; {applicable order of infinity for glue}
@y
@z

@x [32f]
begin this_box:=temp_ptr; g_order:=glue_order(this_box);
@y
begin this_box:=temp_ptr;
@z

@x [32f]
  cur_h:=left_edge+shift_amount(p); {shift the box right}
@y
  if cur_dir=right_to_left then cur_h:=left_edge-shift_amount(p)
  else cur_h:=left_edge+shift_amount(p); {shift the box right}
@z

@x [32f]
if (rule_ht>0)and(rule_wd>0) then {we don't output empty rules}
  pdf_set_rule(cur_h, cur_v, rule_wd, rule_ht);
@y
if (rule_ht>0)and(rule_wd>0) then {we don't output empty rules}
  begin if cur_dir=right_to_left then cur_h:=cur_h-rule_wd;
  pdf_set_rule(cur_h, cur_v, rule_wd, rule_ht);
  cur_h:=left_edge;
  end;
@z

@x [32f]
  begin if g_sign=stretching then
    begin if stretch_order(g)=g_order then
      rule_ht:=rule_ht+round(float(glue_set(this_box))*stretch(g));
@^real multiplication@>
    end
  else  begin if shrink_order(g)=g_order then
      rule_ht:=rule_ht-round(float(glue_set(this_box))*shrink(g));
    end;
  end;
@y
  add_glue(rule_ht);
@z

@x [32f]
begin cur_h:=left_edge+shift_amount(leader_box);@/
@y
begin if cur_dir=right_to_left then
  cur_h:=left_edge-shift_amount(leader_box)
  else cur_h:=left_edge+shift_amount(leader_box);
@z

@x [32f]
@<(in |pdf_ship_out|)Ship box |p| out@>;
@y
@<(in |pdf_ship_out|)Ship box |p| out@>;
if eTeX_ex then @<Check for LR anomalies at the end of |ship_out|@>;
@z

@x [33]
exit: 
if ((m = cal_expand_ratio) or (m = adjust_expand_ratio)) and (expand_ratio <> 0) then begin
    if abs(expand_ratio) > 1000 then
        if expand_ratio > 0 then
            expand_ratio := 1000
        else
            expand_ratio := -1000;
    free_node(r, box_node_size);
    r := hpack(save_p, save_w, subst_font);
end;
hpack:=r;
@y
exit: if TeXXeT_en then @<Check for LR anomalies at the end of |hpack|@>;
if ((m = cal_expand_ratio) or (m = adjust_expand_ratio)) and (expand_ratio <> 0) then begin
    if abs(expand_ratio) > 1000 then
        if expand_ratio > 0 then
            expand_ratio := 1000
        else
            expand_ratio := -1000;
    free_node(r, box_node_size);
    r := hpack(save_p, save_w, subst_font);
end;
hpack:=r;
@z
