<head>
<title>UK TeX FAQ -- question 216</title>
</head><body>
<h3>Patching existing commands</h3>
<p>In the general case (possibly sticking something in the middle of an
existing command) this is difficult.  However, the common requirement,
to add some code at the beginning or the end of an existing command,
is conceptually quite easy.  Suppose we want to define a version of a
command that does some small extension of its original definition: we
would naturally write:
<pre>
  \renewcommand{\splat}{\mumble\splat}
</pre>
However, this would not work: a call to <code>\splat</code> would execute
<code>\mumble</code>, and the call the redefined <code>\splat</code> again; this is an
infinite recursive loop, that will quickly exhaust TeX's memory.
<p>Fortunately, the TeX primitive <code>\let</code> command comes to our
rescue; it allows us to take a "snapshot" of the current state of a
command, which we can then use in the redefinition of the command.
So:
<pre>
  \let\OldSmooth\smooth
  \renewcommand{\smooth}{\mumble\OldSmooth}
</pre>
effects the required patch, safely.  Adding things at the end of a
command works similarly.  If <code>\smooth</code> takes arguments, one must
pass them on:
<pre>
  \renewcommand{\smooth}[2]{\mumble\OldSmooth{#1}{#2}}
</pre>

<p>The general case may be achieved in two ways.  First, one can use the
LaTeX command <code>\CheckCommand</code>; this compares an existing command
with the definition you give it, and issues a warning if two don't
match.  Use is therefore:<br>
<code>  \CheckCommand{\complex}{</code>&lt;<em>original definition</em>&gt;<code>}</code><br>
<code>  \renewcommand{\complex}{</code>&lt;<em>new definition</em>&gt;<code>}</code><br>
This technique is obviously somewhat laborious, but if the original
command comes from a source that's liable to change under the control
of someone else, it does at least warn you that your patch is in
danger of going wrong.
<p>Otherwise, LaTeX users may use one of the <i>patch</i> or
<i>patchcmd</i> systems.
<p><i>Patch</i> gives you an ingenious (and difficult to understand)
mechanism, and comes as an old-style LaTeX documented macro file.
Sadly the old-style <i>doc</i> macros are no longer available, but
the file (<i>patch.doc</i>) may be input directly, and the
documentation may be read (un-typeset).  Roughly speaking, one gives
the command a set of instructions analagous to <i>sed</i>
substitutions, and it regenerates the command thus amended.  The
author of this FAQ has (slightly reluctantly) given up using
<i>patch</i>...
<p>The <i>patchcmd</i> package addresses a slightly simpler task, by
restricting the set of commands that you may patch; you mayn't patch
any command that has an optional argument, though it does deal with
the case of commands defined with <code>\DeclareRobustCommand</code>.  The
package defines a <code>\patchcommand</code> command, that takes three
arguments: the command to patch, stuff to stick at the front of its
definition, and stuff to stick on the end of its definition.  So, if
<code>\b</code> contains "<code>b</code>", then
<code>\patchcommand</code><code>\b{a}{c}</code>
will produce a new version of <code>\b</code> that contains "<code>abc</code>".
<dl>
<dt><tt><i>patch.doc</i></tt><dd><a href="ftp://macros/generic/patch.doc">macros/generic/patch.doc</a>
<dt><tt><i>patchcommand.sty</i></tt><dd><a href="ftp://macros/latex/contrib/supported/patchcmd.tar.gz">macros/latex/contrib/supported/patchcmd.tar.gz</a>
</dl>
<p></body>
