%{
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <linux/fb.h>
#include <linux/pmu.h>
#include <errno.h>
#include "fb-level.h"
#include "fb-level-private.h"

#ifndef FBIOBLANK
#define FBIOBLANK      0x4611          /* 0 or vesa-level+1 */
#endif

#ifndef PMU_IOC_GRAB_BACKLIGHT
#define PMU_IOC_GRAB_BACKLIGHT  _IOR('B', 6, 0)
#endif
%}

class FB:Level from G:Object {
	/* the current backlight level */
	public int level = 0;
	argument INT level (export)
	get {
		int level;

		ioctl (self->_priv->pmu_fd,
				PMU_IOC_GET_BACKLIGHT, &level);

		ARG = level;
	}

	set {
		int level;

		level = fb_level_level_check(ARG);

		ioctl (self->_priv->pmu_fd,
				PMU_IOC_SET_BACKLIGHT, &level);
		self->level = level;
	};

	/* the current dimming status */
	public gboolean dim = FALSE;
	argument INT (type gboolean) dim (export)
	get {
		ARG = self->dim;
	}

	set {
		if (self->dim == FALSE && ARG == TRUE)
		{
			self->_priv->saved_level =
				fb_level_get_level(self);
			fb_level_set_level (self, 1);
			self->dim = TRUE;
		} else if (self->dim == TRUE && ARG == FALSE) {
			fb_level_set_level (self, self->_priv->saved_level);
			self->dim = FALSE;
		}
	};

	/**
	 * new:
	 *
	 * Creates a new #FBLevel object
	 *
	 * Returns: a new object
	 **/
	public
	FBLevel *
	new(void)
	{
		FBLevel *self;
		int fd, foo;

		if (g_file_test ("/dev/pmu", G_FILE_TEST_EXISTS) == FALSE)
			return NULL;

		if (fb_level_is_powerbook () == FALSE)
			return NULL;

		self = (FBLevel *)GET_NEW;
		/* This function switches the kernel backlight control off.
		 * This is part of the PPC kernel branch since version
		 * 2.4.18-rc2-benh. It does nothing with older kernels.
		 * For those kernels a separate kernel patch is nessecary to
		 * get backlight control in user space.
		 *
		 * Notice nicked from pbbuttons*/
		fd  = open ("/dev/pmu", O_RDWR);
		/* We can't emit the signal yet, the signal isn't connected! */
		if (fd < 0)
			return NULL;

		foo = ioctl(fd, PMU_IOC_GRAB_BACKLIGHT, 0);
		self->_priv->pmu_fd = fd;
		return self;
	}

	/* 
	 * PRIVATE functions and data
	 */

	private int pmu_fd = -1;
	private int saved_level = 0;

	/* returns a valid fb level between 0 and 15 */
	private
	int
	level_check (int level)
	{
		return CLAMP (level, 0, 15);
	};

	public
	gboolean
	is_powerbook (void)
	{
		FILE *fd;
		char str[2048];
		gboolean found = FALSE;

		fd = fopen ("/proc/cpuinfo", "r");
		while (!feof (fd) && found == FALSE)
		{
			fread (str, 1, 2048, fd);
			if (strstr (str, "PowerBook") != NULL)
				found = TRUE;
		}

		fclose (fd);

		return found;
	}
}

