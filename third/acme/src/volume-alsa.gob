%{
#include <alsa/asoundlib.h>
#include "volume-alsa.h"
#include "volume-alsa-private.h"

#ifndef DEFAULT_CARD
#define DEFAULT_CARD "default"
#endif
%}

class Volume:Alsa from G:Object {
	/* the current volume */
	public int volume = 0;
	argument INT volume (export)
	get {
		long lval, rval;
		int tmp;

		snd_mixer_selem_get_playback_volume(self->_priv->elem,
				SND_MIXER_SCHN_FRONT_LEFT,
				&lval);
		snd_mixer_selem_get_playback_volume(self->_priv->elem,
				SND_MIXER_SCHN_FRONT_RIGHT,
				&rval);

		tmp = self_vol_check (self, (int) (lval + rval) / 2);
		ARG = (tmp * 100 / self->_priv->pmax);
	}

	set {
		long val;

		val = (long) self_vol_check (self,
				ARG * self->_priv->pmax / 100);
		snd_mixer_selem_set_playback_volume(self->_priv->elem,
				SND_MIXER_SCHN_FRONT_LEFT,
				val);
		snd_mixer_selem_set_playback_volume(self->_priv->elem,
				SND_MIXER_SCHN_FRONT_RIGHT,
				val);
	};

	/* the current muting status */
	public gboolean mute = FALSE;
	argument INT (type gboolean) mute (export)
	get {
		int ival;

		snd_mixer_selem_get_playback_switch(self->_priv->elem,
				SND_MIXER_SCHN_FRONT_LEFT,
				&ival);
		ARG = ival;
	}

	set {
		snd_mixer_selem_set_playback_switch(self->_priv->elem,
				SND_MIXER_SCHN_FRONT_LEFT,
				ARG);
		if (ARG == TRUE)
		{
			self->_priv->saved_volume = self_get_volume (self);
			self_set_volume (self, 0);
		} else {
			if (self->_priv->saved_volume != -1)
				self_set_volume (self,
						self->_priv->saved_volume);
		}
	};

	/* use the PCM volume, or the Master Volume ? */
	public gboolean use_pcm = FALSE;
	argument INT (type gboolean) use_pcm (export) link;

	/**
	 * new:
	 *
	 * Creates a new #VolumeAlsa object
	 *
	 * Returns: a new object
	 **/
	public
	VolumeAlsa *
	new(void)
	{
		snd_mixer_selem_id_t *sid;
		snd_mixer_t *handle;
		snd_mixer_elem_t *elem;
		VolumeAlsa *self;

		self = (VolumeAlsa *)GET_NEW;

		/* open the mixer */
		if (snd_mixer_open (&handle, 0) < 0)
		{
			g_message ("snd_mixer_open");
			return NULL;
		}
		/* attach the handle to the default card */
		if (snd_mixer_attach(handle, DEFAULT_CARD) <0)
		{
			g_message ("snd_mixer_attach");
			goto bail;
		}
		/* ? */
		if (snd_mixer_selem_register(handle, NULL, NULL) < 0)
		{
			g_message ("snd_mixer_selem_register");
			goto bail;
		}
		if (snd_mixer_load(handle) < 0)
		{
			g_message ("snd_mixer_load");
			goto bail;
		}

		snd_mixer_selem_id_alloca(&sid);
		snd_mixer_selem_id_set_name (sid, "Master");
		elem = snd_mixer_find_selem(handle, sid);
		if (!elem)
		{
			g_message ("snd_mixer_find_selem");
			goto bail;
		}

		if (!snd_mixer_selem_has_playback_volume(elem))
		{
			g_message ("snd_mixer_selem_has_capture_volume");
			goto bail;
		}

		snd_mixer_selem_get_playback_volume_range (elem,
				&(self->_priv->pmin),
				&(self->_priv->pmax));

		self->_priv->handle = handle;
		self->_priv->elem = elem;

		return self;

		bail:
			snd_mixer_close(handle);
			return NULL;
	}

	/* 
	 * PRIVATE functions and data
	 */
	private gboolean mixerpb = FALSE;
	private gint saved_volume = -1;

	private snd_mixer_t *handle = NULL;
	private snd_mixer_elem_t *elem = NULL;
	private long pmin = 0;
	private long pmax = 0;

	signal last NONE (NONE)
	void fd_problem(self);

	/* returns a valid volume between 0 and 100 */
	private
	gint
	vol_check (Volume:Alsa *self, gint volume)
	{
		return CLAMP (volume, self->_priv->pmin, self->_priv->pmax);
	}

	/* checks if the mixer device is opened properly */
	private
	gboolean
	mixer_check (Volume:Alsa *self (check null type), gint fd)
	{
		gboolean retval;

		if (fd <0) {
			if (self->_priv->mixerpb == FALSE) {
				self->_priv->mixerpb = TRUE;
				volume_alsa_fd_problem(self);
			}
		}
		retval = (!self->_priv->mixerpb);
		return retval;
	}
}

