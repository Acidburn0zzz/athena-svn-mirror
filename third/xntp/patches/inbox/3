Replied: Fri, 18 Jul 1997 22:53:36 -0400
Replied: "Craig Leres <leres@ee.lbl.gov> "
Replied: Fri, 18 Jul 1997 22:51:51 -0400
Replied: "Craig Leres <leres@ee.lbl.gov> "
Replied: Fri, 18 Jul 1997 22:49:00 -0400
Replied: "Craig Leres <leres@ee.lbl.gov> "
Replied: Fri, 18 Jul 1997 22:45:54 -0400
Replied: "Craig Leres <leres@ee.lbl.gov> Dave Mills <mills@udel.edu>"
Replied: Fri, 18 Jul 1997 22:41:16 -0400
Replied: "Craig Leres <leres@ee.lbl.gov> Dave Mills <mills@udel.edu>"
Received: from copland.udel.edu by huey.udel.edu id aa27695; 17 Jul 97 22:43 EDT
Received: from hot.ee.lbl.gov (hot.ee.lbl.gov [131.243.1.42]) by copland.udel.edu (8.8.5/8.7.3) with ESMTP id WAA10046 for <mills@udel.edu>; Thu, 17 Jul 1997 22:43:00 -0400 (EDT)
Received: by hot.ee.lbl.gov (8.8.6/1.43r)
	id TAA17316; Thu, 17 Jul 1997 19:43:00 -0700 (PDT)
Message-Id: <199707180243.TAA17316@hot.ee.lbl.gov>
To: Dave Mills <mills@udel.edu>
Subject: Christmas in July
Date: Thu, 17 Jul 1997 19:42:59 PDT
From: Craig Leres <leres@ee.lbl.gov>

We got a Rockwell Jupiter 12 channel gps board and I have it up and
running on a FreeBSD systems (meg.ee.lbl.gov). This GPS board is
available in single units for $173. It needs 5 VDC, an antenna and a
rs232 transceiver chip before it can be interfaced to a computer. But
it should be possible to build a working system for < $300 and one with
a top of the line antenna and power supply for < $500. Also, the
Delmore Tripmate uses the same chip, is available for $150 and might be
adapted to time keeping.

Feel free to poke at meg.ee.lbl.gov remotely, I'd be curious to hear if
you think it looks healthy.

There are a few problems I've run into. The first is that under
FreeBSD, I seem to get one extra SIGIO for each DCD cycle. This results
in:

    Jul 17 06:00:02 meg xntpd[1661]: input_handler: select() returned 0
    Jul 17 06:00:33 meg last message repeated 31 times
    Jul 17 06:02:34 meg last message repeated 121 times
    Jul 17 06:12:35 meg last message repeated 601 times
    Jul 17 06:22:36 meg last message repeated 601 times
    Jul 17 06:32:37 meg last message repeated 601 times
    Jul 17 06:42:38 meg last message repeated 601 times
    Jul 17 06:52:39 meg last message repeated 601 times
    Jul 17 07:02:40 meg last message repeated 601 times
    Jul 17 07:12:40 meg last message repeated 600 times

And causes a lot of extra reads to occur. I put a short patch into the
2.2.2-RELEASE kernel but I'm not sure if the FreeBSD folks will class
it a hack or a fix.

I also have submitted a change to FreeBSD that adds PPSCLOCK support to
the kernel. This version includes a way to change the timestamp from
leading edge (the default) to trailing edge triggering.

Another problem is that there doesn't seem to be a way to tell the
receiver that it is stationary. I'm going to call a Rockwell technical
contact to discuss this and other mysterious behaviours.

I've appended context diffs that adds a define for REFCLK_GPS_JUPITER.
It would be nice to get the number nailed down so I don't have to
recompile too many binaries when the next release of ntp comes out.

I've also appended context diffs for the "new" mx4200 clock module.
There are a bunch of format mismatches. Also, FreeBSD doesn't like the
declaration of sys_errlist. I think the best solution is to use
strerror() and use autoconf to AC_REPLACE_FUNCS(strerror) (e.g. provide
a local copy of strerror.c that gets compiled if the local system is
missing it).

		Craig
------
RCS file: RCS/ntp.h,v
retrieving revision 1.1
diff -c -r1.1 ntp.h
*** /tmp/,RCSt1a26782	Thu Jul 17 19:31:28 1997
--- ntp.h	Wed Jul  9 02:00:36 1997
***************
*** 427,432 ****
--- 427,433 ----
  #define REFCLK_PTB_ACTS		23	/* PTB Auto Computer Time Service */
  #define REFCLK_USNO		24	/* Naval Observatory dialup */
  #define REFCLK_GPS_HP		26	/* HP 58503A Time & Frequency Receiver */
+ #define	REFCLK_GPS_JUPITER	27	/* Rockwell Jupiter GPS */
  #define REFCLK_MAX		30	/* maximum index (room to expand) */
  
  /*

RCS file: RCS/clocktypes.c,v
retrieving revision 1.1
diff -c -r1.1 clocktypes.c
*** /tmp/,RCSt1a26813	Thu Jul 17 19:36:00 1997
--- clocktypes.c	Wed Jul  9 03:48:45 1997
***************
*** 64,69 ****
--- 64,71 ----
  	    "TRUETIME" },
  	{ REFCLK_GPS_HP,	"HP 58503A GPS Time & Frequency Receiver (26)",
  	    "GPS_HP" },
+ 	{ REFCLK_GPS_JUPITER,	"Rockwell Jupiter GPS Receiver (27)",
+ 	    "GPS_JUPITER" },
  	{ -1,			"", "" }
  };
  


RCS file: RCS/refclock_mx4200.c,v
retrieving revision 1.1
diff -c -r1.1 refclock_mx4200.c
*** /tmp/,RCSt1a26872	Thu Jul 17 19:40:44 1997
--- refclock_mx4200.c	Sun Jul 13 23:09:58 1997
***************
*** 129,141 ****
  #endif /* PPS */
  
  /*
-  * Imported from perror(3)
-  */
- extern int  sys_nerr;
- extern char *sys_errlist[];
- extern int  errno;
- 
- /*
   * MX4200 unit control structure.
   */
  struct mx4200unit {
--- 129,134 ----
***************
*** 190,199 ****
  #endif /* not QSORT_USES_VOID_P */
  static	void	mx4200_config	P((struct peer *));
  static	void	mx4200_ref	P((struct peer *));
! static	void	mx4200_send	P((struct peer *, char *, ...));
  static	u_char	mx4200_cksum	P((char *, u_int));
  static	int	mx4200_jday	P((int, int, int));
! static	void	mx4200_debug	P((struct peer *, char *, ...));
  static	int	mx4200_pps	P((struct peer *));
  
  /*
--- 183,205 ----
  #endif /* not QSORT_USES_VOID_P */
  static	void	mx4200_config	P((struct peer *));
  static	void	mx4200_ref	P((struct peer *));
! #ifdef __GNUC__
! #if __GNUC__ < 2  || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
! #ifndef __attribute__
! #define __attribute__(args)
! #endif
! #endif
! #else
! #ifndef __attribute__
! #define __attribute__(args)
! #endif
! #endif
! static	void	mx4200_send	P((struct peer *, char *, ...))
!     __attribute__ ((format (printf, 2, 3)));
  static	u_char	mx4200_cksum	P((char *, u_int));
  static	int	mx4200_jday	P((int, int, int));
! static	void	mx4200_debug	P((struct peer *, char *, ...))
!     __attribute__ ((format (printf, 2, 3)));
  static	int	mx4200_pps	P((struct peer *));
  
  /*
***************
*** 598,606 ****
  	    PMVXG_S_PORTCONF,
  	    PMVXG_D_PHV, /* control port output block Label */
  	    0,		/* clear current output control list (0=no) */
! 	    0);		/* add/delete sentences from list (0=delete) */
  			/* must be null */
! 	    		/* sentence output rate (sec) */
  	    		/* precision for position output */
  			/* nmea version for cga & gll output */
  			/* pass-through control */
--- 604,612 ----
  	    PMVXG_S_PORTCONF,
  	    PMVXG_D_PHV, /* control port output block Label */
  	    0,		/* clear current output control list (0=no) */
! 	    0,		/* add/delete sentences from list (0=delete) */
  			/* must be null */
! 	    0);		/* sentence output rate (sec) */
  	    		/* precision for position output */
  			/* nmea version for cga & gll output */
  			/* pass-through control */
***************
*** 700,706 ****
  	if ((pp->sloppyclockflag & CLK_FLAG2) !=
  	    (up->sloppyclockflag & CLK_FLAG2)) {
  		up->sloppyclockflag = pp->sloppyclockflag;
! 		mx4200_debug(peer, "mx4200_receive: mode switch: reset receiver\n", cp);
  		mx4200_config(peer);
  		return;
  	}
--- 706,713 ----
  	if ((pp->sloppyclockflag & CLK_FLAG2) !=
  	    (up->sloppyclockflag & CLK_FLAG2)) {
  		up->sloppyclockflag = pp->sloppyclockflag;
! 		mx4200_debug(peer,
! 		    "mx4200_receive: mode switch: reset receiver\n");
  		mx4200_config(peer);
  		return;
  	}
***************
*** 768,774 ****
  	 */
  	sentence_type = 0;
  	if ((cp = strchr(pp->lastcode, ',')) == NULL) {
! 		mx4200_debug(peer, "mx4200_receive: no sentence\n", cp);
  		refclock_report(peer, CEVNT_BADREPLY);
  		return;
  	}
--- 775,781 ----
  	 */
  	sentence_type = 0;
  	if ((cp = strchr(pp->lastcode, ',')) == NULL) {
! 		mx4200_debug(peer, "mx4200_receive: no sentence\n");
  		refclock_report(peer, CEVNT_BADREPLY);
  		return;
  	}
***************
*** 793,799 ****
  			mx4200_debug(peer,
  				"mx4200_receive: status: %s\n", cp);
  		}
! 		mx4200_debug(peer, "mx4200_receive: reset receiver\n", cp);
  		mx4200_config(peer);
  		return;
  	}
--- 800,806 ----
  			mx4200_debug(peer,
  				"mx4200_receive: status: %s\n", cp);
  		}
! 		mx4200_debug(peer, "mx4200_receive: reset receiver\n");
  		mx4200_config(peer);
  		return;
  	}
***************
*** 1706,1712 ****
  
  
  	/* Update values */
! 	if (ndop <= 0.0 || ndop<= 0.0 || vdop <= 0.0)
  		return ("nonpositive dop");
  	up->edop = edop;
  	up->ndop = ndop;
--- 1713,1719 ----
  
  
  	/* Update values */
! 	if (edop <= 0.0 || ndop <= 0.0 || vdop <= 0.0)
  		return ("nonpositive dop");
  	up->edop = edop;
  	up->ndop = ndop;
***************
*** 1911,1918 ****
  	if (ioctl(fdpps, CIOGETEV, (caddr_t)&up->ppsev) < 0) {
  		/* XXX Actually, if this fails, we're pretty much screwed */
  		mx4200_debug(peer, "mx4200_pps: CIOGETEV: ");
! 		if (errno < sys_nerr)
! 			mx4200_debug(peer, "%s", sys_errlist[errno]);
  		mx4200_debug(peer, "\n");
  		refclock_report(peer, CEVNT_FAULT);
  		return(1);
--- 1918,1924 ----
  	if (ioctl(fdpps, CIOGETEV, (caddr_t)&up->ppsev) < 0) {
  		/* XXX Actually, if this fails, we're pretty much screwed */
  		mx4200_debug(peer, "mx4200_pps: CIOGETEV: ");
! 		mx4200_debug(peer, "%s", strerror(errno));
  		mx4200_debug(peer, "\n");
  		refclock_report(peer, CEVNT_FAULT);
  		return(1);
