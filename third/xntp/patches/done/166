Replied: Wed, 06 Aug 1997 23:46:41 -0400
Replied: "jonathan@dsg.stanford.edu "
Return-Path: jonathan@dsg.stanford.edu 
Return-Path: <jonathan@dsg.stanford.edu>
Received: from Cup.DSG.Stanford.EDU (Cup.DSG.Stanford.EDU [171.64.79.91])
	by whimsy.udel.edu (8.8.5/8.8.5) with ESMTP id JAA23905
	for <stenn@whimsy.udel.edu>; Wed, 6 Aug 1997 09:11:25 GMT
Received: (from jonathan@localhost) by Cup.DSG.Stanford.EDU (8.8.5/8.6.9) id CAA07209; Wed, 6 Aug 1997 02:09:58 -0700 (PDT)
Date: Wed, 6 Aug 1997 02:09:58 -0700 (PDT)
From: Jonathan Stone <jonathan@dsg.stanford.edu>
Message-Id: <199708060909.CAA07209@Cup.DSG.Stanford.EDU>
To: David Mills  <mills@udel.edu>
To: Harlan Stenn  <stenn@whimsy.udel.edu>
To: gnats-bugs@gnats.netbsd.org
Subject:  xntp 3.90 ntptime bug
Reply-To: jonathan@dsg.stanford.edu
X-send-pr-version: 3.95


>Submitter-Id:	net
>Originator:	
>Organization:
	
>Confidential:	
>Synopsis:	<ntptime -c results off by factor of ~4>
>Severity:	
>Priority:	
>Category:	bin
>Class:		sw-bug
>Release:	<NetBSD-current source date>
>Environment:
	
System: NetBSD Cup.DSG.Stanford.EDU 1.2G NetBSD 1.2G (PLACEBO) #0: Wed Jul 30 10:31:00 PDT 1997 jonathan@Cup.DSG.Stanford.EDU:/usr/src/sys/arch/i386/compile/PLACEBO i386


[Mailed to xntpd maintainers and submitted to the NetBSD bug database.]


>Description:

    ntptime -c in xntp-3.5-90 produces an estimates of  syscall overhead
    (time between repeated calls to ntp_gettime) that is 2x-4x
    the true cost.

    This does not appear to  be fixed in 3.5-91.


>How-To-Repeat:

    Build ntptime from 3-5.90 (or as modified from the NetBSD source tree.)
    run ntptime -c.

    Compare to xntpd 3.5f ntptime -c on the same hardware and OS.

    A Decstation 5000/240 with reports 43 usecs and 16 usecs,
    for  3-5.90 and 3.5f,  respectively (either Ultrix or NetBSD).
    An Intel Pentium/133 with NetBSD reports 12 and 6, respectively.

    This rather defeats the raison d'e\^tre of ntptime -c :).

	
>Fix:

    The ntp source code uses sigsetjmp() to establish a signal hanlder to
    gracefully handle the case of calling ntp_gettime() on a kernel that
    doesn't have the in-kernel PLL code.

    UTSL shows that ntptime is establishing such a signal handler for
    every iteration of the ntptime -c loop, rather than just once,
    as the 3.5f code did.

    (Since the loop breaks if pll_control indicates an error, we can
     only trigger the handler once here anyway.)

    The fix is obvious: move the sigsetjmp() outside the loop.
    I can't figure out the house indentation style for the xntp code, sorry.



*** ntptime.c.DIST	Tue Jun 24 04:30:03 1997
--- ntptime.c	Wed Aug  6 01:39:14 1997
***************
*** 197,220 ****
  #endif /* BADCALL */
  
    if (cost) {
-     for (c = 0; c < sizeof times / sizeof times[0]; c++)
-       {
  #ifdef SIGSYS
  	if (sigsetjmp(env, 1) == 0)
  	  {
  #endif
  	    status = ntp_gettime(&ntv);
  	    if ((status < 0) && (errno == ENOSYS))
  	      {
  		--pll_control;
  	      }
- #ifdef SIGSYS
- 	  }
- #endif
  	if (pll_control < 0)
  	  break;
  	times[c] = ntv.time.tv_usec;
        }
      if (pll_control >= 0) {
        printf("[ us %06d:", times[0]);
        for (c = 1; c < sizeof times / sizeof times[0]; c++)
--- 197,221 ----
  #endif /* BADCALL */
  
    if (cost) {
  #ifdef SIGSYS
       if (sigsetjmp(env, 1) == 0)
         {
  #endif
+         for (c = 0; c < sizeof times / sizeof times[0]; c++)
+           {
  	    status = ntp_gettime(&ntv);
  	    if ((status < 0) && (errno == ENOSYS))
  	      {
  		--pll_control;
  	      }
  	if (pll_control < 0)
  	  break;
  	times[c] = ntv.time.tv_usec;
        }
+ #ifdef SIGSYS
+       }
+ #endif
+ 
      if (pll_control >= 0) {
        printf("[ us %06d:", times[0]);
        for (c = 1; c < sizeof times / sizeof times[0]; c++)
