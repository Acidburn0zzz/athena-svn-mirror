Return-Path: harlan@pfcs.com 
Return-Path: <harlan@pfcs.com>
Received: from pcpsj.pfcs.com (o+oRW/EF7GlW3okR/fC2UjHv9WjrNI3k@harlan.fred.net [205.252.219.31])
	by whimsy.udel.edu (8.8.5/8.8.5) with SMTP id FAA00971
	for <stenn@whimsy.udel.edu>; Mon, 9 Jun 1997 05:30:27 GMT
Received: from mumps.pfcs.com (mumps.pfcs.com [192.52.69.11]) by pcpsj.pfcs.com (8.6.12/8.6.9) with SMTP id BAA21634 for <stenn@whimsy.udel.edu>; Mon, 9 Jun 1997 01:30:19 -0400
Received: from brown.pfcs.com by mumps.pfcs.com with SMTP id AA25233
  (5.67b/IDA-1.5 for <stenn@whimsy.udel.edu>); Mon, 9 Jun 1997 01:30:18 -0400
Received: from harlan by brown.pfcs.com with local (Exim 1.62 #1)
	id 0wax22-000417-00; Mon, 9 Jun 1997 01:30:18 -0400
To: stenn@whimsy.udel.edu
Subject: clockinfo patches
Message-Id: <E0wax22-000417-00@brown.pfcs.com>
From: Harlan Stenn <Harlan.Stenn@pfcs.com>
Date: Mon, 9 Jun 1997 01:30:18 -0400

--- acconfig.h-	Sun Jun  8 23:04:22 1997
+++ acconfig.h	Sun Jun  8 23:05:28 1997
@@ -145,6 +145,12 @@
 /* define if struct sockaddr has sa_len */
 #undef HAVE_SA_LEN_IN_STRUCT_SOCKADDR
 
+/* define if struct clockinfo has hz */
+#undef HAVE_HZ_IN_STRUCT_CLOCKINFO
+
+/* define if struct clockinfo has tickadj */
+#undef 	HAVE_TICKADJ_IN_STRUCT_CLOCKINFO
+
 /* define if function prototypes are OK */
 #undef HAVE_PROTOTYPES
 
--- configure.in-	Sun Jun  8 23:00:54 1997
+++ configure.in	Sun Jun  8 23:22:17 1997
@@ -262,6 +262,30 @@
     AC_DEFINE(HAVE_SA_LEN_IN_STRUCT_SOCKADDR)
 fi
 
+AC_CACHE_CHECK(struct clockinfo for hz, ac_cv_struct_clockinfo_has_hz,
+[AC_TRY_COMPILE([
+#include <sys/time.h>],[
+extern struct clockinfo *pc;
+return pc->hz;],
+	ac_cv_struct_clockinfo_has_hz=yes,
+	ac_cv_struct_clockinfo_has_hz=no)
+])
+if test $ac_cv_struct_clockinfo_has_hz = yes; then
+    AC_DEFINE(HAVE_HZ_IN_STRUCT_CLOCKINFO)
+fi
+
+AC_CACHE_CHECK(struct clockinfo for tickadj, ac_cv_struct_clockinfo_has_tickadj,
+[AC_TRY_COMPILE([
+#include <sys/time.h>],[
+extern struct clockinfo *pc;
+return pc->tickadj;],
+	ac_cv_struct_clockinfo_has_tickadj=yes,
+	ac_cv_struct_clockinfo_has_tickadj=no)
+])
+if test $ac_cv_struct_clockinfo_has_tickadj = yes; then
+    AC_DEFINE(HAVE_TICKADJ_IN_STRUCT_CLOCKINFO)
+fi
+
 AC_CACHE_CHECK(if C compiler permits function prototypes, ac_cv_have_prototypes,
 [AC_TRY_COMPILE([
 extern int foo (short);
--- xntpd/ntp_unixclock.c-	Sun Jun  8 23:54:33 1997
+++ xntpd/ntp_unixclock.c	Mon Jun  9 01:27:19 1997
@@ -271,31 +271,6 @@
  *
  */
 
-#if defined(HAVE_SYSCTL) && defined(CTL_KERN) && defined(KERN_CLOCKRATE)
-static void
-clock_parms(ptickadj, ptick)
-    u_long *ptickadj;
-    u_long *ptick;
-{
-    int mib[2];
-    size_t len;
-    struct clockinfo c;
-    int e;
-
-    mib[0] = CTL_KERN;
-    mib[1] = KERN_CLOCKRATE;
-    len = sizeof(c);
-    e = sysctl(mib,2,&c,&len,NULL,0);
-    if (e != 0) {
-	NLOG(NLOG_SYSINFO) /* conditional if clause for conditional syslog */
-	syslog(LOG_NOTICE, "Could not find clockrate with sysctl\n");
-	exit(1);
-    }
-    *ptickadj = c.tickadj;
-    *ptick = c.tick;
-}
-#else
-
 static void
 clock_parms(ptickadj, ptick)
      u_long *ptickadj;
@@ -305,43 +280,50 @@
   int got_tick = 0;
   int got_tickadj = 0;
   int hz;
-#ifdef SYS_WINNT
+  int got_hz = 0;
+# ifdef SYS_WINNT
   DWORD add, every;
   BOOL noslew;
-#else
-#ifndef NOKMEM
+# else /* not SYS_WINNT */
+#  if defined(HAVE_SYSCTL) && defined(CTL_KERN) && defined(KERN_CLOCKRATE)
+  int mib[2];
+  size_t ci_len;
+  struct clockinfo c;
+  int rc;
+#  endif /* HAVE_SYSCTL && CTL_KERN && KERN_CLOCKRATE */
+#  ifndef NOKMEM
   static struct nlist nl[] =
   {
     NL_B
-# ifdef K_TICKADJ_NAME
+#   ifdef K_TICKADJ_NAME
 #  define N_TICKADJ 0
     K_TICKADJ_NAME
-# else
+#   else
     K_FILLER_NAME
-# endif /* K_TICKADJ_NAME */
+#   endif /* K_TICKADJ_NAME */
     NL_E,
     NL_B
-# ifdef K_TICK_NAME
+#   ifdef K_TICK_NAME
 #  define N_TICK 1
     K_TICK_NAME
-# else
+#   else
     K_FILLER_NAME
-# endif /* K_TICK_NAME */
+#   endif /* K_TICK_NAME */
     NL_E,
     NL_B "" NL_E,
   };
-# ifdef HAVE_K_OPEN
-# else /* not HAVE_K_OPEN */
-#  ifdef HAVE_KVM_OPEN
+#   ifdef HAVE_K_OPEN
+#   else /* not HAVE_K_OPEN */
+#    ifdef HAVE_KVM_OPEN
   register kvm_t *kd;
-#  else /* not HAVE_KVM_OPEN */
+#    else /* not HAVE_KVM_OPEN */
   register int i;
   int kmem;
   struct stat stbuf;
   off_t where;
-#   ifdef HAVE_BOOTFILE
+#     ifdef HAVE_BOOTFILE
   const char *kernelname;
-#   else /* not HAVE_BOOTFILE */
+#     else /* not HAVE_BOOTFILE */
   static char *kernelnames[] =
   {
     "/kernel/unix",
@@ -354,18 +336,18 @@
     "/netbsd",
     "/stand/vmunix",
     "/bsd",
-#    ifdef KERNELFILE
+#      ifdef KERNELFILE
     KERNELFILE,
-#    endif
+#      endif
     NULL
   };
-#   endif /* not HAVE_BOOTFILE */
-#  endif /* not HAVE_KVM_OPEN */
-# endif /* not HAVE_K_OPEN */
-#endif /* not NOKMEM */
-#endif /* not SYS_WINNT */
+#     endif /* not HAVE_BOOTFILE */
+#    endif /* not HAVE_KVM_OPEN */
+#   endif /* not HAVE_K_OPEN */
+#  endif /* not NOKMEM */
+# endif /* not SYS_WINNT */
 
-#ifdef SYS_WINNT
+# ifdef SYS_WINNT
   if (!GetSystemTimeAdjustment(&add, &every, &noslew))
     {
       *ptick = 0;
@@ -373,18 +355,45 @@
       return;
     }
   units_per_tick = add;
-#else /* not SYS_WINNT */
-  hz = HZ;
-#if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
-  hz = (int) sysconf (_SC_CLK_TCK);
-#endif /* SYS_WINNT */
-#ifdef OVERRIDE_HZ
-  hz = DEFAULT_HZ;
-#endif
+# else /* not SYS_WINNT */
+
+#  if defined(HAVE_SYSCTL) && defined(CTL_KERN) && defined(KERN_CLOCKRATE)
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_CLOCKRATE;
+    ci_len = sizeof(c);
+    rc = sysctl(mib, 2, &c, &ci_len, NULL, 0);
+    if (rc == -1)
+    {
+      NLOG(NLOG_SYSINFO) /* conditional if clause for conditional syslog */
+      syslog(LOG_NOTICE, "sysctl returned %d: %m", rc);
+    }
+    *ptick = c.tick;
+    ++got_tick;
+#   ifdef HAVE_TICKADJ_IN_STRUCT_CLOCKINFO
+    *ptickadj = c.tickadj;
+    ++got_tickadj;
+#   endif /* HAVE_TICKADJ_IN_STRUCT_CLOCKINFO */
+#   ifdef HAVE_HZ_IN_STRUCT_CLOCKINFO
+    hz = c.hz;
+    ++got_hz;
+#   endif /* HAVE_HZ_IN_STRUCT_CLOCKINFO */
+#  endif /* HAVE_SYSCTL && CTL_KERN && KERN_CLOCKRATE */
+
+  if (!got_hz)
+  {
+    hz = HZ;
+#  if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
+    hz = (int) sysconf (_SC_CLK_TCK);
+#  endif /* HAVE_SYSCONF && _SC_CLK_TCK */
+#  ifdef OVERRIDE_HZ
+    hz = DEFAULT_HZ;
+#  endif
+    ++got_hz;
+  }
 
   {
-#ifndef NOKMEM
-# ifdef HAVE_K_OPEN /* { */
+#  ifndef NOKMEM
+#   ifdef HAVE_K_OPEN /* { */
     if (K_open((char *)0, O_RDONLY, "/vmunix")!=0)
       {
 	msyslog(LOG_ERR, "K_open failed");
@@ -396,8 +405,8 @@
 	msyslog(LOG_ERR, "knlist failed");
 	exit(3);
       }
-# else  /* } not HAVE_K_OPEN { */
-#  ifdef HAVE_KVM_OPEN /* { */
+#   else  /* } not HAVE_K_OPEN { */
+#    ifdef HAVE_KVM_OPEN /* { */
     if ((kd = kvm_open(NULL, NULL, NULL, O_RDONLY, NULL)) == NULL)
       {
 	msyslog(LOG_ERR, "kvm_open failed");
@@ -408,8 +417,8 @@
 	msyslog(LOG_ERR, "kvm_nlist failed");
 	exit(3);
       }
-#  else /* } not HAVE_KVM_OPEN { */
-#   ifdef HAVE_GETBOOTFILE
+#    else /* } not HAVE_KVM_OPEN { */
+#     ifdef HAVE_GETBOOTFILE
     kernelname = getbootfile();
     if (!kernelname)
       {
@@ -426,7 +435,7 @@
 	msyslog(LOG_ERR, "nlist(%s) failed: %m", kernelname);
 	exit(3);
       }  
-#   else /* not HAVE_GETBOOTFILE */
+#     else /* not HAVE_GETBOOTFILE */
     for (i = 0; kernelnames[i] != NULL; i++)
       {
 	if (stat(kernelnames[i], &stbuf) == -1)
@@ -438,7 +447,7 @@
       {
 	msyslog(LOG_ERR, "Clock init couldn't find kernel object file");
       }
-#   endif /* not HAVE_GETBOOTFILE */
+#     endif /* not HAVE_GETBOOTFILE */
     kmem = open("/dev/kmem", O_RDONLY);
     if (kmem < 0)
       {
@@ -448,20 +457,21 @@
 	  perror("/dev/kmem");
 #endif
       }
-#  endif /* } not HAVE_KVM_OPEN */
-# endif /* } not HAVE_K_OPEN */
-#endif /* not NOKMEM */
+#    endif /* } not HAVE_KVM_OPEN */
+#   endif /* } not HAVE_K_OPEN */
+#  endif /* not NOKMEM */
   }
-#endif /* not SYS_WINNT */
+# endif /* not SYS_WINNT */
 
   /* Skippy says we need to know TICK before handling TICKADJ */
+  if (got_tick != 1)
   {
-#if defined(HAVE_SYS_TIMEX_H) && defined(HAVE___ADJTIMEX)
+# if defined(HAVE_SYS_TIMEX_H) && defined(HAVE___ADJTIMEX)
     struct timex txc;
-#endif /* HAVE_SYS_TIMEX_H && HAVE___ADJTIMEX */
+# endif /* HAVE_SYS_TIMEX_H && HAVE___ADJTIMEX */
 
-#if !defined(NOKMEM) && defined(N_TICK)
-# ifdef HAVE_K_OPEN
+# if !defined(NOKMEM) && defined(N_TICK)
+#  ifdef HAVE_K_OPEN
     if (K_read(ptick, sizeof(*ptick), nl[N_TICK].n_value) != sizeof(*ptick))
       {
 	msyslog(LOG_ERR, "K_read tick failed");
@@ -470,8 +480,8 @@
       {
 	if (*ptick) ++got_tick;
       }
-# else /* not HAVE_K_OPEN */
-#  ifdef HAVE_KVM_OPEN
+#  else /* not HAVE_K_OPEN */
+#   ifdef HAVE_KVM_OPEN
     if (kvm_read(kd, nl[N_TICK].n_value, (char *)ptick, sizeof(*ptick)) !=
 	sizeof(*ptick))
       {
@@ -481,7 +491,7 @@
       {
 	if (*ptick) ++got_tick;
       }
-#  else /* not HAVE_KVM_OPEN */
+#   else /* not HAVE_KVM_OPEN */
     if ((where = nl[N_TICK].n_value) == 0)
       {
 	msyslog(LOG_ERR, "Unknown kernel var <%s>",
@@ -503,7 +513,7 @@
 	      }
 	    else
 	      {
-#   ifdef NLIST_EXTRA_INDIRECTION
+#    ifdef NLIST_EXTRA_INDIRECTION
 		/*
 		 * Aix requires one more round of indirection
 		 * if storage class a pointer.
@@ -529,21 +539,21 @@
 			  }
 		      }
 		  }
-#   else /* not NLIST_EXTRA_INDIRECTION */
+#    else /* not NLIST_EXTRA_INDIRECTION */
 		if (*ptick) ++got_tick;
-#   endif /* not NLIST_EXTRA_INDIRECTION */
+#    endif /* not NLIST_EXTRA_INDIRECTION */
 	      }
 	  }
       }
-#  endif /* not HAVE_KVM_OPEN */
-# endif /* not HAVE_K_OPEN */
-# ifdef TICK_NANO
+#   endif /* not HAVE_KVM_OPEN */
+#  endif /* not HAVE_K_OPEN */
+#  ifdef TICK_NANO
     if (got_tick)
       {
 	*ptick /= 1000;
       }
-# endif /* TICK_NANO */
-#endif /* not NOKMEM && N_TICK */
+#  endif /* TICK_NANO */
+# endif /* not NOKMEM && N_TICK */
 
     if (!got_tick && default_tick)
       {
@@ -551,21 +561,21 @@
 	if (*ptick) ++got_tick;
       }
 
-#ifdef PRESET_TICK
+# ifdef PRESET_TICK
     if (!got_tick)
       {
-# if defined(HAVE_SYS_TIMEX_H) && defined(HAVE___ADJTIMEX)
-#  ifdef MOD_OFFSET
+#  if defined(HAVE_SYS_TIMEX_H) && defined(HAVE___ADJTIMEX)
+#   ifdef MOD_OFFSET
 	txc.modes = 0;
-#  else
+#   else
 	txc.mode = 0;
-#  endif
+#   endif
 	__adjtimex(&txc);
-# endif /* HAVE_SYS_TIMEX_H && HAVE___ADJTIMEX */
+#  endif /* HAVE_SYS_TIMEX_H && HAVE___ADJTIMEX */
 	*ptick = (u_long) PRESET_TICK;
 	if (*ptick) ++got_tick;
       }
-#endif  /* PRESET_TICK */
+# endif  /* PRESET_TICK */
 
     if (got_tick != 1)
       {
@@ -577,8 +587,9 @@
   }
 
   /* Skippy says we need to know TICK before handling TICKADJ */
+  if (got_tickadj != 1)
   {
-#if !defined(NOKMEM) && defined(N_TICKADJ)
+# if !defined(NOKMEM) && defined(N_TICKADJ)
     if (nl[N_TICKADJ].n_value == 0)
       {
 	msyslog(LOG_ERR, "Unknown kernel variable <%s>",
@@ -586,7 +597,7 @@
       }
     else
       {
-# ifdef HAVE_K_OPEN
+#  ifdef HAVE_K_OPEN
 	if (K_read(ptickadj, sizeof(*ptickadj), nl[N_TICKADJ].n_value) !=
 	    sizeof(*ptickadj))
 	  {
@@ -596,8 +607,8 @@
 	  {
 	    if (*ptickadj) ++got_tickadj;
 	  }
-# else /* not HAVE_K_OPEN */
-#  ifdef HAVE_KVM_OPEN
+#  else /* not HAVE_K_OPEN */
+#   ifdef HAVE_KVM_OPEN
 	if (kvm_read(kd, nl[N_TICKADJ].n_value, (char *)ptickadj, sizeof(*ptickadj)) !=
 	    sizeof(*ptickadj))
 	  {
@@ -607,7 +618,7 @@
 	  {
 	    if (*ptickadj) ++got_tickadj;
 	  }
-#  else /* not HAVE_KVM_OPEN */
+#   else /* not HAVE_KVM_OPEN */
 	if ((where = nl[N_TICKADJ].n_value) == 0)
 	  {
 	    msyslog(LOG_ERR, "Unknown kernel var <%s>",
@@ -630,7 +641,7 @@
 		  }
 		else
 		  {
-#   ifdef NLIST_EXTRA_INDIRECTION
+#    ifdef NLIST_EXTRA_INDIRECTION
 		    /*
 		     * Aix requires one more round of indirection
 		     * if storage class a pointer.
@@ -656,17 +667,17 @@
 			      }
 			  }
 		      }
-#   else /* not NLIST_EXTRA_INDIRECTION */
+#    else /* not NLIST_EXTRA_INDIRECTION */
 		    if (*ptickadj) ++got_tickadj;
-#   endif /* not NLIST_EXTRA_INDIRECTION */
+#    endif /* not NLIST_EXTRA_INDIRECTION */
 		  }
 	      }
 	  }
-#  endif /* not HAVE_KVM_OPEN */
-# endif /* not HAVE_K_OPEN */
+#   endif /* not HAVE_KVM_OPEN */
+#  endif /* not HAVE_K_OPEN */
       }
 
-# ifdef TICKADJ_NANO
+#  ifdef TICKADJ_NANO
     if (got_tickadj)
       {
 	*ptickadj /= 1000;
@@ -675,21 +686,21 @@
 	    *ptickadj = 1;
 	  }
       }
-# endif /* TICKADJ_NANO */
-# ifdef SCO5_TICKADJ
+#  endif /* TICKADJ_NANO */
+#  ifdef SCO5_TICKADJ
     if (got_tickadj)
       {
 	*ptickadj /= (1000 * hz);
       }
-# else /* not SCO5_TICKADJ */
-#  ifdef SCO3_TICKADJ
+#  else /* not SCO5_TICKADJ */
+#   ifdef SCO3_TICKADJ
     if (got_tickadj)
       {
 	*ptickadj *= (10000 / hz);
       }
-#  endif /* SCO3_TICKADJ */
-# endif/* not SCO5_TICKADJ */
-#endif /* not NOKMEM && N_TICKADJ */
+#   endif /* SCO3_TICKADJ */
+#  endif/* not SCO5_TICKADJ */
+# endif /* not NOKMEM && N_TICKADJ */
 
     if (!got_tickadj && default_tickadj)
       {
@@ -712,26 +723,25 @@
       }
   }
 
-#ifndef NOKMEM
-# ifdef HAVE_K_OPEN
+# ifndef NOKMEM
+#  ifdef HAVE_K_OPEN
   (void) K_close();
-# else /* not HAVE_K_OPEN */
-#  ifdef HAVE_KVM_OPEN
+#  else /* not HAVE_K_OPEN */
+#   ifdef HAVE_KVM_OPEN
   if (kvm_close(kd) < 0)
     {
       msyslog(LOG_ERR, "kvm_close failed");
       exit(3);
     }
-#  else /* not HAVE_KVM_OPEN */
+#   else /* not HAVE_KVM_OPEN */
   close(kmem);
-#  endif /* not HAVE_KVM_OPEN */
-# endif /* not HAVE_K_OPEN */
-#endif /* not NOKMEM */
+#   endif /* not HAVE_KVM_OPEN */
+#  endif /* not HAVE_K_OPEN */
+# endif /* not NOKMEM */
 
-#ifdef	DEBUG
+# ifdef	DEBUG
   if (debug)
     printf("tick = %ld, tickadj = %ld, hz = %d\n", *ptick, *ptickadj, hz);
-#endif
+# endif
 }
-#endif
 #endif /* not VMS */
