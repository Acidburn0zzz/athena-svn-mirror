<refentry id="gobject-Signals">
<refmeta>
<refentrytitle>Signals</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GOBJECT Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Signals</refname><refpurpose>A means for customization of object behaviour and a general purpose notification mechanism</refpurpose>
</refnamediv>

<refsynopsisdiv><title>Synopsis</title>

<synopsis>

#include &lt;gobject.h&gt;


struct      <link linkend="GSignalInvocationHint">GSignalInvocationHint</link>;
<link linkend="gboolean">gboolean</link>    (<link linkend="GSignalAccumulator">*GSignalAccumulator</link>)           (<link linkend="GSignalInvocationHint">GSignalInvocationHint</link> *ihint,
                                             <link linkend="GValue">GValue</link> *return_accu,
                                             const <link linkend="GValue">GValue</link> *handler_return,
                                             <link linkend="gpointer">gpointer</link> data);
typedef     <link linkend="GSignalCMarshaller">GSignalCMarshaller</link>;
<link linkend="gboolean">gboolean</link>    (<link linkend="GSignalEmissionHook">*GSignalEmissionHook</link>)          (<link linkend="GSignalInvocationHint">GSignalInvocationHint</link> *ihint,
                                             <link linkend="guint">guint</link> n_param_values,
                                             const <link linkend="GValue">GValue</link> *param_values,
                                             <link linkend="gpointer">gpointer</link> data);
enum        <link linkend="GSignalFlags">GSignalFlags</link>;
enum        <link linkend="GSignalMatchType">GSignalMatchType</link>;
struct      <link linkend="GSignalQuery">GSignalQuery</link>;
#define     <link linkend="G-SIGNAL-TYPE-STATIC-SCOPE-CAPS">G_SIGNAL_TYPE_STATIC_SCOPE</link>
#define     <link linkend="G-SIGNAL-MATCH-MASK-CAPS">G_SIGNAL_MATCH_MASK</link>
#define     <link linkend="G-SIGNAL-FLAGS-MASK-CAPS">G_SIGNAL_FLAGS_MASK</link>
<link linkend="guint">guint</link>       <link linkend="g-signal-new">g_signal_new</link>                    (const <link linkend="gchar">gchar</link> *signal_name,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="GSignalFlags">GSignalFlags</link> signal_flags,
                                             <link linkend="guint">guint</link> class_offset,
                                             <link linkend="GSignalAccumulator">GSignalAccumulator</link> accumulator,
                                             <link linkend="gpointer">gpointer</link> accu_data,
                                             <link linkend="GSignalCMarshaller">GSignalCMarshaller</link> c_marshaller,
                                             <link linkend="GType">GType</link> return_type,
                                             <link linkend="guint">guint</link> n_params,
                                             ...);
<link linkend="guint">guint</link>       <link linkend="g-signal-newv">g_signal_newv</link>                   (const <link linkend="gchar">gchar</link> *signal_name,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="GSignalFlags">GSignalFlags</link> signal_flags,
                                             <link linkend="GClosure">GClosure</link> *class_closure,
                                             <link linkend="GSignalAccumulator">GSignalAccumulator</link> accumulator,
                                             <link linkend="gpointer">gpointer</link> accu_data,
                                             <link linkend="GSignalCMarshaller">GSignalCMarshaller</link> c_marshaller,
                                             <link linkend="GType">GType</link> return_type,
                                             <link linkend="guint">guint</link> n_params,
                                             <link linkend="GType">GType</link> *param_types);
<link linkend="guint">guint</link>       <link linkend="g-signal-new-valist">g_signal_new_valist</link>             (const <link linkend="gchar">gchar</link> *signal_name,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="GSignalFlags">GSignalFlags</link> signal_flags,
                                             <link linkend="GClosure">GClosure</link> *class_closure,
                                             <link linkend="GSignalAccumulator">GSignalAccumulator</link> accumulator,
                                             <link linkend="gpointer">gpointer</link> accu_data,
                                             <link linkend="GSignalCMarshaller">GSignalCMarshaller</link> c_marshaller,
                                             <link linkend="GType">GType</link> return_type,
                                             <link linkend="guint">guint</link> n_params,
                                             va_list args);
void        <link linkend="g-signal-query">g_signal_query</link>                  (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="GSignalQuery">GSignalQuery</link> *query);
<link linkend="guint">guint</link>       <link linkend="g-signal-lookup">g_signal_lookup</link>                 (const <link linkend="gchar">gchar</link> *name,
                                             <link linkend="GType">GType</link> itype);
G_CONST_RETURN <link linkend="gchar">gchar</link>* <link linkend="g-signal-name">g_signal_name</link>         (<link linkend="guint">guint</link> signal_id);
<link linkend="guint">guint</link>*      <link linkend="g-signal-list-ids">g_signal_list_ids</link>               (<link linkend="GType">GType</link> itype,
                                             <link linkend="guint">guint</link> *n_ids);
void        <link linkend="g-signal-emit">g_signal_emit</link>                   (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             ...);
void        <link linkend="g-signal-emit-by-name">g_signal_emit_by_name</link>           (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             ...);
void        <link linkend="g-signal-emitv">g_signal_emitv</link>                  (const <link linkend="GValue">GValue</link> *instance_and_params,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GValue">GValue</link> *return_value);
void        <link linkend="g-signal-emit-valist">g_signal_emit_valist</link>            (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             va_list var_args);
#define     <link linkend="g-signal-connect">g_signal_connect</link>                (instance, detailed_signal, c_handler, data)
#define     <link linkend="g-signal-connect-after">g_signal_connect_after</link>          (instance, detailed_signal, c_handler, data)
#define     <link linkend="g-signal-connect-swapped">g_signal_connect_swapped</link>        (instance, detailed_signal, c_handler, data)
<link linkend="gulong">gulong</link>      <link linkend="g-signal-connect-object">g_signal_connect_object</link>         (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GCallback">GCallback</link> c_handler,
                                             <link linkend="gpointer">gpointer</link> gobject,
                                             <link linkend="GConnectFlags">GConnectFlags</link> connect_flags);
enum        <link linkend="GConnectFlags">GConnectFlags</link>;
<link linkend="gulong">gulong</link>      <link linkend="g-signal-connect-data">g_signal_connect_data</link>           (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GCallback">GCallback</link> c_handler,
                                             <link linkend="gpointer">gpointer</link> data,
                                             <link linkend="GClosureNotify">GClosureNotify</link> destroy_data,
                                             <link linkend="GConnectFlags">GConnectFlags</link> connect_flags);
<link linkend="gulong">gulong</link>      <link linkend="g-signal-connect-closure">g_signal_connect_closure</link>        (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gboolean">gboolean</link> after);
<link linkend="gulong">gulong</link>      <link linkend="g-signal-connect-closure-by-id">g_signal_connect_closure_by_id</link>  (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gboolean">gboolean</link> after);
void        <link linkend="g-signal-handler-block">g_signal_handler_block</link>          (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);
void        <link linkend="g-signal-handler-unblock">g_signal_handler_unblock</link>        (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);
void        <link linkend="g-signal-handler-disconnect">g_signal_handler_disconnect</link>     (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);
<link linkend="gulong">gulong</link>      <link linkend="g-signal-handler-find">g_signal_handler_find</link>           (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);
<link linkend="guint">guint</link>       <link linkend="g-signal-handlers-block-matched">g_signal_handlers_block_matched</link> (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);
<link linkend="guint">guint</link>       <link linkend="g-signal-handlers-unblock-matched">g_signal_handlers_unblock_matched</link>
                                            (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);
<link linkend="guint">guint</link>       <link linkend="g-signal-handlers-disconnect-matched">g_signal_handlers_disconnect_matched</link>
                                            (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);
<link linkend="gboolean">gboolean</link>    <link linkend="g-signal-handler-is-connected">g_signal_handler_is_connected</link>   (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);
#define     <link linkend="g-signal-handlers-block-by-func">g_signal_handlers_block_by_func</link> (instance, func, data)
#define     <link linkend="g-signal-handlers-unblock-by-func">g_signal_handlers_unblock_by_func</link>(instance, func, data)
#define     <link linkend="g-signal-handlers-disconnect-by-func">g_signal_handlers_disconnect_by_func</link>(instance, func, data)
<link linkend="gboolean">gboolean</link>    <link linkend="g-signal-has-handler-pending">g_signal_has_handler_pending</link>    (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="gboolean">gboolean</link> may_be_blocked);
void        <link linkend="g-signal-stop-emission">g_signal_stop_emission</link>          (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail);
void        <link linkend="g-signal-stop-emission-by-name">g_signal_stop_emission_by_name</link>  (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal);
void        <link linkend="g-signal-override-class-closure">g_signal_override_class_closure</link> (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="GType">GType</link> instance_type,
                                             <link linkend="GClosure">GClosure</link> *class_closure);
void        <link linkend="g-signal-chain-from-overridden">g_signal_chain_from_overridden</link>  (const <link linkend="GValue">GValue</link> *instance_and_params,
                                             <link linkend="GValue">GValue</link> *return_value);
<link linkend="gulong">gulong</link>      <link linkend="g-signal-add-emission-hook">g_signal_add_emission_hook</link>      (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GSignalEmissionHook">GSignalEmissionHook</link> hook_func,
                                             <link linkend="gpointer">gpointer</link> hook_data,
                                             <link linkend="GDestroyNotify">GDestroyNotify</link> data_destroy);
void        <link linkend="g-signal-remove-emission-hook">g_signal_remove_emission_hook</link>   (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="gulong">gulong</link> hook_id);
<link linkend="gboolean">gboolean</link>    <link linkend="g-signal-parse-name">g_signal_parse_name</link>             (const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="guint">guint</link> *signal_id_p,
                                             <link linkend="GQuark">GQuark</link> *detail_p,
                                             <link linkend="gboolean">gboolean</link> force_detail_quark);
<link linkend="GSignalInvocationHint">GSignalInvocationHint</link>* <link linkend="g-signal-get-invocation-hint">g_signal_get_invocation_hint</link>
                                            (<link linkend="gpointer">gpointer</link> instance);
<link linkend="GClosure">GClosure</link>*   <link linkend="g-signal-type-cclosure-new">g_signal_type_cclosure_new</link>      (<link linkend="GType">GType</link> itype,
                                             <link linkend="guint">guint</link> struct_offset);

</synopsis>
</refsynopsisdiv>







<refsect1>
<title>Description</title>
<para>
The basic concept of the signal system is that of the <emphasis>emission</emphasis>
of a signal.
Signals are introduced per-type and are identified through strings.
Signals introduced for a parent type are available in derived types as well,
so basically they are a per-type facility that is inherited.
A signal emission mainly involves invocation of a certain set of callbacks in
precisely defined manner. There are two main categories of such callbacks,
per-object
	<footnote><para>Although signals can deal with any kind of instantiatable type,
	i'm referring to those types as "object types" in the following, simply
	because that is the context most users will encounter signals in.
	</para></footnote>
ones and user provided ones.
The per-object callbacks are most often referred to as "object method
handler" or "default (signal) handler", while user provided callbacks are
usually just called "signal handler".
The object method handler is provided at signal creation time (this most
frequently happens at the end of an object class' creation), while user
provided handlers are frequently connected and disconnected to/from a certain
signal on certain object instances.
</para>
<para>
A signal emission consists of five stages, unless prematurely stopped:
<variablelist>
  <varlistentry><term></term><listitem><para>
	1 - Invocation of the object method handler for <literal>G_SIGNAL_RUN_FIRST</literal> signals
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	2 - Invocation of normal user-provided signal handlers (<emphasis>after</emphasis> flag <literal>FALSE</literal>)
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	3 - Invocation of the object method handler for <literal>G_SIGNAL_RUN_LAST</literal> signals
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	4 - Invocation of user provided signal handlers, connected with an <emphasis>after</emphasis> flag of <literal>TRUE</literal>
  </para></listitem></varlistentry>
  <varlistentry><term></term><listitem><para>
	5 - Invocation of the object method handler for <literal>G_SIGNAL_RUN_CLEANUP</literal> signals
  </para></listitem></varlistentry>
</variablelist>
The user provided signal handlers are called in the order they were
connected in.
All handlers may prematurely stop a signal emission, and any number of
handlers may be connected, disconnected, blocked or unblocked during
a signal emission.
There are certain criteria for skipping user handlers in stages 2 and 4
of a signal emission.
First, user handlers may be <emphasis>blocked</emphasis>, blocked handlers are omitted
during callback invocation, to return from the "blocked" state, a
handler has to get unblocked exactly the same amount of times
it has been blocked before.
Second, upon emission of a <literal>G_SIGNAL_DETAILED</literal> signal, an additional
"detail" argument passed in to <link linkend="g-signal-emit">g_signal_emit</link>() has to match the detail
argument of the signal handler currently subject to invocation.
Specification of no detail argument for signal handlers (omission of the
detail part of the signal specification upon connection) serves as a
wildcard and matches any detail argument passed in to emission.
</para>
</refsect1>

<refsect1>
<title>Details</title>
<refsect2>
<title><anchor id="GSignalInvocationHint"/>struct GSignalInvocationHint</title>
<programlisting>struct GSignalInvocationHint {

  guint		signal_id;
  GQuark	detail;
  GSignalFlags	run_type;
};
</programlisting>
<para>
The <link linkend="GSignalInvocationHint">GSignalInvocationHint</link> structure is used to pass on additional information
to callbacks during a signal emission.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="guint">guint</link> <structfield>signal_id</structfield></term>
<listitem><simpara>	The signal id of the signal invoking the callback
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GQuark">GQuark</link> <structfield>detail</structfield></term>
<listitem><simpara>	The detail passed on for this emission
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GSignalFlags">GSignalFlags</link> <structfield>run_type</structfield></term>
<listitem><simpara>	The stage the signal emission is currently in, this
		field will contain one of <literal>G_SIGNAL_RUN_FIRST</literal>,
		<literal>G_SIGNAL_RUN_LAST</literal> or <literal>G_SIGNAL_RUN_CLEANUP</literal>.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GSignalAccumulator"/>GSignalAccumulator ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    (*GSignalAccumulator)           (<link linkend="GSignalInvocationHint">GSignalInvocationHint</link> *ihint,
                                             <link linkend="GValue">GValue</link> *return_accu,
                                             const <link linkend="GValue">GValue</link> *handler_return,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
The signal accumulator is a special callback function that can be used
to collect return values of the various callbacks that are called
during a signal emission. The signal accumulator is specified at signal
creation time, if it is left NULL, no accumulation of callback return
values is performed. The return value of signal emissions is then the
value returned by the last callback.
</para><variablelist role="params">
<varlistentry><term><parameter>ihint</parameter>&nbsp;:</term>
<listitem><simpara>	Signal invocation hint, see <link linkend="GSignalInvocationHint">GSignalInvocationHint</link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>return_accu</parameter>&nbsp;:</term>
<listitem><simpara>	Accumulator to collect callback return values in, this
		is the return value of the current signal emission.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler_return</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>	The accumulator function returns whether the signal emission
		should be aborted. Returning <literal>FALSE</literal> means to abort the
		current emission and <literal>TRUE</literal> is returned for continuation.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GSignalCMarshaller"/>GSignalCMarshaller</title>
<programlisting>typedef GClosureMarshal			 GSignalCMarshaller;
</programlisting>
<para>
This is the signature of marshaller functions, required to marshall
arrays of parameter values to signal emissions into C language callback
invocations. It is merely an alias to <link linkend="GClosureMarshal">GClosureMarshal</link> since the <link linkend="GClosure">GClosure</link>
mechanism takes over responsibility of actual function invocation for the
signal system.
</para></refsect2>
<refsect2>
<title><anchor id="GSignalEmissionHook"/>GSignalEmissionHook ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    (*GSignalEmissionHook)          (<link linkend="GSignalInvocationHint">GSignalInvocationHint</link> *ihint,
                                             <link linkend="guint">guint</link> n_param_values,
                                             const <link linkend="GValue">GValue</link> *param_values,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
A simple function pointer to get invoked when the signal is emitted. This 
allows you tie a hook to the signal type, so that it will trap all emissions 
of that signal, from any object.
</para>
<para>
You may not attach these to signals created with the <link linkend="G-SIGNAL-NO-HOOKS-CAPS">G_SIGNAL_NO_HOOKS</link> flag.
</para><variablelist role="params">
<varlistentry><term><parameter>ihint</parameter>&nbsp;:</term>
<listitem><simpara>Signal invocation hint, see <link linkend="GSignalInvocationHint">GSignalInvocationHint</link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_param_values</parameter>&nbsp;:</term>
<listitem><simpara>the number of parameters to the function, including
                 the instance on which the signal was emitted.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>param_values</parameter>&nbsp;:</term>
<listitem><simpara>the instance on which the signal was emitted, followed by the 
               parameters of the emission.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>user data associated with the hook.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>whether it wished to be removed. If it returns <literal>TRUE</literal>, the signal 
          hook is disconnected (and destroyed).


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GSignalFlags"/>enum GSignalFlags</title>
<programlisting>typedef enum
{
  G_SIGNAL_RUN_FIRST	= 1 &lt;&lt; 0,
  G_SIGNAL_RUN_LAST	= 1 &lt;&lt; 1,
  G_SIGNAL_RUN_CLEANUP	= 1 &lt;&lt; 2,
  G_SIGNAL_NO_RECURSE	= 1 &lt;&lt; 3,
  G_SIGNAL_DETAILED	= 1 &lt;&lt; 4,
  G_SIGNAL_ACTION	= 1 &lt;&lt; 5,
  G_SIGNAL_NO_HOOKS	= 1 &lt;&lt; 6
} GSignalFlags;
</programlisting>
<para>
The signal flags are used to specify a signal's behaviour, the overall
signal description outlines how especially the RUN flags control the
stages of a signal emission.
</para><variablelist role="enum">
<varlistentry>
<term><literal>G_SIGNAL_RUN_FIRST</literal></term>
<listitem><simpara>  Invoke the object method handler in the first emission stage.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_RUN_LAST</literal></term>
<listitem><simpara>   Invoke the object method handler in the third emission stage.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_RUN_CLEANUP</literal></term>
<listitem><simpara>Invoke the object method handler in the last emission stage.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_NO_RECURSE</literal></term>
<listitem><simpara> Signals being emitted for an object while currently being in
                       emission for this very object will not be emitted recursively,
                       but instead cause the first emission to be restarted.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_DETAILED</literal></term>
<listitem><simpara>   This signal supports "::detail" appendixes to the signal name
                       upon handler connections and emissions.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_ACTION</literal></term>
<listitem><simpara>     Action signals are signals that may freely be emitted on alive
                       objects from user code via <link linkend="g-signal-emit">g_signal_emit</link>() and friends, without
                       the need of being embedded into extra code that performs pre or
                       post emission adjustments on the object. They can also be thought
                       of as by third-party code generically callable object methods.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_NO_HOOKS</literal></term>
<listitem><simpara>   No emissions hooks are supported for this signal.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GSignalMatchType"/>enum GSignalMatchType</title>
<programlisting>typedef enum
{
  G_SIGNAL_MATCH_ID	   = 1 &lt;&lt; 0,
  G_SIGNAL_MATCH_DETAIL	   = 1 &lt;&lt; 1,
  G_SIGNAL_MATCH_CLOSURE   = 1 &lt;&lt; 2,
  G_SIGNAL_MATCH_FUNC	   = 1 &lt;&lt; 3,
  G_SIGNAL_MATCH_DATA	   = 1 &lt;&lt; 4,
  G_SIGNAL_MATCH_UNBLOCKED = 1 &lt;&lt; 5
} GSignalMatchType;
</programlisting>
<para>
The match types specify what <link linkend="g-signal-handlers-block-matched">g_signal_handlers_block_matched</link>(),
<link linkend="g-signal-handlers-unblock-matched">g_signal_handlers_unblock_matched</link>() and <link linkend="g-signal-handlers-disconnect-matched">g_signal_handlers_disconnect_matched</link>()
match signals by.
</para><variablelist role="enum">
<varlistentry>
<term><literal>G_SIGNAL_MATCH_ID</literal></term>
<listitem><simpara>The signal id must be equal.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_MATCH_DETAIL</literal></term>
<listitem><simpara>The signal detail be equal.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_MATCH_CLOSURE</literal></term>
<listitem><simpara>The closure must be the same.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_MATCH_FUNC</literal></term>
<listitem><simpara>The C closure callback must be the same.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_MATCH_DATA</literal></term>
<listitem><simpara>The closure data must be the same.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_SIGNAL_MATCH_UNBLOCKED</literal></term>
<listitem><simpara>Only unblocked signals may matched.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GSignalQuery"/>struct GSignalQuery</title>
<programlisting>struct GSignalQuery {

  guint		signal_id;
  const gchar  *signal_name;
  GType		itype;
  GSignalFlags	signal_flags;
  GType		return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
  guint		n_params;
  const GType  *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
};
</programlisting>
<para>
A structure holding in-depth information for a specific signal. It is
filled in by the <link linkend="g-signal-query">g_signal_query</link>() function.
</para><variablelist role="struct">
<varlistentry>
<term><link linkend="guint">guint</link> <structfield>signal_id</structfield></term>
<listitem><simpara>	The signal id of the signal being queried, or 0 if the
		signal to be queried was unknown.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const <link linkend="gchar">gchar</link> *<structfield>signal_name</structfield></term>
<listitem><simpara>	The signal name.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GType">GType</link> <structfield>itype</structfield></term>
<listitem><simpara>	The interface/instance type that this signal can be emitted for.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GSignalFlags">GSignalFlags</link> <structfield>signal_flags</structfield></term>
<listitem><simpara>	The signal flags as passed in to <link linkend="g-signal-new">g_signal_new</link>().
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="GType">GType</link> <structfield>return_type</structfield></term>
<listitem><simpara>	The return type for user callbacks.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint">guint</link> <structfield>n_params</structfield></term>
<listitem><simpara>	The number of parameters that user callbacks take.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const <link linkend="GType">GType</link> *<structfield>param_types</structfield></term>
<listitem><simpara>	The individual parameter types for user callbacks, note that the
		effective callback signature is:
<programlisting>
<parameter>return_type</parameter> callback (<link linkend="gpointer">gpointer</link>     data1,
                      [<link linkend="param-types">param_types</link> param_names,]
                       <link linkend="gpointer">gpointer</link>     data2);
</programlisting>

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-SIGNAL-TYPE-STATIC-SCOPE-CAPS"/>G_SIGNAL_TYPE_STATIC_SCOPE</title>
<programlisting>#define	G_SIGNAL_TYPE_STATIC_SCOPE (G_TYPE_FLAG_RESERVED_ID_BIT)
</programlisting>
<para>
This macro flags signal argument types for which the signal system may 
assume that instances thereof remain persistent across all signal emissions
they are used in. This is only useful for non ref-counted, value-copy types.
</para>
<para>
To flag a signal argument in this way, add 
<literal>| G_SIGNAL_TYPE_STATIC_SCOPE</literal> to the corresponding argument
of <link linkend="g-signal-new">g_signal_new</link>().
</para>
<informalexample>
<programlisting>
    g_signal_new ("size_request",
		  G_TYPE_FROM_CLASS (gobject_class),
		  G_SIGNAL_RUN_FIRST,
		  G_STRUCT_OFFSET (GtkWidgetClass, size_request),
		  NULL, NULL,
		  _gtk_marshal_VOID__BOXED,
		  G_TYPE_NONE, 1,
		  GTK_TYPE_REQUISITION | G_SIGNAL_TYPE_STATIC_SCOPE);
</programlisting>
</informalexample></refsect2>
<refsect2>
<title><anchor id="G-SIGNAL-MATCH-MASK-CAPS"/>G_SIGNAL_MATCH_MASK</title>
<programlisting>#define G_SIGNAL_MATCH_MASK  0x3f
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="G-SIGNAL-FLAGS-MASK-CAPS"/>G_SIGNAL_FLAGS_MASK</title>
<programlisting>#define G_SIGNAL_FLAGS_MASK  0x7f
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="g-signal-new"/>g_signal_new ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_new                    (const <link linkend="gchar">gchar</link> *signal_name,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="GSignalFlags">GSignalFlags</link> signal_flags,
                                             <link linkend="guint">guint</link> class_offset,
                                             <link linkend="GSignalAccumulator">GSignalAccumulator</link> accumulator,
                                             <link linkend="gpointer">gpointer</link> accu_data,
                                             <link linkend="GSignalCMarshaller">GSignalCMarshaller</link> c_marshaller,
                                             <link linkend="GType">GType</link> return_type,
                                             <link linkend="guint">guint</link> n_params,
                                             ...);</programlisting>
<para>
Creates a new signal. (This is usually done in the class initializer.)
</para>
<para>
A signal name consists of segments consisting of ASCII letters and
digits, separated by either the '-' or '_' character. The first
character of a signal name must be a letter. Names which violate these
rules lead to undefined behaviour of the GSignal system. 
</para>
<para>
When registering a signal and looking up a signal, either separator can
be used, but they cannot be mixed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_name</parameter>&nbsp;:</term>
<listitem><simpara> the name for the signal
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara> the type this signal pertains to. It will also pertain to 
   types which are derived from this type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_flags</parameter>&nbsp;:</term>
<listitem><simpara> a combination of <link linkend="GSignalFlags">GSignalFlags</link> specifying detail of when 
   the default handler is to be invoked. You should at least specify 
   <literal>G_SIGNAL_RUN_FIRST</literal> or <literal>G_SIGNAL_RUN_LAST</literal>. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>class_offset</parameter>&nbsp;:</term>
<listitem><simpara> The offset of the function pointer in the class structure 
   for this type. Used to invoke a class method generically.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>accumulator</parameter>&nbsp;:</term>
<listitem><simpara> the accumulator for this signal; may be <literal>NULL</literal>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>accu_data</parameter>&nbsp;:</term>
<listitem><simpara> user data for the <parameter>accumulator</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_marshaller</parameter>&nbsp;:</term>
<listitem><simpara> the function to translate arrays of parameter values to 
   signal emissions into C language callback invocations.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>return_type</parameter>&nbsp;:</term>
<listitem><simpara> the type of return value, or <link linkend="G-TYPE-NONE-CAPS">G_TYPE_NONE</link> for a signal 
   without a return value.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_params</parameter>&nbsp;:</term>
<listitem><simpara> the number of parameter types to follow.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>...</parameter>&nbsp;:</term>
<listitem><simpara> a list of types, one for each parameter.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the signal id
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-newv"/>g_signal_newv ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_newv                   (const <link linkend="gchar">gchar</link> *signal_name,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="GSignalFlags">GSignalFlags</link> signal_flags,
                                             <link linkend="GClosure">GClosure</link> *class_closure,
                                             <link linkend="GSignalAccumulator">GSignalAccumulator</link> accumulator,
                                             <link linkend="gpointer">gpointer</link> accu_data,
                                             <link linkend="GSignalCMarshaller">GSignalCMarshaller</link> c_marshaller,
                                             <link linkend="GType">GType</link> return_type,
                                             <link linkend="guint">guint</link> n_params,
                                             <link linkend="GType">GType</link> *param_types);</programlisting>
<para>
Creates a new signal. (This is usually done in the class initializer.)
</para>
<para>
See <link linkend="g-signal-new">g_signal_new</link>() for details on allowed signal names.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_name</parameter>&nbsp;:</term>
<listitem><simpara> the name for the signal
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara> the type this signal pertains to. It will also pertain to 
   types which are derived from this type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_flags</parameter>&nbsp;:</term>
<listitem><simpara> a combination of <link linkend="GSignalFlags">GSignalFlags</link> specifying detail of when 
   the default handler is to be invoked. You should at least specify 
   <literal>G_SIGNAL_RUN_FIRST</literal> or <literal>G_SIGNAL_RUN_LAST</literal>. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>class_closure</parameter>&nbsp;:</term>
<listitem><simpara> The closure to invoke on signal emission. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>accumulator</parameter>&nbsp;:</term>
<listitem><simpara> the accumulator for this signal; may be <literal>NULL</literal>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>accu_data</parameter>&nbsp;:</term>
<listitem><simpara> user data for the <parameter>accumulator</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_marshaller</parameter>&nbsp;:</term>
<listitem><simpara> the function to translate arrays of parameter values to 
   signal emissions into C language callback invocations.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>return_type</parameter>&nbsp;:</term>
<listitem><simpara> the type of return value, or <link linkend="G-TYPE-NONE-CAPS">G_TYPE_NONE</link> for a signal 
   without a return value.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_params</parameter>&nbsp;:</term>
<listitem><simpara> the length of <parameter>param_types</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>param_types</parameter>&nbsp;:</term>
<listitem><simpara> an array types, one for each parameter.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the signal id
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-new-valist"/>g_signal_new_valist ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_new_valist             (const <link linkend="gchar">gchar</link> *signal_name,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="GSignalFlags">GSignalFlags</link> signal_flags,
                                             <link linkend="GClosure">GClosure</link> *class_closure,
                                             <link linkend="GSignalAccumulator">GSignalAccumulator</link> accumulator,
                                             <link linkend="gpointer">gpointer</link> accu_data,
                                             <link linkend="GSignalCMarshaller">GSignalCMarshaller</link> c_marshaller,
                                             <link linkend="GType">GType</link> return_type,
                                             <link linkend="guint">guint</link> n_params,
                                             va_list args);</programlisting>
<para>
Creates a new signal. (This is usually done in the class initializer.)
</para>
<para>
See <link linkend="g-signal-new">g_signal_new</link>() for details on allowed signal names.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_name</parameter>&nbsp;:</term>
<listitem><simpara> the name for the signal
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara> the type this signal pertains to. It will also pertain to 
   types which are derived from this type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_flags</parameter>&nbsp;:</term>
<listitem><simpara> a combination of <link linkend="GSignalFlags">GSignalFlags</link> specifying detail of when 
   the default handler is to be invoked. You should at least specify 
   <literal>G_SIGNAL_RUN_FIRST</literal> or <literal>G_SIGNAL_RUN_LAST</literal>. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>class_closure</parameter>&nbsp;:</term>
<listitem><simpara> The closure to invoke on signal emission. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>accumulator</parameter>&nbsp;:</term>
<listitem><simpara> the accumulator for this signal; may be <literal>NULL</literal>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>accu_data</parameter>&nbsp;:</term>
<listitem><simpara> user data for the <parameter>accumulator</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_marshaller</parameter>&nbsp;:</term>
<listitem><simpara> the function to translate arrays of parameter values to 
   signal emissions into C language callback invocations.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>return_type</parameter>&nbsp;:</term>
<listitem><simpara> the type of return value, or <link linkend="G-TYPE-NONE-CAPS">G_TYPE_NONE</link> for a signal 
   without a return value.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_params</parameter>&nbsp;:</term>
<listitem><simpara> the number of parameter types in <parameter>args</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>args</parameter>&nbsp;:</term>
<listitem><simpara> va_list of <link linkend="GType">GType</link>, one for each parameter.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the signal id
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-query"/>g_signal_query ()</title>
<programlisting>void        g_signal_query                  (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="GSignalQuery">GSignalQuery</link> *query);</programlisting>
<para>
Queries the signal system for in-depth information about a
specific signal. This function will fill in a user-provided
structure to hold signal-specific information. If an invalid
signal id is passed in, the <parameter>signal_id</parameter> member of the <link linkend="GSignalQuery">GSignalQuery</link>
is 0. All members filled into the <link linkend="GSignalQuery">GSignalQuery</link> structure should
be considered constant and have to be left untouched.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> The signal id of the signal to query information for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>query</parameter>&nbsp;:</term>
<listitem><simpara> A user provided structure that is filled in with constant
        values upon success.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-lookup"/>g_signal_lookup ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_lookup                 (const <link linkend="gchar">gchar</link> *name,
                                             <link linkend="GType">GType</link> itype);</programlisting>
<para>
Given the name of the signal and the type of object it connects to, gets 
the signal's identifying integer. Emitting the signal by number is 
somewhat faster than using the name each time.
</para>
<para>
Also tries the ancestors of the given type.
</para>
<para>
See <link linkend="g-signal-new">g_signal_new</link>() for details on allowed signal names.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> the signal's name.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara> the type that the signal operates on.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the signal's identifying number, or 0 if no signal was found.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-name"/>g_signal_name ()</title>
<programlisting>G_CONST_RETURN <link linkend="gchar">gchar</link>* g_signal_name         (<link linkend="guint">guint</link> signal_id);</programlisting>
<para>
Given the signal's identifier, finds its name.
</para>
<para>
Two different signals may have the same name, if they have differing types.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal's identifying number.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the signal name, or <literal>NULL</literal> if the signal number was invalid.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-list-ids"/>g_signal_list_ids ()</title>
<programlisting><link linkend="guint">guint</link>*      g_signal_list_ids               (<link linkend="GType">GType</link> itype,
                                             <link linkend="guint">guint</link> *n_ids);</programlisting>
<para>
Lists the signals by id that a certain instance or interface type
created. Further information about the signals can be acquired through
<link linkend="g-signal-query">g_signal_query</link>().</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara> Instance or interface type.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n_ids</parameter>&nbsp;:</term>
<listitem><simpara> Location to store the number of signal ids for <parameter>itype</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Newly allocated array of signal IDs.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-emit"/>g_signal_emit ()</title>
<programlisting>void        g_signal_emit                   (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             ...);</programlisting>
<para>
Emits a signal. 
</para>
<para>
Note that <link linkend="g-signal-emit">g_signal_emit</link>() resets the return value to the default
if no handlers are connected, in contrast to <link linkend="g-signal-emitv">g_signal_emitv</link>().</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance the signal is being emitted on.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal id 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>...</parameter>&nbsp;:</term>
<listitem><simpara> parameters to be passed to the signal, followed by a
           location for the return value. If the return type of the signal
           is <link linkend="G-TYPE-NONE-CAPS">G_TYPE_NONE</link>, the return value location can be omitted.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-emit-by-name"/>g_signal_emit_by_name ()</title>
<programlisting>void        g_signal_emit_by_name           (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             ...);</programlisting>
<para>
Emits a signal. 
</para>
<para>
Note that <link linkend="g-signal-emit-by-name">g_signal_emit_by_name</link>() resets the return value to the default
if no handlers are connected, in contrast to <link linkend="g-signal-emitv">g_signal_emitv</link>().</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance the signal is being emitted on.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>...</parameter>&nbsp;:</term>
<listitem><simpara> parameters to be passed to the signal, followed by a
          location for the return value. If the return type of the signal
          is <link linkend="G-TYPE-NONE-CAPS">G_TYPE_NONE</link>, the return value location can be omitted.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-emitv"/>g_signal_emitv ()</title>
<programlisting>void        g_signal_emitv                  (const <link linkend="GValue">GValue</link> *instance_and_params,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GValue">GValue</link> *return_value);</programlisting>
<para>
Emits a signal. 
</para>
<para>
Note that <link linkend="g-signal-emitv">g_signal_emitv</link>() doesn't change <parameter>return_value</parameter> if no handlers are
connected, in contrast to <link linkend="g-signal-emit">g_signal_emit</link>() and <link linkend="g-signal-emit-valist">g_signal_emit_valist</link>().</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance_and_params</parameter>&nbsp;:</term>
<listitem><simpara> argument list for the signal emission. The first 
     element in the array is a <link linkend="GValue">GValue</link> for the instance the signal is 
     being emitted on. The rest are any arguments to be passed to the 
     signal.  
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal id 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>return_value</parameter>&nbsp;:</term>
<listitem><simpara> Location to store the return value of the signal emission.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-emit-valist"/>g_signal_emit_valist ()</title>
<programlisting>void        g_signal_emit_valist            (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             va_list var_args);</programlisting>
<para>
Emits a signal. 
</para>
<para>
Note that <link linkend="g-signal-emit-valist">g_signal_emit_valist</link>() resets the return value to the default
if no handlers are connected, in contrast to <link linkend="g-signal-emitv">g_signal_emitv</link>().</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance the signal is being emitted on.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal id 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>var_args</parameter>&nbsp;:</term>
<listitem><simpara> a list of parameters to be passed to the signal, followed by a
           location for the return value. If the return type of the signal
           is <link linkend="G-TYPE-NONE-CAPS">G_TYPE_NONE</link>, the return value location can be omitted.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect"/>g_signal_connect()</title>
<programlisting>#define     g_signal_connect(instance, detailed_signal, c_handler, data)</programlisting>
<para>
Connects a <link linkend="GCallback">GCallback</link> function to a signal for a particular object.
</para>
<para>
The handler will be called before the default handler of the signal.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara>a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_handler</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GCallback">GCallback</link> to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>data to pass to <parameter>c_handler</parameter> calls.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>the handler id


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect-after"/>g_signal_connect_after()</title>
<programlisting>#define     g_signal_connect_after(instance, detailed_signal, c_handler, data)</programlisting>
<para>
Connects a <link linkend="GCallback">GCallback</link> function to a signal for a particular object.
</para>
<para>
The handler will be called after the default handler of the signal.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara>a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_handler</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GCallback">GCallback</link> to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>data to pass to <parameter>c_handler</parameter> calls.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>the handler id


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect-swapped"/>g_signal_connect_swapped()</title>
<programlisting>#define     g_signal_connect_swapped(instance, detailed_signal, c_handler, data)</programlisting>
<para>
Connects a <link linkend="GCallback">GCallback</link> function to a signal for a particular object.
</para>
<para>
The instance on which the signal is emitted and <parameter>data</parameter> will be swapped when 
calling the handler.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara>a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_handler</parameter>&nbsp;:</term>
<listitem><simpara>the <link linkend="GCallback">GCallback</link> to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>data to pass to <parameter>c_handler</parameter> calls.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>the handler id


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect-object"/>g_signal_connect_object ()</title>
<programlisting><link linkend="gulong">gulong</link>      g_signal_connect_object         (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GCallback">GCallback</link> c_handler,
                                             <link linkend="gpointer">gpointer</link> gobject,
                                             <link linkend="GConnectFlags">GConnectFlags</link> connect_flags);</programlisting>
<para>
This is similar to <link linkend="g-signal-connect-data">g_signal_connect_data</link>(), but uses a closure which
ensures that the object stays alive during the call to <parameter>c_handler</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_handler</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="GCallback">GCallback</link> to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>gobject</parameter>&nbsp;:</term>
<listitem><simpara> the object to pass as data to <parameter>c_handler</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>connect_flags</parameter>&nbsp;:</term>
<listitem><simpara> a combination of <link linkend="GConnnectFlags">GConnnectFlags</link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the handler id.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GConnectFlags"/>enum GConnectFlags</title>
<programlisting>typedef enum
{
  G_CONNECT_AFTER	= 1 &lt;&lt; 0,
  G_CONNECT_SWAPPED	= 1 &lt;&lt; 1
} GConnectFlags;
</programlisting>
<para>
The connection flags are used to specify the behaviour of a signal's 
connection.
</para><variablelist role="enum">
<varlistentry>
<term><literal>G_CONNECT_AFTER</literal></term>
<listitem><simpara>whether the handler should be called before or after the 
                  default handler of the signal.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><literal>G_CONNECT_SWAPPED</literal></term>
<listitem><simpara>whether the instance and data should be swapped when
                  calling the handler.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect-data"/>g_signal_connect_data ()</title>
<programlisting><link linkend="gulong">gulong</link>      g_signal_connect_data           (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GCallback">GCallback</link> c_handler,
                                             <link linkend="gpointer">gpointer</link> data,
                                             <link linkend="GClosureNotify">GClosureNotify</link> destroy_data,
                                             <link linkend="GConnectFlags">GConnectFlags</link> connect_flags);</programlisting>
<para>
Connects a <link linkend="GCallback">GCallback</link> function to a signal for a particular object.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>c_handler</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="GCallback">GCallback</link> to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara> data to pass to <parameter>c_handler</parameter> calls. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy_data</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GDestroyNotify">GDestroyNotify</link> for <parameter>data</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>connect_flags</parameter>&nbsp;:</term>
<listitem><simpara> a combination of <link linkend="GConnectFlags">GConnectFlags</link>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the handler id 
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect-closure"/>g_signal_connect_closure ()</title>
<programlisting><link linkend="gulong">gulong</link>      g_signal_connect_closure        (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gboolean">gboolean</link> after);</programlisting>
<para>
Connects a closure to a signal for a particular object.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>closure</parameter>&nbsp;:</term>
<listitem><simpara> the closure to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>after</parameter>&nbsp;:</term>
<listitem><simpara> whether the handler should be called before or after the 
        default handler of the signal.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the handler id 
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-connect-closure-by-id"/>g_signal_connect_closure_by_id ()</title>
<programlisting><link linkend="gulong">gulong</link>      g_signal_connect_closure_by_id  (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gboolean">gboolean</link> after);</programlisting>
<para>
Connects a closure to a signal for a particular object.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance to connect to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the id of the signal.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>closure</parameter>&nbsp;:</term>
<listitem><simpara> the closure to connect.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>after</parameter>&nbsp;:</term>
<listitem><simpara> whether the handler should be called before or after the 
        default handler of the signal.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the handler id 
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handler-block"/>g_signal_handler_block ()</title>
<programlisting>void        g_signal_handler_block          (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);</programlisting>
<para>
Blocks a handler of an instance so it will not be called during 
any signal emissions unless it is unblocked again. Thus "blocking" 
a signal handler means to temporarily deactive it, a signal handler 
has to be unblocked exactly the same amount of times it has been 
blocked before to become active again.
</para>
<para>
The <parameter>handler_id</parameter> has to be a valid signal handler id, connected to a 
signal of <parameter>instance</parameter>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance to block the signal handler of.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler_id</parameter>&nbsp;:</term>
<listitem><simpara> Handler id of the handler to be blocked.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handler-unblock"/>g_signal_handler_unblock ()</title>
<programlisting>void        g_signal_handler_unblock        (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);</programlisting>
<para>
Undoes the effect of a previous <link linkend="g-signal-handler-block">g_signal_handler_block</link>() call. 
A blocked handler is skipped during signal emissions and will not be 
invoked, unblocking it (for exactly the amount of times it has been 
blocked before) reverts its "blocked" state, so the handler will be 
recognized by the signal system and is called upon future or currently
ongoing signal emissions (since the order in which handlers are
called during signal emissions is deterministic, whether the
unblocked handler in question is called as part of a currently
ongoing emission depends on how far that emission has proceeded
yet).
</para>
<para>
The <parameter>handler_id</parameter> has to be a valid id of a signal handler that is 
connected to a signal of <parameter>instance</parameter> and is currently blocked.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance to unblock the signal handler of.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler_id</parameter>&nbsp;:</term>
<listitem><simpara> Handler id of the handler to be unblocked.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handler-disconnect"/>g_signal_handler_disconnect ()</title>
<programlisting>void        g_signal_handler_disconnect     (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);</programlisting>
<para>
Disconnects a handler from an instance so it will not be called during 
any future or currently ongoing emissions of the signal it has been 
connected to. The <parameter>handler_id</parameter> becomes invalid and may be reused.
</para>
<para>
The <parameter>handler_id</parameter> has to be a valid signal handler id, connected to a 
signal of <parameter>instance</parameter>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance to remove the signal handler from. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler_id</parameter>&nbsp;:</term>
<listitem><simpara> Handler id of the handler to be disconnected.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handler-find"/>g_signal_handler_find ()</title>
<programlisting><link linkend="gulong">gulong</link>      g_signal_handler_find           (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
Finds the first signal handler that matches certain selection criteria.
The criteria mask is passed as an OR-ed combination of <link linkend="GSignalMatchType">GSignalMatchType</link>
flags, and the criteria values are passed as arguments.
The match <parameter>mask</parameter> has to be non-0 for successful matches.
If no handler was found, 0 is returned.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance owning the signal handler to be found.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mask</parameter>&nbsp;:</term>
<listitem><simpara> Mask indicating which of <parameter>signal_id</parameter>, <parameter>detail</parameter>, <parameter>closure</parameter>, <parameter>func</parameter> 
       and/or <parameter>data</parameter> the handler has to match.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> Signal the handler has to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> Signal detail the handler has to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>closure</parameter>&nbsp;:</term>
<listitem><simpara> The closure the handler will invoke.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> The C closure callback of the handler (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara> The closure data of the handler's closure.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> A valid non-0 signal handler id for a successful match.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handlers-block-matched"/>g_signal_handlers_block_matched ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_handlers_block_matched (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
Blocks all handlers on an instance that match a certain selection criteria.
The criteria mask is passed as an OR-ed combination of <link linkend="GSignalMatchType">GSignalMatchType</link> 
flags, and the criteria values are passed as arguments.
Passing at least one of the <literal>G_SIGNAL_MATCH_CLOSURE</literal>, <literal>G_SIGNAL_MATCH_FUNC</literal>
or <literal>G_SIGNAL_MATCH_DATA</literal> match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of blocked handlers
otherwise.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance to block handlers from. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mask</parameter>&nbsp;:</term>
<listitem><simpara> Mask indicating which of <parameter>signal_id</parameter>, <parameter>detail</parameter>, <parameter>closure</parameter>, <parameter>func</parameter> 
       and/or <parameter>data</parameter> the handlers have to match.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> Signal the handlers have to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> Signal detail the handlers have to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>closure</parameter>&nbsp;:</term>
<listitem><simpara> The closure the handlers will invoke.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> The C closure callback of the handlers (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara> The closure data of the handlers' closures.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The amount of handlers that got blocked.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handlers-unblock-matched"/>g_signal_handlers_unblock_matched ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_handlers_unblock_matched
                                            (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
Unblocks all handlers on an instance that match a certain selection
criteria. The criteria mask is passed as an OR-ed combination of
<link linkend="GSignalMatchType">GSignalMatchType</link> flags, and the criteria values are passed as arguments.
Passing at least one of the <literal>G_SIGNAL_MATCH_CLOSURE</literal>, <literal>G_SIGNAL_MATCH_FUNC</literal>
or <literal>G_SIGNAL_MATCH_DATA</literal> match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of unblocked handlers
otherwise. The match criteria should not apply to any handlers that are
not currently blocked.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance to unblock handlers from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mask</parameter>&nbsp;:</term>
<listitem><simpara> Mask indicating which of <parameter>signal_id</parameter>, <parameter>detail</parameter>, <parameter>closure</parameter>, <parameter>func</parameter> 
       and/or <parameter>data</parameter> the handlers have to match.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> Signal the handlers have to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> Signal detail the handlers have to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>closure</parameter>&nbsp;:</term>
<listitem><simpara> The closure the handlers will invoke.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> The C closure callback of the handlers (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara> The closure data of the handlers' closures.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The amount of handlers that got unblocked.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handlers-disconnect-matched"/>g_signal_handlers_disconnect_matched ()</title>
<programlisting><link linkend="guint">guint</link>       g_signal_handlers_disconnect_matched
                                            (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="GSignalMatchType">GSignalMatchType</link> mask,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GClosure">GClosure</link> *closure,
                                             <link linkend="gpointer">gpointer</link> func,
                                             <link linkend="gpointer">gpointer</link> data);</programlisting>
<para>
Disconnects all handlers on an instance that match a certain selection 
criteria. The criteria mask is passed as an OR-ed combination of
<link linkend="GSignalMatchType">GSignalMatchType</link> flags, and the criteria values are passed as arguments.
Passing at least one of the <literal>G_SIGNAL_MATCH_CLOSURE</literal>, <literal>G_SIGNAL_MATCH_FUNC</literal>
or <literal>G_SIGNAL_MATCH_DATA</literal> match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of disconnected 
handlers otherwise.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance to remove handlers from. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mask</parameter>&nbsp;:</term>
<listitem><simpara> Mask indicating which of <parameter>signal_id</parameter>, <parameter>detail</parameter>, <parameter>closure</parameter>, <parameter>func</parameter> 
       and/or <parameter>data</parameter> the handlers have to match.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> Signal the handlers have to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> Signal detail the handlers have to be connected to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>closure</parameter>&nbsp;:</term>
<listitem><simpara> The closure the handlers will invoke.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> The C closure callback of the handlers (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara> The closure data of the handlers' closures.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The amount of handlers that got disconnected.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handler-is-connected"/>g_signal_handler_is_connected ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    g_signal_handler_is_connected   (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="gulong">gulong</link> handler_id);</programlisting>
<para>
Returns whether <parameter>handler_id</parameter> is the id of a handler connected to <parameter>instance</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> The instance where a signal handler is sought.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler_id</parameter>&nbsp;:</term>
<listitem><simpara> the handler id.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> whether <parameter>handler_id</parameter> identifies a handler connected to 
              <parameter>instance</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handlers-block-by-func"/>g_signal_handlers_block_by_func()</title>
<programlisting>#define     g_signal_handlers_block_by_func(instance, func, data)</programlisting>
<para>
Blocks all handlers on an instance that match <parameter>func</parameter> and <parameter>data</parameter>.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>The instance to block handlers from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara>The C closure callback of the handlers (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>The closure data of the handlers' closures.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>The number of handlers that got blocked.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handlers-unblock-by-func"/>g_signal_handlers_unblock_by_func()</title>
<programlisting>#define     g_signal_handlers_unblock_by_func(instance, func, data)</programlisting>
<para>
Unblocks all handlers on an instance that match <parameter>func</parameter> and <parameter>data</parameter>.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>The instance to unblock handlers from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara>The C closure callback of the handlers (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>The closure data of the handlers' closures.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>The number of handlers that got unblocked.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-handlers-disconnect-by-func"/>g_signal_handlers_disconnect_by_func()</title>
<programlisting>#define     g_signal_handlers_disconnect_by_func(instance, func, data)</programlisting>
<para>
Disconnects all handlers on an instance that match <parameter>func</parameter> and <parameter>data</parameter>.
</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara>The instance to remove handlers from.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara>The C closure callback of the handlers (useless for non-C closures).
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data</parameter>&nbsp;:</term>
<listitem><simpara>The closure data of the handlers' closures.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>The number of handlers that got disconnected.


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-has-handler-pending"/>g_signal_has_handler_pending ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    g_signal_has_handler_pending    (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="gboolean">gboolean</link> may_be_blocked);</programlisting>
<para>
Returns whether there are any handlers connected to <parameter>instance</parameter> for the
given signal id and detail.
</para>
<para>
One example of when you might use this is when the arguments to the 
signal are difficult to compute. A class implementor may opt to not emit 
the signal if no one is attached anyway, thus saving the cost of building
the arguments.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the object whose signal handlers are sought.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal id.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>may_be_blocked</parameter>&nbsp;:</term>
<listitem><simpara> whether blocked handlers should count as match.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> <literal>TRUE</literal> if a handler is connected to the signal, 
              <literal>FALSE</literal> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-stop-emission"/>g_signal_stop_emission ()</title>
<programlisting>void        g_signal_stop_emission          (<link linkend="gpointer">gpointer</link> instance,
                                             <link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail);</programlisting>
<para>
Stops a signal's current emission.
</para>
<para>
This will prevent the default method from running, if the signal was
<literal>G_SIGNAL_RUN_LAST</literal> and you connected normally (i.e. without the "after" 
flag).
</para>
<para>
Prints a warning if used on a signal which isn't being emitted.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the object whose signal handlers you wish to stop.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal identifier, as returned by <link linkend="g-signal-lookup">g_signal_lookup</link>().
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail which the signal was emitted with.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-stop-emission-by-name"/>g_signal_stop_emission_by_name ()</title>
<programlisting>void        g_signal_stop_emission_by_name  (<link linkend="gpointer">gpointer</link> instance,
                                             const <link linkend="gchar">gchar</link> *detailed_signal);</programlisting>
<para>
Stops a signal's current emission.
</para>
<para>
This is just like <link linkend="g-signal-stop-emission">g_signal_stop_emission</link>() except it will look up the 
signal id for you.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the object whose signal handlers you wish to stop.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-override-class-closure"/>g_signal_override_class_closure ()</title>
<programlisting>void        g_signal_override_class_closure (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="GType">GType</link> instance_type,
                                             <link linkend="GClosure">GClosure</link> *class_closure);</programlisting>
<para>
Overrides the class closure (i.e. the default handler) for the given signal
for emissions on instances of <parameter>instance_type</parameter>. <parameter>instance_type</parameter> must be derived
from the type to which the signal belongs.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal id 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>instance_type</parameter>&nbsp;:</term>
<listitem><simpara> the instance type on which to override the class closure 
                for the signal. 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>class_closure</parameter>&nbsp;:</term>
<listitem><simpara> the closure. 
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-chain-from-overridden"/>g_signal_chain_from_overridden ()</title>
<programlisting>void        g_signal_chain_from_overridden  (const <link linkend="GValue">GValue</link> *instance_and_params,
                                             <link linkend="GValue">GValue</link> *return_value);</programlisting>
<para>
Calls the original class closure of a signal. This function should only
be called from an overridden class closure; see 
<link linkend="g-signal-override-class-closure">g_signal_override_class_closure</link>().</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance_and_params</parameter>&nbsp;:</term>
<listitem><simpara>  the argument list of the signal emission. The first 
     element in the array is a <link linkend="GValue">GValue</link> for the instance the signal is 
     being emitted on. The rest are any arguments to be passed to the 
     signal.  
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>return_value</parameter>&nbsp;:</term>
<listitem><simpara> Location for the return value. 
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-add-emission-hook"/>g_signal_add_emission_hook ()</title>
<programlisting><link linkend="gulong">gulong</link>      g_signal_add_emission_hook      (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="GQuark">GQuark</link> detail,
                                             <link linkend="GSignalEmissionHook">GSignalEmissionHook</link> hook_func,
                                             <link linkend="gpointer">gpointer</link> hook_data,
                                             <link linkend="GDestroyNotify">GDestroyNotify</link> data_destroy);</programlisting>
<para>
Adds an emission hook for a signal, which will get called for any emission
of that signal, independent of the instance.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the signal identifier, as returned by <link linkend="g-signal-lookup">g_signal_lookup</link>().
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail</parameter>&nbsp;:</term>
<listitem><simpara> the detail on which to call the hook.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>hook_func</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GSignalEmissionHook">GSignalEmissionHook</link> function.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>hook_data</parameter>&nbsp;:</term>
<listitem><simpara> user data for <parameter>hook_func</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>data_destroy</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GDestroyNotify">GDestroyNotify</link> for <parameter>hook_data</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the hook id, for later use with 
              <link linkend="g-signal-remove-emission-hook">g_signal_remove_emission_hook</link>().
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-remove-emission-hook"/>g_signal_remove_emission_hook ()</title>
<programlisting>void        g_signal_remove_emission_hook   (<link linkend="guint">guint</link> signal_id,
                                             <link linkend="gulong">gulong</link> hook_id);</programlisting>
<para>
Deletes an emission hook.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>signal_id</parameter>&nbsp;:</term>
<listitem><simpara> the id of the signal
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>hook_id</parameter>&nbsp;:</term>
<listitem><simpara> the id of the emission hook, as returned by 
          <link linkend="g-signal-add-emission-hook">g_signal_add_emission_hook</link>()
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-parse-name"/>g_signal_parse_name ()</title>
<programlisting><link linkend="gboolean">gboolean</link>    g_signal_parse_name             (const <link linkend="gchar">gchar</link> *detailed_signal,
                                             <link linkend="GType">GType</link> itype,
                                             <link linkend="guint">guint</link> *signal_id_p,
                                             <link linkend="GQuark">GQuark</link> *detail_p,
                                             <link linkend="gboolean">gboolean</link> force_detail_quark);</programlisting>
<para>
Internal function to parse a signal name into its <parameter>signal_id</parameter>
and <parameter>detail</parameter> quark.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>detailed_signal</parameter>&nbsp;:</term>
<listitem><simpara> a string of the form "signal-name::detail".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara> The interface/instance type that introduced "signal-name".
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal_id_p</parameter>&nbsp;:</term>
<listitem><simpara> Location to store the signal id.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>detail_p</parameter>&nbsp;:</term>
<listitem><simpara> Location to store the detail quark.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>force_detail_quark</parameter>&nbsp;:</term>
<listitem><simpara> <literal>TRUE</literal> forces creation of a <link linkend="GQuark">GQuark</link> for the detail.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Whether the signal name could successfully be parsed and
              <parameter>signal_id_p</parameter> and <parameter>detail_p</parameter> contain valid return values.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-get-invocation-hint"/>g_signal_get_invocation_hint ()</title>
<programlisting><link linkend="GSignalInvocationHint">GSignalInvocationHint</link>* g_signal_get_invocation_hint
                                            (<link linkend="gpointer">gpointer</link> instance);</programlisting>
<para>
Returns the invocation hint of the innermost signal emission of instance.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>instance</parameter>&nbsp;:</term>
<listitem><simpara> the instance to query
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the invocation hint of the innermost signal emission.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-signal-type-cclosure-new"/>g_signal_type_cclosure_new ()</title>
<programlisting><link linkend="GClosure">GClosure</link>*   g_signal_type_cclosure_new      (<link linkend="GType">GType</link> itype,
                                             <link linkend="guint">guint</link> struct_offset);</programlisting>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>itype</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>struct_offset</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara>


</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
