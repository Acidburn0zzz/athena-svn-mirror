<!-- ifhp-HOWTO SGML format -->
<!doctype linuxdoc system>
<article>
<!-- must be matched by / article at end -->
<title> IFHP-HOWTO
<author> Patrick Powell
<tt><htmlurl url="mailto:papowell@astart.com" name="papowell@astart.com"></tt>
<date> 21 Dec 1998 (For ifhp-3.1.2)
<toc>
<sect>Filter Operation
<p>
The
Tifhp
filter operates by first reading a configuration file
to determine the type of printer it is working with,
and then proceeds to carry out operations requested by the values of
option variables passed on the command line or found in the configuration
files.
In normal operation,
input is read from 
<tt/STDIN/
(file descriptor 0),
massaged in the appropriate manner,
and then written out to
<tt/STDOUT/ (file descriptor 1).
Status reports are written to
a status file, or optionally to
<tt/STDERR/ (file descriptor 2),
together with any error messages or diagnostics.
<p>
In addition to normal operation
the filter can run in the
<bf/OF/ mode and act as a printer initializer and job terminator.
This is discussed in detail in the LPRng documentation.
When in the OF mode,
The first nonblank input line will be treated as
a request to generate a banner.
The string "\031\001" will cause the filter to suspend operations
using a SIGSUSP signal.
At this point,
job files will be sent to the output device by the spooler,
and the filter will then be restarted with a SIGCONT signal.
<p>
These steps are best explained algorithmically.
The following is a <em/pseudo-code/ description of the steps
performed during the printing activity.
The sections marked with <tt/###/ are discussed later in this document
in detail.
<p>
<ref id="setup" name="Initialization and Setup" >
<verb>
###+++ Initialization and Setup
foreach option in -Toptions, -Zoptions do
    if( option = "debug=level"  and Debuglevel not set ){
        set Debuglevel = level;
    }
    if( option = "trace_on_stderr" ){
        output error and trace on STDERR
    }
    if( option = "config=pathlist" and from -Toption ){
        set configuration pathlist = pathlist;
    }
    if( option = "model=name" and model not set ){
        set model = name;
    }
}
</verb>
<ref id="modelselect" name="Model Information Selection" >
<verb>
// get model information from $PRINTCAP environment variable
if( $PRINTCAP environment variable defined and model not set ){
	split printcap information into printcap fields
	if( :model=name is present in printcap ){
		set model=name
	}
}
</verb>
<ref id="optioninit" name="Option Initialization" >
<verb>
// extract configuration information
foreach path in configuration pathlist {
    open path;
    for each line in file information {
		if( line is selected to be in configuration ){
			process input line, adding it to configuration
			if( line is 'debug=','model='
			   and the corresponding value not set ){
			   set the value;
			}
		}
    }
}

// get values of options with predefined meanings
// these include status, forcestatus, etc
foreach option in predefined list {
	if( option=value is in selected configuration information ){
		set option=value;
	}
}

###---
</verb>
<ref id="syncpage" name="Synchronization and Pagecount" >
<verb>
###+++ Synchronization and Pagecount
if( status returned by printer ){
    // sync has the form sync@ (none), sync=ps, sync=pjl, ...
    if( sync=language has value ) do{
        if sync = pjl and PJL ECHO available then
           send PJL ECHO command to printer
        else if sync = ps then
           send PS program to printer
    } while( no response );

    // pagecount has the form pagecount@ (none), pagecount=ps, pagecount=pjl, ...
    if( pagecount=language has value ) do {
        if pagecount = pjl and PJL ECHO available then
           send PJL INFO PAGECOUNT command to printer
        else if pagecount = ps then
           send PS program to printer
    } while( no pagecount response );
}
###---
</verb>
<ref id="pjlinit" name="PJL Initialization" >
<verb>
### PJL Initialization
if( PJL enabled ){
    language = "pjl_"
    foreach option in pjl_init=&lsqb;...&rsqb; {
       expand the option using the language value
       #+++ PJL OPTION ACTIONS +++
       if( option in pjl_vars_set=[ ... ]
         and option not in pjl_vars_except
         expand "@PJL SET OPTION=\%{option}"
         output = expanded string value
       } else {
         if( option value is a string ){
           output = expanded string value;
         }
       }
       // output has the form @PJL COMMAND ....
       if( COMMAND is in pjl_only=[ ... ]
           and not in pjl_except=[ ... ] ){
           send output to printer
       }
       #--- end PJL OPTION ACTIONS
    }
    if( !OF_mode ){
         foreach option in -Toption=value {
            if( option in pjl_user_vars ){
                #+++ USER PJL OPTIONS
                // join 'pjl_' and the option name
                expand 'pjl_' . option
                // perform PJL actions as above
                    #+++ PJL OPTION ACTIONS +++
                    ....
                    #-- PJL OPTION ACTIONS +++
                #--- USER PJL OPTIONS
            }
         }
         foreach option in -Zoption=value {
            if( option in pjl_user_vars ){
                // perform USER PJL actions as above
                #+++ USER PJL OPTIONS
                #--- USER PJL OPTIONS
            }
         }
    }
}
###--- PJL INITIALIZATION
</verb>
<ref id="textfile" name="Text File Conversion" >
<verb>
// language is set to the type of job language
// - PS, PCL, TEXT, RAW, UNKNOWN
//  the first part of the job file is read and the filter takes
//  a (wimpy) guess at the job file based only on the first couple
//  of characters;  language is  be PJL, PS, or TEXT, or RAW
//  This is the same algorithm as the UNIX FILE utility

language = UNKNOWN
if( command line -c (binary) option present ){
    language = RAW;
} else if( -Zlanguage=xxx option present ){
    language=xxx
} else if( file is PS file ){
    language=PS
} else if( file is PCL file ){
    language=PS
} else if( file_util_path=/pathname ){
    use UNIX file utility to get file type
}

if( language = UNKNOWN and
    default_language option has value ){
    language = value of default_language;
}

if( language = TEXT ){
    if( text_converter=/path option has value ){
        run text converter on input
    } else if( printer does not support TEXT output ){
        exit with error;
    }
    language = value of text_converter_output option
}

if( language = UNKNOWN ){
    exit with error;
}
</verb>
<ref id="languageinit" name="Language Specific Initialization">
<verb>
// LANGUAGE SPECIFIC INITIALIZATIONS
if( language = PCL ){
    foreach option in pcl_init {
        ###+++ expansion 
        do expansion similar to PJL OPTION actions
            using "pcl_" prefix for option lookup;
        ###---
    }
    if( not in OF_MODE ){
        foreach option in -Toption do {
            if( option in pcl_user_vars=[ ... ] ){
            ###+++ expansion as above
            ###---
        }
        foreach option in -Zoption do {
            if( option in pcl_user_vars=[ ... ] ){
            ###+++ expansion as above
            ###---
        }
    }
    remove whitespace and expand string results;
} else if( language = PS ){
    ###+++ language specific actions as above,
      using the ps_ prefix for lookup 
    expand string results but do not remove whitespace
}
</verb>
<ref id="filetransfer" name="File Transfer and Error Status Monitoring">
<verb>
Transfer job to printer, reading error and other information
  back from the printer if enabled

if( language = PCL ){
    send PCL End of Job
} else if( language = PS ){
    send PS End of Job
}


// job terminaton
###+++ Synchronization and Pagecount as above
###---
exit
</verb>
<label id="setup">
<sect1>Initialization and Setup
<p>
The first actions carried out by the
Tifhp
filter are to establish some operational and debugging values.
The
<tt/debug/,
<tt/trace_on_stderr/,
<tt/config/,
and
<tt/model/
have the property that once they are set, then they cannot be modified
(i.e. - sticky values).
The command line
<tt/-Zoption/
and
<tt/-Toption/
options are first scanned to see if they can set these values.
<p>
By convention,  the LPRng print spooling system will pass the
<tt/lpr -Zoption/
values on the filter command line.
It will insert spooler dependent
<tt/-Toption/
values to control the filter operation as well.
The
Tifhp
filter uses only a limited number of the
<tt/-Zoption/s
but treatest the
<tt/-Toption/s
as through they were read from a configuration file.
The
<tt/-Toption/s will override any values obtained from the
various configuration files.
<sect2>Debug and Trace_on_stderr
<p>
The value of the
<tt/debug/
option sets the debugging level.
It can be increased, but not decreased.
The
<tt/trace_on_stderr/
flag causes debugging information to be sent to STDERR (file descriptor 2)
as well as to the status file.
<sect2>Statusfile, Statusfile_max, Statusfile_min
<p>
The status file pathname is set by the command line
<tt>-s /pathname</tt>
or the
<tt>statusfile=/pathname</tt>
configurtion file entry.
If the
<tt>/pathname</tt>
file does not exist then it will not be created.
If the statusfile is larger than the
<tt/statusfile_max=max/
K bytes option value (default 8K),
then it will be truncated to
<tt/statusfile_min=min/
K bytes.
<sect2>Summmaryfile
<p>
For historical and vintage software compatibility,
the
<tt>summaryfile=/pathname</tt>
or
<tt>summaryfile=host%port</tt>
option will cause either a file to be open or a UDP network connection
established to the host  and port combination.
Debugging or trace information will be written to this file or network
connection as well, but the file will be truncated each time,
holding only the last line of trace information.
<label id="modelselect">
<sect1>Model Information Selection
<p>
The value established by the first
command line
<tt/-Tmodel=name/,
$PRINTCAP environment variable
<tt/:model=name/ entry,
or configuration file
<tt/model=name/
line establishes the model name that will be used in extracting
configuration information.
Once the model name is set,  it cannot be changed.
<p>
The purpose of this elaborate set of methods is to provide the
maximum amount of configuration flexibilty
together with consistency of operation.
<p>
The recommended methods of model selection is to use the
command line
<tt/-Tmodel=name/
and
<tt/$PRINTCAP/
environment variable
<tt/:model=name/
method.
The LPRng spooling system will extract printcap information for the
printer,  and passes in the
<tt/$PRINTCAP/
environment variable.
This information has the form below,
where the fields  are separated by new lines.
<verb>
PRINTCAP=pr
 :value
 :value

Simple Example:
  PRINTCAP=model=name
</verb>
<p>
Another method is to put the model information in a
<tt>./ifhp.conf</tt>
file in the spool directory of the print queue.
The
<tt>config=/pathname,/pathname,...</tt>
option specifies the list of configuration files to read,
and the default value is:
<verb>
config=./ifhp.conf,/etc/ifhp.conf,./ifhp.conf
</verb>
<p>
If the model information is put in the 
<tt>./ifhp.conf</tt>
configuration file,
the first reading will set the model name,
and the name is used to select the model information from the
<tt>/etc/ifhp.conf</tt>
file.
When the 
<tt>./ifhp.conf</tt>
is reread,  the values in it can be used to override values from the
<tt>/etc/ifhp.conf</tt>
file.
For example:
<verb>
./ifhp.conf:
  model=hp
  lines=66

/etc/ifhp.conf:
[ hp* ]
 lines=60
[ apple* ]
 lines=20
</verb>
<p>
When the
<tt>./ifhp.conf</tt>
is first read,
it will establish
<tt/model=hp/
(sticky) and 
<tt/lines=66/.
When the
<tt>/etc/ifhp.conf</tt> file is read,
the model name matches the
<tt/hp*/ selector
and the
<tt/lines=60/
is selected and overrides the
<tt/lines=66/
value.
Finally,
when the
<tt>./ifhp.conf</tt>
file is reread,
<tt/lines=66/
will establish the final value.
<label id="optioninit">
<sect1>Option Initialization
<p>
The
<tt/-Toption=value/
and model configuration infomation is scanned
to set values of options with predefined operations.
The names and effects of these options are discussed
in the appropriate sections.
<p>
There are some options whose related actions do not fall into
the simple model of string expansion.
These usually require generating commands dynamically,
or sending files containing font or setup information to the printer.
The following is a list of these options.
<sect2>status and forcestatus FLAGS
<p>
These options have the side effect of enabling the reception of status
and error information from the printer.
<sect2>pjl, pcl, ps and text FLAGS
<p>
These flags set the lanaguages that are recognized or processed by
the filter.
<sect2>crlf_only FLAG
This has the peculiar sending the job file to the
output with CR (<tt/\r/) translated to CR-LF
(<tt/\r\n/) sequences.
If PJL is enabled,
then PJL initialization will be carried out as well.
The following options will turn the
Tifhp
filter into a simple CRLF translation filter.
Note that this translation should have no effct on Text,
PostScript, or PCL files.
<verb>
pjl@
crlf_only
</verb>
<sect2>pjl_job FLAG
<p>
If PJL is enabled and this flag is SET,
a PJL JOB and PJL EOJ command will be generated
and sent to the printer.
The JOB command has the form:
<verb>
&commat;PJL JOB NAME = "..." &lsqb; START = nnn &rsqb; &lsqb; END = nnn &rsqb;
</verb>
The START and END values can be specified by -Zstart=nnn and -Zend=nnn
options.  The EOJ command has the form and must match the JOB command.
<verb>
&commat;PJL EOJ NAME = "..." &lsqb; START = nnn &rsqb; &lsqb; END = nnn &rsqb;
</verb>
<sect2> pjl_enter FLAG
<p>
If PJL is enabled and this flag is SET,
a PJL ENTER LANGUAGE = xx command will be generated
when PCL or PS files are sent to the printer.
<verb>
@PJL ENTER LANGUAGE = PCL
@PJL ENTER LANGUAGE = POSTSCRIPT
</verb>
<sect2> pjl_console FLAG
<p>
When this flag is set,
PJL is available,
and the PJL
<tt/RDYMSG/
command is supported,
then a short message will be put on the console.
<sect2> tbcp FLAG
<p>This flag can be specified as a user option as well as a
configuration file option.
If the file type is PostScript and this flag is set,
then the file is transferred using the Transparent Binary Communication
Protocol.
(See the Adobe PostScript Language Reference Manual for details on
the protocol.)
<p>
At the start of the PostScript job,
the sequence <tt/\001/ <tt/M/ is sent.
Afterwards,  all control characters in the set
<tt>
0x01, 0x03, 0x04, 0x05,
0x11, 0x13, 0x14, 0x1C,
</tt>
are replaced by the two character sequence <tt/\001/
<tt/X+'@'/ or
<tt/X+'\100'/ or
is sent.
For example:
<verb>
C\001\003   ->  \001\115\103\001\101\001\103 or \001MC\001A\001C
</verb>
<p>
<label id="syncpage">
<sect1>Synchronization and Pagecounts
<p>
Many printers are able to provide status information back to the
filter.
It is assumed that in these circumstances file descriptor 1
(FD1)
is
<em/bidirectional/
and status information can be read from it.
When the
<tt/status/
or
<tt/forcestatus/
option is TRUE,
then the filter assumes that it can read FD1.
In order to simplify configuration,
the
Tifhp
filter will test FD1, and if it is not
a serial port or a network socket, will set
<tt/status@/
or OFF.
<p>
However, there are some devices such as bidirectional printer ports
that will report status.
By setting
<tt/forcestatus/
ON,
the filter can be forced to check for status.
This can have fatal or unexpected effects if status is not returned
correctly.
<p>
Synchronization is usually done in order to ensure that a previously
spooled job or printer action has completed correctly,
and the printer is ready to accept a new job.
It is usally carried out by sending a request to the printer to
echo a string back to the filter.
Clearly,
if the printer cannot provide status or echo values back,
then synchronization is impossible.
<p>
The value of the
<tt/sync/ option determines if a PJL ECHO command or simple PostScript 
program is used.
The PostScript program has the form:
<verb>
\004%!PS-Adobe-2.0
( %%[ echo: <it/TODSTR/ ]%% ) print () = flush
\004
</verb>
<p>
where <it/TODSTR/ is replaced with the current Time of Day.
<p>
To control obtaining synchronization,
the
and
<tt/sync_timeout=nnn/
options are used.
The PJL or PS command is repeated at
<tt/sync_interval=nnn/
second intervals; if nnn is 0, then it is sent only once.
If synchronization is not obtained within
<tt/sync_timeout=nnn/
seconds, then the filter exits with an error status.
A 0 value or
<tt/sync_timeout@/
disables timeouts.
<p>
Pagecounts are used to do accounting and report the number of pages
used for a job.
Most printer have a hardware based pagecounter mechanism whose value
can be read by the appropriate PJL command or PostScript program.
For example, if the PJL INFO command
<verb>
@PJL INFO PAGECOUNT
</verb>
is supported by a printer,
the printer will return a status message containing the current pagecounter
value.
Printers that support PostScript may also be able to access the pagecounter
value using a PostScript program.
The exact details of the PostScript program vary from vendor to vendor and
the
<tt/pagecount_ps_code=.../
option specifies the PostScript program to use.
For example:
<verb>
pagecount_ps_code=
  /p {print} def ( %%&lsqb; pagecount: ) p
  statusdict begin pagecount end 20 string cvs p
  ( &rsqb;%% ) p () = flush
</verb>
<p>
Pagecounting is supported by the
<tt/pagecount=/<it/language/,
<tt/pagecount_interval=nnn/,
and
<tt/pagecount_timeout=nnn/
options.
The
<tt/pagecount=/<it/language/
option enables pagecounting, and sets the language to be used.
Currently
<tt/ps/ (PostScript)
and
<tt/pjl/ (PJL)
are supported.
The pagecount request is repeated every
<tt/pagecount_interval=nnn/
second intervals; if nnn is 0, then it is sent only once.
If no pagecount value is obtained within
<tt/pagecount_timeout=nnn/
seconds, then the filter exits with an error.
A 0 value or
<tt/sync_timeout@/
disables timeouts.
<p>
Some printers do not correctly report end of job and must be polled
until the pagecount information stabilizes.
The PJL TEOJ (True End Of Job) PJL has been tried with limited success
on various printers to force End of Job reporting only when the
job has finished.
<tscreen>
<verb>
pjl_init=[ ... teoj ... ]
pjl_teoj=&commat;PJL TEOJ=ON
</verb>
</tscreen>
<label id="pjlinit">
<sect1>PJL Initialization
<p>
If a printer supports PJL,
the many printer operations can be initiated and controlled using
PJL commands.
Unfortunately,
not all printers support the same set of commands.
In addition,
not all printers support the same set of operations or options.
A PJL command has the form:
<verb>
@PJL COMMAND OPTION OPTION ...
</verb>
A PJL variable is set using:
<verb>
@PJL SET <it/var/ = <it/value/ ...
</verb>
The
<tt/pjl_only=[ ... ]/,
<tt/pjl_except=[ ... ]/,
<tt/pjl_vars_set=[ ... ]/,
and
<tt/pjl_vars_except=[ ... ]/
options are used to control which PJL commands and which PJL variables
can be set.
The 
<tt/pjl_only/
variable lists the commands supported by the printer,
and the
<tt/pjl_except/
lists commands <em/not/
supported by the printer.
Before sending a PJL command,
the
Tifhp
filter checks to make sure that the command name is in
<tt/pjl_only/
and not in
<tt/pjl_except/.
If the tests fail, then tne command is not sent.
<p>
Similarly,
when sending a command to set a PJL variable,
the
<tt/pjl_vars_set/
and
<tt/pjl_vars_except/
lists are checked to determine if the variable name is in
<tt/pjl_vars_set/
and not in
<tt/pjl_except/
list.
If the tests fail, then tne command is not sent.
<p>
If PJL is enabled,
then the following actions are taken.
<enum>
<item> PJL Universal Exit Lanaguage (UEL) <tt/\033%-12345X/ is sent to the printer.
<p>
This is required to ensure that the following PJL commands are
accepted.
<item> PJL JOB command is sent at the start of job.
The JOB command can be used to select pages or impressions to be printed.
If the
<tt/-Zpagestart=nnn/
or
<tt/-Zpagestart=mmm/
option is present, then the PJL JOB command has the form:
<verb>
@PJL JOB START=nnn END=nnn
</verb>

<item> The
<tt/pjl_init=[ ... ]/
value option is expanded using the PJL
(<tt/"pjl_"/) language context as described above.

<item> The
<tt/-Toption=value/s
and
<tt/-Zoption=value/s
are scanned for matching option names in the 
<tt/pjl_user_opts=[ ... ]/ 
list.
If they are found,
then the options are recursively evaluated in the PJL language context.
The expansion alorithm will cause the option value to be used to set PJL
variables.
For example:
<verb>
Configuration:
  pjl_vars_set=[ OUTBIN AUTOSELECT JAM=YES ]

Command
  ifhp -Zoutbin=upper,autoselect,jam

PJL command generated:
  @PJL SET OUTBIN=UPPER
  @PJL SET AUTOSELECT=ON
  @PJL SET JAM=YES
</verb>
</enum>
<label id="textfile">
<sect1>Text File Conversion
<p>
Many PostScript printers cannot handle text files,
and produce many hundreds of pages of garbage
output if they are sent to the printer without being translated
into PostScript.
Also,
while most PCL printers will accept text files and do a reasonable
job of printing them,
some form of initialization strings or setup may need to be done.
The following options control text file
conversion:
<descrip>
<tag><tt>file_util_path=/pathname</tt></tag>
The pathname of the UNIX file utility.
<tag><tt>text_converter=/pathname</tt></tag>
    specifies the pathname of a text to language program.
<tag><tt>text_output=language</tt></tag>
    Specifies the output language of the conversion program.
Language can be
<tt/ps/,
<tt/pcl/,
<tt/text/,
<tt/raw/,
<tt/unknown/
<tag><tt>text_tempfile=/pathname</tt></tag>
A temporary file location.
The
<tt>/pathname</tt>
value has the string
<tt>XXXXXX</tt>
appended to it and is used as input to the POSIX
<tt/mktemp()/
function.
</descrip>
<p>
The print file language is determined using the following algorithm.
<enum>
<item>
The default language is set to
<tt/unknown/
or the
<tt/default_file=language/ value if it exists.
<item>
If the command line
<tt/-c/
(binary) option is present,
or the
<tt/autodetect/ configuration option is TRUE,
then the language is set to
<tt/RAW/.
(The autodetect option is not recommended for general use).
<item>
If there is a
<tt/-Zlanguage=value/ command line option,
the language is set to
<tt/value/.
<item>
Various simple checks to determine if the file is
Postscript
(language=<tt/ps/)
or PCL
(language=<tt/pcl/)
are performed.
These are the same checks that the UNIX
<tt/file/
utility uses.
<item>
If the file type is still
<tt/unknown/
and the
<tt>file_util_path=/path</tt>
value is defined, then the
<tt/file/
utility is run and is used to determine the file type.
This will determine that the file is a
<tt/text/
file
or
<tt/unknown/.
<item>
If the file is a
<tt/text/
file and the
<tt>text_converter=/path</tt>
option has a value,
then the specified program is run,
and its output is used as the converted text file.
The 
<tt>text_converter_output=language</tt>
value is used as the output language.
</enum>
<p>
While this algorithm may appear to be overly complex, it
will handle a wide range of desired configurations.
<sect2>No Textfile Conversion Needed
<p>
If your printer can handle text files without conversion,
but require PCL intialization, then the following combination
will simply set the language to
<tt/pcl/:
<verb>
text_converter@
text_converter_output=pcl
</verb>
<sect2>Default Passthrough of Unknown File Types
<p>
Your printer may be capable of handling a wide variety of job
formats.  If you want to simply pass through files of
unknown type or language then use:
<verb>
text_converter@
text_converter_output=raw
</verb>
<label id="languageinit">
<sect1> Language Specific Initialization
<p>
After determining the output file language type,
language specific operations are then carried out by
expanding the
<it/language_/<tt/_init=[ ... ]/
options in the language context,
and then the options in the
<tt/-Toption=value/
and
<tt/-Zoption=value/
command line options.
The 
<tt/-T/
options are expanded before the
<tt/-Z/,
allowing the 
<tt/-Z/ actions to override any set by the
<tt/-T/ actions.
<p>
As mentioned elsewhere,
the reason for the language specific processing is to allow
different actions for the same command line option,
depending on the file type that is being processed.
For example,  when processing a PCL file it might be necessary to send
PCL command strings and when processing a PostScript file,
you would need to send PostScript commands.
<label id="filetransfer">
<sect1>File Transfer and Error Status Monitoring
<p>
If the printer can return status, i.e., the
<tt/status/
or 
<tt/forcestatus/
flag is set,
then the
Tifhp
filter will read status information back from the printer.
<p>
If the
<tt>logall</tt>
flag is SET,
then all error messages will be written to the status or log file.
<p>
If the printer is returning PJL status information,
then this has a specific format:
<verb>
@PJL UINFO DEVICE
CODE=nnnn
DISLAY="value"
...

@PJL UINFO JOB
START
...

@PJL UINFO JOB
END
...

</verb>
<p>
The
Tifhp program will extract the
<tt/CODE/
and job start and end flags,
and log these as appropriate.
<p>
Unfortunately,
some PJL based printers are extremely verbose in their generation of status
messages.
In order to reduce the amount of logging of redundant information,
Tifhp
will only record when a device status has
<bf/changed/,
rather than when it has been reported.
<p>
The
pjl_quiet_codes=&lsqb; code code code &rsqb;
value is used to suppress reporting of selected error codes.
If the error code is in the pjl_quiet_codes list,  then the error status
will not be reported to the user unless the
<tt/log_all/
option is set.
For example:
<verb>
  pjl_quiet_codes=&lsqb; 10000 10001 10003 10023 10024 35078 &rsqb;
</verb>
<p>
Also, there may be error codes which does not have a builtin error
message available.  New messages can be added using the
<tt/pjl_error_code/
option.
Its value is a list of lines, each line consisting of an error code
followed by the corresonding error message:
<verb>
pjl_error_codes=&lsqb;
   code=msg
   code=msg
   ...
&rsqb;

Example:
  pjl_error_codes=&lsqb;
     10000=powersave mode
     10001=Ready Online
     10002=Ready Offline
     10003=Warming Up
     10004=Self Test
     10005=Reset
  &rsqb;
</verb>
<sect> Banners and OF Mode Operations
<p>
The OF mode is enabled by the command line -Fo flag or by
the file name of the executable containing the "of" string.
<p>
When operating in the OF mode,  the filter uses the value of the
banner key to determine what to do with input.  If banners are
disabled
(<tt/banner&commat;/),
then input is simply passed directly to the
output.
The banner_suppressed flag allows you to suppress banner printing
until explicitly requested by a user using the -Zbanner flag.
<descrip>
<tag><tt>banner=pcl</tt></tag>
     Uses a built-in PCL banner generator.  Pretty simple.
<tag><tt> banner=ps </tt></tag>

Using information from the command line options,  generates
PostScript line which set the values of PostScript variables.
Then the contents of the file specified by
<tt>banner_file=/path</tt>
are appended.
<tscreen>
<verb>
%!PS-Adobe-2.0
/Seq (number) def
/Job (banner) def
/Host (HOST) def
/Class (CLASS) def
/User (USER) def
/Date (DATE) def
/Name (NAME) def
/Line (LINE) def
/<bf/X/> (<it/command line -X option value/) def
</verb>
</tscreen>
<tag><tt>banner=/path</tt></tag>
Opens and copies the file directly to the printer.
<tag><tt> banner=|/path </tt></tag>
    Forks and EXECs the executable specified by
<tt>/path</tt>,
with the same arguments as those passed to the filter.
The executable output is sent to the printer.
</descrip>
Some printers do not correctly report end of job and must be polled
until the pagecount information stabilizes.  The following options
can be used to try to remedy this situation.
<p>
true_eoj=&commat;PJL TEOJ=ON
<p>
This may work on some printers,  causing end of job reporting to be
delayed until the last page is printed.
<p>
pagecount_poll=nnn
<p>
Periodically poll the printer at nnn second intervals until the
pagecount value stabilizes.
<p>
Builtin or Predefined Flags and Actions:
<p>
The following keys are used to control printer actions,
and are BUILTIN or predefined in their actions.
<p>
status - FLAG
  If status is OFF then no response will be expected from the
  printer.  The filter will set status to OFF if the output
  device (printer) is not a serial line or socket.
    status   - no status can be read from printer (write only)
    status&commat;  - status can be read from printer (read/write)
<p>
force_status - FLAG
  Forces status to be obtained from printer,  even it it appears
  that the device will not return status.  Covers a loophole where
  you can have a bidirectional pipe or parallel port device that
  looks like they should not return status.
    force_status  - force status to be read
    force_status&commat; - do force status to be read
<p>
debug - STRING
  sets the debug level - 0 to n
  As usual,  turning on debugging will produce very voluminous output.
  If debugging is turned on, trace messages are also written to the
  STDERR output unless the trace_on_stderr flag is set off
    debug=1
<p>
trace_on_stderr - FLAG
  If set, then trace and debugging information will be output to
  stderr as well as the status file.
    trace_on_stderr  - trace output on STDERR as well as to status file
    trace_on_stderr&commat; - only error messages to STDERR
<p>
statusfile - STRING
  Specifies a status file to be used for filter status and trace information.
  This value is overridden by the command line '-s file' option.
    statusfile=status
    statusfile&commat;   - no status file
    ifhp -s statusfile  - command line option
<p>
logall - FLAG
  Log all error and output from printer, with no interpretation.
    logall   - logs all to trace file
    logall&commat;  - only 'interesting' information is logged
<p>
dev    - STRING
  Open this device RW for output.  For testing and/or desperation use.
  Look in the source code for some other flags, etc, such as retries, wait
  times, etc.  This is NOT documented, on purpose.
  Examples:
	dev=astart14%9100
	dev=/tmp/d
    dev_retries=5   - number of retries
    dev_sleep=5     - sleep between retries
<p>
init=&lsqb; ... &rsqb;  - LIST
  actions to request before printer specific action
<p>
sync  - STRING BUILTIN OPERATION
  Request synchronization with printer before transferring data files
  Synchronization can be done with PJL or PS methods.  If status is OFF
  then no synchronization will be done.
    sync&commat;     - no synchronization
    sync=pjl  - use PJL ECHO facilty
    sync=ps   - send PS program to generate ECHO string
sync_interval - STRING
  If synchronization is not done within this period, then resend the
  synchronization request.
<p>
job_timeout - STRING
  If the job has not completed within this period of time, abandon
  the job.
    job_timeout&commat;  - no timeout
    job_timeout=nnn - nnn seconds
<p>
<p>
Language Control
<p>
pjl  - FLAG
  printer supports PJL.  See PJL Specific Options
  pjl   - enabled
  pjl&commat;  - disabled
pcl  - FLAG
  printer supports PCL.  See PCL Specific Options
ps   - FLAG
  printer supports PCL.  See PCL Specific Options
raw  - FLAG
  printer allows BINARY files.  Default is ON.
<p>
Banner Generation for OF Operations
<p>
  These flags control operation in the OF mode for banner
  generation.
<p>
banner - STRING
  specifies the type of banner to be produced
    banner&commat;    - no banner - does passthrough mode.
    banner=pcl - use PCL builtin code
    banner=ps  - use PS setup, then appends bannerfile
    banner     - equivalent to banner=pcl
    banner=/pathname  - opens and writes file to output
    banner=|pathname  - forks and execs filter.
<p>
banner_file - STRING
    file to send after banner PS strings sent
<p>
banner_suppressed - FLAG
    allows you to suppress banner printing until explicitly requested
    by a user using the -Zbanner flag.
<p>
Page Counting:
<p>
pagecount - STRING
  specifies which method to use to get pagecount information
    pagecount&commat;      - do not do page counting
	pagecount       - use default PJL if enabled, PS if enabled
	pagecount=ps    - use PS,  and send the ps_pagecount_code
	pagecount=pjl   - use PJL INFO PAGECOUNT command
ps_pagecount_code  - STRING
    PostScript code for obtaining pagecount information
pagecount_poll - STRING
    forces pagecount to be obtained at intervals, and is not
    reported until it is stable.
pagecount_interval - STRING
    if pagecounting is not reported within this interval, then
    resend the request.
<p>
Action Strings
<p>
init=&lsqb; ... &rsqb;      - LIST
    initialization actions done before language specific actions.
    of other options, i.e. - PJL options
    init=&lsqb; sync=ps pagecount=ps &rsqb;
<p>
term=&lsqb; ... &rsqb;      - LIST
    actions done after language specific actions
<p>
pjl_init=&lsqb; ... &rsqb;  - LIST
    if PJL is enabled, do these actions before language specific
    actions
<p>
pjl_term=&lsqb; ... &rsqb;  - LIST
    if PJL is enabled, do these actions after language specific
    actions
<p>
pjl_user_opts=&lsqb; ... &rsqb; - LIST
    allow these user options to be processed if requested after
    the pjl_init actions.
<p>
pcl_init=&lsqb; ... &rsqb;, ps_init=&lsqb; ... &rsqb;, raw_init=&lsqb; ... &rsqb;
	if job language enabled and job has this form,  do these actions
pcl_user_opts=&lsqb; ... &rsqb;, ps_user_opts=&lsqb; ... &rsqb;, raw_user_opts=&lsqb; ... &rsqb;
	if job language enabled and job has this form,  do these
       user requested -T and -Z actions
<p>
pjl_job		- FLAG, BUILTIN
	Set this if the PJL JOB facility is supported.  This will
	case &commat;PJL JOB lines to be generated
-->
<!-- IFHP-HOWTO SGML format -->
</article>
