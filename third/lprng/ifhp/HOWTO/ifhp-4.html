<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> IFHP-HOWTO: Filter Operation Details</TITLE>
 <LINK HREF="ifhp-5.html" REL=next>
 <LINK HREF="ifhp-3.html" REL=previous>
 <LINK HREF="ifhp.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="ifhp-5.html">Next</A>
<A HREF="ifhp-3.html">Previous</A>
<A HREF="ifhp.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4. Filter Operation Details</A></H2>

<P>The
<CODE>ifhp</CODE>
filter operates by first reading a configuration file
to determine the type of printer it is working with,
and then proceeds to carry out operations requested by the values of
option variables passed on the command line or found in the configuration
files.
In normal operation,
input is read from 
<CODE>STDIN</CODE>
(file descriptor 0),
massaged in the appropriate manner,
and then written out to
<CODE>STDOUT</CODE> (file descriptor 1).
Status reports are written to
a status file, or optionally to
<CODE>STDERR</CODE> (file descriptor 2),
together with any error messages or diagnostics.
<P>In addition to normal operation
the filter can run in the
<B>OF</B> mode and act as a printer initializer and job terminator.
This is discussed in detail in the LPRng documentation.
When in the OF mode,
The first nonblank input line will be treated as
a request to generate a banner.
The string "\031\001" will cause the filter to suspend operations
using a SIGSUSP signal.
At this point,
job files will be sent to the output device by the spooler,
and the filter will then be restarted with a SIGCONT signal.
<P>These steps are best explained algorithmically.
The following is a <EM>pseudo-code</EM> description of the steps
performed during the printing activity.
The sections marked with <CODE>###</CODE> are discussed later in this document
in detail.
<P><CODE>///</CODE> See: 
<A HREF="#setup">Options, Initialization and Setup</A>
<BLOCKQUOTE><CODE>
<PRE>
###+++ Initialization and Setup
// get ifhp information from PRINTCAP_ENTRY environment variable
if( PRINTCAP_ENTRY environment variable has a value ){
        split printcap information into printcap fields
        if( :ifhp=options,options is present in printcap ){
                split the options list and place in the Toptions list
        }
}
foreach option in -Toptions, -Zoptions do
    if( option = "debug=level"  and Debuglevel not set ){
        set Debuglevel = level;
    }
    if( option = "trace" ){
        output error and trace on STDERR
    }
    if( option = "config=pathlist" and from -Toption ){
        set configuration pathlist = pathlist;
    }
    if( option = "model=name" and model not set ){
        set model = name;
    }
}
</PRE>
</CODE></BLOCKQUOTE>

<CODE>///</CODE> See: 
<A HREF="#optioninit">Operation Configuration Options</A>
<BLOCKQUOTE><CODE>
<PRE>
// extract configuration information
foreach path in configuration pathlist {
    open path;
    for each line in file information {
                if( line is selected to be in configuration ){
                        process input line, adding it to configuration
                        if( line is 'debug=','model='
                           and the corresponding value not set ){
                           set the value;
                        }
                }
    }
}

// get values of options with predefined meanings
// these include status, forcestatus, etc
foreach option in predefined list {
        if( option=value is in selected configuration information ){
                set option=value;
        }
}

// open a direct connection if specified
if( device specified using -Tdev=device ){
        // if device is host%port, we open TCP/IP connection
        fd = open(device);
        dup fd to 1; close fd;
}
if( appsocket procotol specified and TCP/IP device ){
        udp_socket = open( udp socket to device%port+1 )
}


###---
</PRE>
</CODE></BLOCKQUOTE>

<CODE>///</CODE> See: 
<A HREF="#syncpage">Synchronization and Pagecount</A>
<BLOCKQUOTE><CODE>
<PRE>
###+++ Synchronization and Pagecount
if( status returned by printer and sync requested ){
    // APPSOCKET protocol
    // sync has the form sync@ (none), sync=ps, sync=pjl, ...
        if( appsocket ){
                command = "\n\r"
        } else {
                // decode status=language and determine sync
        if( sync = pjl and PJL ECHO available ){
            send PJL ECHO command to printer
                } else if( sync = ps ){
            send PS program to printer
                } else {
                        terminate with error;
                }
        do{
                send command and wait for timeout;
    } while( no response );

        if( appsocket ){
                close and reopen TCP/IP connection;
        }

    // pagecount has the form pagecount@ (none),
    //   pagecount=ps, pagecount=pjl, ...
    if( pagecount=language has value ) do {
                if( pagecount TRUE ){
                        set pagecount= pjl or ps depending on availability
                }
        if( pagecount = pjl and PJL INFO available ){
           send PJL INFO PAGECOUNT command to printer
                } else if( pagecount = ps ){
           send PS program to printer
                } else {
                        terminate with error;
                }
    } while( no pagecount response );

        if( appsocket ){
                close and reopen TCP/IP connection;
        }
}
###---
</PRE>
</CODE></BLOCKQUOTE>

<CODE>///</CODE> See: 
<A HREF="#pjlinit">PJL Initialization</A>
<BLOCKQUOTE><CODE>
<PRE>
### PJL Initialization
if( PJL enabled ){
    language = "pjl_"
    foreach option in pjl_init=[...] {
       expand the option using the language value
       #+++ PJL OPTION ACTIONS +++
       if( option in pjl_vars_set=[ ... ]
         and option not in pjl_vars_except
         expand "@PJL SET OPTION=\%{option}"
         output = expanded string value
       } else {
         if( option value is a string ){
           output = expanded string value;
         }
       }
       // output has the form @PJL COMMAND ....
       if( COMMAND is in pjl_only=[ ... ]
           and not in pjl_except=[ ... ] ){
           send output to printer
       }
       #--- end PJL OPTION ACTIONS
    }
    if( !OF_mode ){
         foreach option in -Toption=value {
            if( option in pjl_user_opts ){
                #+++ USER PJL OPTIONS
                // join 'pjl_' and the option name
                expand 'pjl_' . option
                // perform PJL actions as above
                    #+++ PJL OPTION ACTIONS +++
                    ....
                    #-- PJL OPTION ACTIONS +++
                #--- USER PJL OPTIONS
            }
         }
         foreach option in -Zoption=value {
            if( option in pjl_user_opts ){
                // perform USER PJL actions as above
                #+++ USER PJL OPTIONS
                #--- USER PJL OPTIONS
            }
         }
    }
}

###--- PJL INITIALIZATION
</PRE>
</CODE></BLOCKQUOTE>

<CODE>///</CODE> See: 
<A HREF="#textfile">Text File Conversion</A>
<BLOCKQUOTE><CODE>
<PRE>
// language is set to the type of job language
// - PS, PCL, TEXT, RAW, UNKNOWN
//  the first part of the job file is read and the filter takes
//  a (wimpy) guess at the job file based only on the first couple
//  of characters;  language is  be PJL, PS, or TEXT, or RAW
//  This is the same algorithm as the UNIX FILE utility

language = UNKNOWN
if( command line -c (binary) option present ){
    language = RAW;
} else if( -Zlanguage=xxx option present ){
    language=xxx
} else if( file is PS file ){
    language=PS
        if( file starts with PS EOJ (CTRL-D)
                and no_ps_eoj is set ){
                remove the PS EOJ
        } else {
                send a PS EOJ first
        }
} else if( file is PCL file ){
    language=PCL
        if( file starts with PCL EOJ (ESC E)
                and no_pcl_eoj is set ){
                remove the PCL EOJ
        }
} else if( file_util_path=/pathname ){
    use UNIX file utility to get file type
}

if( language = UNKNOWN and
    default_language option has value ){
    language = value of default_language;
}

if( language = TEXT ){
    if( text_converter=/path option has value ){
        run text converter on input
    } else if( printer does not support TEXT output ){
        exit with error;
    }
    language = value of text_converter_output option
}

if( language = UNKNOWN ){
    exit with error;
}
if( PJL ENTER supported ){
        use PJL ENTER command to select language;
        send nullpad NULLS to force full buffer condition
}
</PRE>
</CODE></BLOCKQUOTE>

<CODE>///</CODE> See: 
<A HREF="#languageinit">Language Specific Initialization</A>
<BLOCKQUOTE><CODE>
<PRE>
// LANGUAGE SPECIFIC INITIALIZATIONS
if( language = PCL ){
    foreach option in pcl_init {
        ###+++ expansion 
        do expansion similar to PJL OPTION actions
            using "pcl_" prefix for option lookup;
        ###---
    }
    if( not in OF_MODE ){
        foreach option in -Toption do {
            if( option in pcl_user_vars=[ ... ] ){
            ###+++ expansion as above
            ###---
        }
        foreach option in -Zoption do {
            if( option in pcl_user_vars=[ ... ] ){
            ###+++ expansion as above
            ###---
        }
    }
    remove whitespace and expand string results;
} else if( language = PS ){
    ###+++ language specific actions as above,
      using the ps_ prefix for lookup 
    expand string results but do not remove whitespace
}
</PRE>
</CODE></BLOCKQUOTE>

<CODE>///</CODE> See: 
<A HREF="#filetransfer">File Transfer and Error Status Monitoring</A>
<BLOCKQUOTE><CODE>
<PRE>
Transfer job to printer, reading error and other information
  back from the printer if enabled

if( language = PCL ){
    send PCL End of Job
} else if( language = PS ){
    send PS End of Job
}


// job terminaton

###+++ Synchronization and Pagecount as above
if( waitend ){
        if( sync requested previously ){
                if( sync with PJL ){
                        wait for end of job using UINFO;
                } else if( sync with PS ){
                        request status using ^T and wait for
                        printing to stop
                }
        }
        if( appsocket ){
                close and reopen connection;
        }
        get pagecount using previously descibed algorithm
}
        
###---

exit
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="setup"></A> <A NAME="ss4.1">4.1 Options, Initialization and Setup</A>
</H2>

<P>The
<CODE>ifhp</CODE>
filter is designed to work with the LPRng print spooler,
but will also work with other spooling systems.
The LPRng system will set the 
<CODE>PRINTCAP_ENTRY</CODE>
environment variable to the current printcap value.
By convention,
the filter command line
<CODE>-Toptions</CODE>
are reserved for the print spooler to pass configurtion inforamtion
and the
<CODE>-Zoptions</CODE>
are passed by the user.
For example,
examine the following
<CODE>lpr</CODE>
command and printcap example:
<BLOCKQUOTE><CODE>
<PRE>
Printcap:
pr:...
  :ifhp=opt1=value1,opt2=value2
  :if=/usr/ifhp -Topt1=value4,opt3=value3

Command:
lpr -Zopt4=value4

PRINTCAP_ENTRY envionment variable: 
  pr:...\n
    :ifhp=opt1=value1,opt2=value2\n
    :if=/usr/ifhp -Topt1=value4,opt3=value3\n

Resulting option list:

-Toptions:
  opt1=value4
  opt2=value2
  opt3=value3

-Zoptions:
  opt4=value4
</PRE>
</CODE></BLOCKQUOTE>
<P>When started,
the
<CODE>ifhp</CODE>
filter process the environment and command line options as follows.
<OL>
<LI>If the
<CODE>PRINTCAP_ENTRY</CODE>
environment variable has a value,
then this value is used to initialize the
<CODE>-Toption</CODE>
list.</LI>
<LI>If there is a
<CODE>-Toption</CODE>
command line option,
then these values are added to the
option list,
overriding values from the
<CODE>PRINTCAP_ENTRY</CODE>
set.</LI>
<LI>The command line
<CODE>-Zoption</CODE>
list is generated by splitting the
<CODE>-Zoption</CODE>
command line option.</LI>
</OL>
<P>The option lists are scanned for values for the
<CODE>debug</CODE>,
<CODE>trace</CODE>,
<CODE>config</CODE>,
and
<CODE>model</CODE>
options.
These options
have the property that once they are set, then they cannot be modified
(i.e. - sticky values).
<P>
<A NAME="model_from_option"></A> 
There is another,
and rather bizarre way to specify the printer model,
and that is the
<CODE>model_from_option</CODE>
option in the configuration file.
This option causes the command line options to be scanned,
and if there is a value for the command line option then it
is used as the model.
For example:
<BLOCKQUOTE><CODE>
<PRE>
model_from_option=Q
</PRE>
</CODE></BLOCKQUOTE>
<P>The above setting will cause the model to be taken from the
<CODE>Q</CODE> option.
This can be used to select a configuration for the printer
based on values specifed by the user.
<H3><A NAME="trace"></A> <A NAME="debug"></A> Debug and Trace</H3>

<P>The value of the
<CODE>debug</CODE>
option sets the debugging level.
It can be increased, but not decreased.
The
<CODE>trace</CODE>
flag causes debugging information to be sent to STDERR (file descriptor 2)
as well as to the status file.
<H3><A NAME="config"></A> <A NAME="configpaths"></A> Configuration File Paths</H3>

<P>The main source of configuration information are the configuration files.
The
<BLOCKQUOTE><CODE>
config=pathname,pathname
</CODE></BLOCKQUOTE>

option can be used to specify the list of configuration files to be read.
This can only be done using the
<CODE>PRINTCAP_ENTRY</CODE>
<CODE>:ifhp</CODE>
entry or the
<CODE>-Tconfig=pathname,pathname</CODE>
command line option.
<H2><A NAME="model"></A> <A NAME="modelselect"></A> <A NAME="ss4.2">4.2 Model Selection</A>
</H2>

<P>The
<CODE>model=name</CODE>
option is used to establishes the model name for extracting
configuration information.
For details on this, see
<A HREF="ifhp-7.html#configfiles">Configuration Files</A>.
<P>During initialization,
the
<CODE>-Toptions</CODE>
list is scanned for a
<CODE>-Tmodel=name</CODE>
entry.
Once the model name is set, it cannot be changed.
After this,
the configuration files are read,
and the first
<CODE>model=name</CODE>
option encountered will set the
<CODE>model</CODE>
option to
<CODE>name</CODE>.
<P>The recommended method of model selection is to
specify it in the
LPRng printcap entry for the printer,
using the <CODE>:ifhp=...</CODE>
printcap field.
For example:
<BLOCKQUOTE><CODE>
<PRE>
lp:ifhp=model=HP4,status@
  :if=/usr/local/ifhp

Resulting -Toption List:
 model=HP4
 status@
</PRE>
</CODE></BLOCKQUOTE>
<P>This will cause the
<CODE>-Toption</CODE>
list to be initialized as indicated,
and the
<CODE>model</CODE>
option value will be set to
<CODE>HP4</CODE>.
<P>The next method is use a
<CODE>-Toption</CODE>
command line option.
<BLOCKQUOTE><CODE>
<PRE>
lp:...
  :if=/usr/local/ifhp -Tmodel=HP4

Resulting -Toption List:
 model=HP4
</PRE>
</CODE></BLOCKQUOTE>
<P>This will cause the
<CODE>-Toption</CODE>
list to be initialized as indicated,
and the
<CODE>model</CODE>
option value will be set to
<CODE>HP4</CODE>.
<P>Another method is to put the model information in a
<CODE>./ifhp.conf</CODE>
file in the spool directory of the print queue.
The
<CODE>config=/pathname,/pathname,...</CODE>
option specifies the list of configuration files to read,
and the default value is:
<BLOCKQUOTE><CODE>
<PRE>
config=./ifhp.conf,/etc/ifhp.conf,./ifhp.conf
</PRE>
</CODE></BLOCKQUOTE>
<P>If the model information is put in the 
<CODE>./ifhp.conf</CODE>
configuration file,
the first reading will set the model name,
and the name is used to select the model information from the
<CODE>/etc/ifhp.conf</CODE>
file.
When the 
<CODE>./ifhp.conf</CODE>
is reread,  the values in it can be used to override values from the
<CODE>/etc/ifhp.conf</CODE>
file.
For example:
<BLOCKQUOTE><CODE>
<PRE>
./ifhp.conf:
  model=HP4
  lines=66

/etc/ifhp.conf:
[ hp* ]
 lines=60
[ apple* ]
 lines=20
</PRE>
</CODE></BLOCKQUOTE>
<P>When the
<CODE>./ifhp.conf</CODE>
is first read,
it will establish
<CODE>model=hp</CODE>
(sticky) and 
<CODE>lines=66</CODE>.
When the
<CODE>/etc/ifhp.conf</CODE> file is read,
the model name matches the
<CODE>hp*</CODE> selector
(case insensive GLOB matching is used),
and the
<CODE>lines=60</CODE>
is selected and overrides the
<CODE>lines=66</CODE>
value.
Finally,
when the
<CODE>./ifhp.conf</CODE>
file is reread,
<CODE>lines=66</CODE>
will establish the final value.
<H2><A NAME="statusfile_min"></A> <A NAME="statusfile_max"></A> <A NAME="statusfile"></A> <A NAME="ss4.3">4.3 Statusfile, Statusfile_max, Statusfile_min</A>
</H2>

<P>The status file pathname is set by the command line
<CODE>-s /pathname</CODE>
or the
<CODE>statusfile=/pathname</CODE>
configurtion file entry.
If the
<CODE>/pathname</CODE>
file does not exist then it will not be created.
If the statusfile is larger than the
<CODE>statusfile_max=max</CODE>
K bytes option value (default 8K),
then it will be truncated to
<CODE>statusfile_min=min</CODE>
K bytes.
<H3>Summmaryfile</H3>

<P>
<A NAME="summaryfile"></A> 
For historical and vintage software compatibility,
the
<CODE>summaryfile=/pathname</CODE>
or
<CODE>summaryfile=host%port</CODE>
option will cause either a file to be open or a UDP network connection
established to the host  and port combination.
Debugging or trace information will be written to this file or network
connection as well, but the file will be truncated each time,
holding only the last line of trace information.
<P>
<H2><A NAME="ss4.4">4.4 Operation Configuration Options</A>
</H2>

<P>
<A NAME="optioninit"></A> 
<A NAME="status"></A> 
<A NAME="forcestatus"></A> 
<A NAME="pjl"></A> 
<A NAME="pcl"></A> 
<A NAME="ps"></A> 
<A NAME="text"></A> 
The
<CODE>-Toption=value</CODE>
and model configuration information is scanned
to set values of options which control filter activity.
There are some options whose related actions do not fall into
the simple model of string expansion.
These usually require generating commands dynamically,
or sending files containing font or setup information to the printer.
The following is a list of these options.
<H3>status and forcestatus FLAGS</H3>

<P>These options have the side effect of enabling the reception of status
and error information from the printer.
<H3>pjl, pcl, ps and text FLAGS</H3>

<P>These flags set the lanaguages that are recognized or processed by
the filter.
<H3><A NAME="crlf"></A> crlf FLAG</H3>

<P>The
<CODE>crlf</CODE>
causes LF (<CODE>\n</CODE>) to be translated to CR-LF
(<CODE>\r\n</CODE>) sequences.
The following options will turn the
<CODE>ifhp</CODE>
filter into a simple CRLF translation filter.
Note that CRLF translation should have no effect
on PostScript, Text, or PCL files.
<BLOCKQUOTE><CODE>
<PRE>
status@
pjl@
ps@
pcl@
text
text_converter_output@
text_converter@
crlf
</PRE>
</CODE></BLOCKQUOTE>
<H3><A NAME="pjl_job"></A> pjl_job FLAG</H3>

<P>If PJL is enabled and this flag is SET,
a PJL JOB and PJL EOJ command will be generated
and sent to the printer.
The JOB command has the form:
<BLOCKQUOTE><CODE>
&commat;PJL JOB NAME = "..." [ START = nnn ] [ END = mmm ]
</CODE></BLOCKQUOTE>

The START and END values can be specified by
<CODE>-Zstart=nnn</CODE>
and
<CODE>-Zend=mmm</CODE>
command line options.
The EOJ command has must match the JOB command.
<BLOCKQUOTE><CODE>
&commat;PJL EOJ NAME = "..." [ START = nnn ] [ END = nnn ]
</CODE></BLOCKQUOTE>
<H3><A NAME="pjl_enter"></A> pjl_enter FLAG</H3>

<P>If PJL is enabled and this flag is SET,
a PJL ENTER LANGUAGE = xx command will be generated
when PCL or PS files are sent to the printer.
<BLOCKQUOTE><CODE>
<PRE>
@PJL ENTER LANGUAGE = PCL
@PJL ENTER LANGUAGE = POSTSCRIPT
</PRE>
</CODE></BLOCKQUOTE>
<H3><A NAME="nullpad"></A> nullpad STRING</H3>

<P>Some older model HP printers required sending a large number of
NULL (0) characters to force commands in the input buffer to be read.
This can be done using the
<CODE>nullpad</CODE> option.
<P>In practice,
this has turned out to be largely historical,
as most printers do not have this problem.
<H3><A NAME="pjl_console"></A> pjl_console FLAG</H3>

<P>When this flag is set,
PJL is available,
and the PJL
<CODE>RDYMSG</CODE>
command is supported,
then a short message will be put on the console.
<H3><A NAME="remove_ctrl"></A> remove_ctrl STRING</H3>

<P>The
<CODE>remove_ctrl</CODE> string option species a list of (control) characters
that will be removed from PostScript jobs.
This solves the problem of jobs with embedded Control-T or Control-C
characters causing abnormal printer operation.
For example:
<BLOCKQUOTE><CODE>
<PRE>
remove_ctrl=CT
</PRE>
</CODE></BLOCKQUOTE>

would cause Control-C and Control-T characters to be removed.
<H3><A NAME="tbcp"></A> tbcp FLAG</H3>

<P>The
<CODE>tbcp</CODE>
flag can be specified as a user option as well as a
configuration file option.
If the file type is PostScript and this flag is set,
then the file is transferred using the Transparent Binary Communication
Protocol.
(See the Adobe PostScript Language Reference Manual for details on
the protocol.)
<P>At the start of the PostScript job,
the sequence <CODE>\001</CODE> <CODE>M</CODE> is sent.
Afterwards,  all control characters in the set
<CODE>0x01, 0x03, 0x04, 0x05,
0x11, 0x13, 0x14, 0x1C,</CODE>
are replaced by the two character sequence <CODE>\001</CODE>
<CODE>X+'@'</CODE> or
<CODE>X+'\100'</CODE> or
is sent.
For example:
<BLOCKQUOTE><CODE>
<PRE>
C\001\003   ->  \001\115\103\001\101\001\103 or \001MC\001A\001C
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="sync_timeout"></A> <A NAME="sync_interval"></A> <A NAME="sync"></A> <A NAME="pagecount_ps_code"></A> <A NAME="pagecount_timeout"></A> <A NAME="pagecount_interval"></A> <A NAME="pagecount"></A> <A NAME="syncpage"></A> <A NAME="ss4.5">4.5 Synchronization and Pagecounts</A>
</H2>

<P>Many printers are able to provide status information back to the
filter.
It is assumed that in these circumstances file descriptor 1
(FD1)
is
<EM>bidirectional</EM>
and status information can be read from it.
When the
<CODE>status</CODE>
or
<CODE>forcestatus</CODE>
option is TRUE,
then the filter assumes that it can read FD1.
In order to simplify configuration,
the
<CODE>ifhp</CODE>
filter will test FD1, and if it is not
a serial port or a network socket, will set
<CODE>status@</CODE>
or OFF.
<P>However, there are some devices such as bidirectional printer ports
that will report status.
By setting
<CODE>forcestatus</CODE>
ON,
the filter can be forced to check for status.
This can have fatal or unexpected effects if status is not returned
correctly.
<P>Synchronization is usually done in order to ensure that a previously
spooled job or printer action has completed correctly,
and the printer is ready to accept a new job.
It is usally carried out by sending a request to the printer to
echo a string back to the filter.
Clearly,
if the printer cannot provide status or echo values back,
then synchronization is impossible.
<P>The value of the
<CODE>sync</CODE> option determines if a PJL ECHO command or simple PostScript 
program is used.
The PostScript program has the form:
<BLOCKQUOTE><CODE>
\004%!PS-Adobe-2.0<BR>
( %%[ echo: <EM>TODSTR</EM> ]%% ) print () = flush<BR>
\004
</CODE></BLOCKQUOTE>
<P>where <EM>TODSTR</EM> is replaced with the current Time of Day.
<P>To control obtaining synchronization,
the
and
<CODE>sync_timeout=nnn</CODE>
options are used.
The PJL or PS command is repeated at
<CODE>sync_interval=nnn</CODE>
second intervals; if nnn is 0, then it is sent only once.
If synchronization is not obtained within
<CODE>sync_timeout=nnn</CODE>
seconds, then the filter exits with an error status.
A 0 value or
<CODE>sync_timeout@</CODE>
disables timeouts.
<P>Pagecounts are used to do accounting and report the number of pages
used for a job.
Most printer have a hardware based pagecounter mechanism whose value
can be read by the appropriate PJL command or PostScript program.
For example, if the PJL INFO command
<BLOCKQUOTE><CODE>
<PRE>
@PJL INFO PAGECOUNT
</PRE>
</CODE></BLOCKQUOTE>

is supported by a printer,
the printer will return a status message containing the current pagecounter
value.
Printers that support PostScript may also be able to access the pagecounter
value using a PostScript program.
The exact details of the PostScript program vary from vendor to vendor and
the
<CODE>pagecount_ps_code=...</CODE>
option specifies the PostScript program to use.
For example:
<BLOCKQUOTE><CODE>
<PRE>
pagecount_ps_code=
  /p {print} def ( %%[ pagecount: ) p
  statusdict begin pagecount end 20 string cvs p
  ( ]%% ) p () = flush
</PRE>
</CODE></BLOCKQUOTE>
<P>Pagecounting is supported by the
<CODE>pagecount=</CODE><I>language</I>,
<CODE>pagecount_interval=nnn</CODE>,
and
<CODE>pagecount_timeout=nnn</CODE>
options.
The
<CODE>pagecount=</CODE><I>language</I>
option enables pagecounting, and sets the language to be used.
Currently
<CODE>ps</CODE> (PostScript)
and
<CODE>pjl</CODE> (PJL)
are supported.
The pagecount request is repeated every
<CODE>pagecount_interval=nnn</CODE>
second intervals; if nnn is 0, then it is sent only once.
If no pagecount value is obtained within
<CODE>pagecount_timeout=nnn</CODE>
seconds, then the filter exits with an error.
A 0 value or
<CODE>sync_timeout@</CODE>
disables timeouts.
<P>Some printers do not correctly report end of job and must be polled
until the pagecount information stabilizes.
The PJL TEOJ (True End Of Job) PJL has been tried with limited success
on various printers to force End of Job reporting only when the
job has finished.
<BLOCKQUOTE><CODE>
<PRE>
pjl_init=[ ... teoj ... ]
pjl_teoj=&commat;PJL TEOJ=ON
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="pjl_init"></A> <A NAME="pjl_user_opts"></A> <A NAME="pjl_vars_except"></A> <A NAME="pjl_vars_set"></A> <A NAME="pjl_except"></A> <A NAME="pjl_only"></A> <A NAME="startpage"></A> <A NAME="endpage"></A> <A NAME="pjlinit"></A> <A NAME="ss4.6">4.6 PJL Initialization</A>
</H2>

<P>If a printer supports PJL,
the many printer operations can be initiated and controlled using
PJL commands.
Unfortunately,
not all printers support the same set of commands.
In addition,
not all printers support the same set of operations or options.
A PJL command has the form:
<BLOCKQUOTE><CODE>
@PJL COMMAND OPTION OPTION ...
</CODE></BLOCKQUOTE>

A PJL variable is set using:
<BLOCKQUOTE><CODE>
@PJL SET <I>var</I> = <I>value</I> ...
</CODE></BLOCKQUOTE>

The
<CODE>pjl_only=[ ... ]</CODE>,
<CODE>pjl_except=[ ... ]</CODE>,
<CODE>pjl_vars_set=[ ... ]</CODE>,
and
<CODE>pjl_vars_except=[ ... ]</CODE>
options are used to control which PJL commands and which PJL variables
can be set.
The 
<CODE>pjl_only</CODE>
variable lists the commands supported by the printer,
and the
<CODE>pjl_except</CODE>
lists commands <EM>not</EM>
supported by the printer.
Before sending a PJL command,
the
<CODE>ifhp</CODE>
filter checks to make sure that the command name is in
<CODE>pjl_only</CODE>
and not in
<CODE>pjl_except</CODE>.
If the tests fail, then tne command is not sent.
<P>Similarly,
when sending a command to set a PJL variable,
the
<CODE>pjl_vars_set</CODE>
and
<CODE>pjl_vars_except</CODE>
lists are checked to determine if the variable name is in
<CODE>pjl_vars_set</CODE>
and not in
<CODE>pjl_except</CODE>
list.
If the tests fail, then tne command is not sent.
<P>If PJL is enabled,
then the following actions are taken.
<OL>
<LI> PJL Universal Exit Lanaguage (UEL) <CODE>\033%-12345X</CODE> is sent to the printer.
<P>This is required to ensure that the following PJL commands are
accepted.
</LI>
<LI> PJL JOB command is sent at the start of job.
The JOB command can be used to select pages or impressions to be printed.
If the
<CODE>-Zstartpage=nnn</CODE>
or
<CODE>-Zendpage=mmm</CODE>
option is present, then the PJL JOB command has the form:
<BLOCKQUOTE><CODE>
@PJL JOB START=nnn END=mmm
</CODE></BLOCKQUOTE>
</LI>
<LI> The
<CODE>pjl_init=[ ... ]</CODE>
value option is expanded using the PJL
(<CODE>"pjl_"</CODE>) language context as described above.</LI>
<LI> The
<CODE>-Toption=value</CODE>s
and
<CODE>-Zoption=value</CODE>s
are scanned for matching option names in the 
<CODE>pjl_user_opts=[ ... ]</CODE> 
list.
If they are found,
then the options are recursively evaluated in the PJL language context.
The expansion alorithm will cause the option value to be used to set PJL
variables.
For example:
<BLOCKQUOTE><CODE>
<PRE>
Configuration:
  pjl_vars_set=[ OUTBIN AUTOSELECT JAM=YES ]

Command
  ifhp -Zoutbin=upper,autoselect,jam

PJL command generated:
  @PJL SET OUTBIN=UPPER
  @PJL SET AUTOSELECT=ON
  @PJL SET JAM=YES
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</OL>
<H2><A NAME="language"></A> <A NAME="text_tempfile"></A> <A NAME="text_converter_output"></A> <A NAME="text_converter"></A> <A NAME="file_util_path"></A> <A NAME="default_language"></A> <A NAME="textfile"></A> <A NAME="ss4.7">4.7 Text File Conversion</A>
</H2>

<P>Many PostScript printers cannot handle text files,
and produce many hundreds of pages of garbage
output if they are sent to the printer without being translated
into PostScript.
Also,
while most PCL printers will accept text files and do a reasonable
job of printing them
some form of initialization strings or setup may need to be done.
Finally,
you might want to try using a
<CODE>MagicFilter</CODE>
that will convert just about any type of file into a PostScript file.
<H3>Default Converter Program</H3>

<P>This method specifies that the default file type
will be
<CODE>text</CODE>.
If the simple <CODE>ifhp</CODE> type detection code cannot decide
what type of file this is,
it will invoke a converter program.
This operation is controlled by the following options.
<DL>
<DT><B><CODE>default_language=text</CODE></B><DD><P>When the default lanague is <CODE>text</CODE>
then the
<CODE>text_converter</CODE> and
<CODE>text_converter_output</CODE> options are used.
<DT><B><CODE>text_converter=/pathname</CODE></B><DD><P>specifies the pathname of a text to language program.
<DT><B><CODE>text_converter_output=language</CODE></B><DD><P>Specifies the output language of the conversion program.
Language can be
<CODE>ps</CODE>,
<CODE>pcl</CODE>,
<CODE>text</CODE>,
<CODE>raw</CODE>,
<CODE>unknown</CODE>
<DT><B><CODE>tempfile=/pathname</CODE></B><DD><P>A temporary file location,  used to store
intermediate conversion results.
The
<CODE>/pathname</CODE>
value has the string
<CODE>XXXXXX</CODE>
appended to it and is used as input to the POSIX
<CODE>mktemp()</CODE>
function.
</DL>
<P>The print file language is determined using the following algorithm.
<OL>
<LI>The default language is set to
<CODE>unknown</CODE>
or the
<CODE>default_language=language</CODE> value if it exists.</LI>
<LI>If the command line
<CODE>-c</CODE>
(binary) option is present,
or the
<CODE>autodetect</CODE> configuration option is TRUE,
then the language is set to
<CODE>RAW</CODE>.
(The autodetect option is not recommended for general use).</LI>
<LI>If there is a
<CODE>-Zlanguage=value</CODE> command line option,
the language is set to
<CODE>value</CODE>.</LI>
<LI>Various simple checks to determine if the file is
Postscript
(language=<CODE>ps</CODE>)
or PCL
(language=<CODE>pcl</CODE>)
are performed.
These are the same checks that the UNIX
<CODE>file</CODE>
utility uses.</LI>
<LI>If the file type is 
<CODE>text</CODE>
then the
<CODE>text_converter</CODE>
program is run to translate the file and the results stored in
the <CODE>tempfile</CODE>.</LI>
</OL>
<P>One technique used with varying degrees of sophistication is to
use a general purpose file to PostScript conversion program.
These have generally been known as
<EM>MagicFilters</EM>, due to their high degree of flexibility. 
<H3>Pseudo-MagicFilter Support</H3>

<P>As described above,
the various
<EM>MagicFilter</EM> packages can do conversion.
However, most of the time there is only a limited need for the
general purpose conversions.
This can be met by using the
<CODE>file</CODE> program,  which will determine the type of a file based on
its contents,
and having <CODE>ifhp</CODE> invoke a program based on the type of file found.
This method is used when
<CODE>default_language=unknown</CODE>
and the
<CODE>file_util_path=/path</CODE>
and
<CODE>file_output_match=[ ... ]</CODE>
values are defined.
A typical configuration is shown below.
<BLOCKQUOTE><CODE>
<PRE>
Configuration:
# 
#  Method 2 -
#    Use the file util and match the output
# file reports format information
#  glob text_output_format text_converter
#  - you do a glob match against pattern and use the converter
#
default_language=unknown
file_util_path=/usr/bin/file -
file_output_match = [
# glob   output converter
 *text*  ps     /usr/local/bin/a2ps -q -B -o-
 *gif*   ps     /usr/local/bin/gif2ps
 ]
</PRE>
</CODE></BLOCKQUOTE>
<P>The
<CODE>file_output_match</CODE>
entry consists of a list of lines containing
a <I>glob</I> pattern,
a language type (<CODE>ps</CODE>, <CODE>pcl</CODE>, or <CODE>raw</CODE>),
and a program to invoke to do the conversions.
<P>The
<CODE>file</CODE>
utility is run and its output is matched against the specified
glob patterns.
When a match is found the specified program is run,
with STDIN attached to the original input file and its
STDOUT sent to the printer.
<P>While this algorithm may appear to be overly complex, it
will handle a wide range of desired configurations.
<H3>No Textfile Conversion Needed</H3>

<P>If your printer can handle text files without conversion,
but require PCL intialization, then the following combination
will simply set the language to
<CODE>pcl</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
text_converter@
text_converter_output=pcl
</PRE>
</CODE></BLOCKQUOTE>
<H3>Default Passthrough of Unknown File Types</H3>

<P>Your printer may be capable of handling a wide variety of job
formats.  If you want to simply pass through files of
unknown type or language then use:
<BLOCKQUOTE><CODE>
<PRE>
text_converter@
text_converter_output=raw
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="languageinit"></A> <A NAME="ss4.8">4.8 Language Specific Initialization</A>
</H2>

<P>After determining the output file language type,
language specific operations are then carried out by
expanding the
<I>language_</I><CODE>_init=[ ... ]</CODE>
options in the language context,
and then the options in the
<CODE>-Toption=value</CODE>
and
<CODE>-Zoption=value</CODE>
command line options.
The 
<CODE>-T</CODE>
options are expanded before the
<CODE>-Z</CODE>,
allowing the 
<CODE>-Z</CODE> actions to override any set by the
<CODE>-T</CODE> actions.
<P>As mentioned elsewhere,
the reason for the language specific processing is to allow
different actions for the same command line option,
depending on the file type that is being processed.
For example,  when processing a PCL file it might be necessary to send
PCL command strings and when processing a PostScript file,
you would need to send PostScript commands.
<H2><A NAME="pjl_quiet_codes"></A> <A NAME="pjl_error_codes"></A> <A NAME="logall"></A> <A NAME="filetransfer"></A> <A NAME="ss4.9">4.9 File Transfer and Error Status Monitoring</A>
</H2>

<P>If the printer can return status, i.e., the
<CODE>status</CODE>
or 
<CODE>forcestatus</CODE>
flag is set,
then the
<CODE>ifhp</CODE>
filter will read status information back from the printer.
<P>If the
<CODE>logall</CODE>
flag is SET,
then all error messages will be written to the status or log file.
<P>If the printer is returning PJL status information,
then this has a specific format:
<BLOCKQUOTE><CODE>
<PRE>
@PJL UINFO DEVICE
CODE=nnnn
DISLAY="value"
...

@PJL UINFO JOB
START
...

@PJL UINFO JOB
END
...
</PRE>
</CODE></BLOCKQUOTE>
<P>The
<CODE>ifhp</CODE> program will extract the
<CODE>CODE</CODE>
and job start and end flags,
and log these as appropriate.
<P>Unfortunately,
some PJL based printers are extremely verbose in their generation of status
messages.
In order to reduce the amount of logging of redundant information,
<CODE>ifhp</CODE>
will only record when a device status has
<B>changed</B>,
rather than when it has been reported.
<P>The
pjl_quiet_codes=[ code code code ]
value is used to suppress reporting of selected error codes.
If the error code is in the pjl_quiet_codes list,  then the error status
will not be reported to the user unless the
<CODE>logall</CODE>
option is set.
For example:
<BLOCKQUOTE><CODE>
<PRE>
  pjl_quiet_codes=[ 10000 10001 10003 10023 10024 35078 ]
</PRE>
</CODE></BLOCKQUOTE>
<P>Also, there may be error codes which does not have a builtin error
message available.  New messages can be added using the
<CODE>pjl_error_codes</CODE>
option.
Its value is a list of lines, each line consisting of an error code
followed by the corresonding error message:
<BLOCKQUOTE><CODE>
<PRE>
pjl_error_codes=[
   code=msg
   code=msg
   ...
]

Example:
  pjl_error_codes=[
     10000=powersave mode
     10001=Ready Online
     10002=Ready Offline
     10003=Warming Up
     10004=Self Test
     10005=Reset
  ]
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="waitend"></A> <A NAME="ss4.10">4.10 End of Job</A>
</H2>

<P>The <CODE>waitend</CODE> option controls the job termination sequence.
By default,
this will do the same work as the
<CODE>sync</CODE> operation,
and the option takes the same set of values.
<P>If <CODE>waitend</CODE>
is suppressed using <CODE>waitend@</CODE>,
then as soon as a job has been transferred,
the next step,
<CODE>pagecount</CODE>,
will be attempted.
If the print job has not finished at this point,
then erroneous page counts will be reported.
<P>When using the <CODE>appsocket</CODE> protocol,
then suppressing <CODE>waitend</CODE> will cause no error messages from the printer to
be reported.
<P>
<H2><A NAME="appsocket"></A> <A NAME="ss4.11">4.11 Tektronix Phaser and AppSocket Support</A>
</H2>

<P>The Tektronix Phaser PostScript printers uses the AppSocket protcol
for sending a job to the printer over a network connection.
The
<CODE>appsocket</CODE> flag enables this operation.
The protocol is (briefly):
<OL>
<LI> The printer listens for UDP packets on port 9101
and for TCP/IP connections on port 9100.</LI>
<LI> When a UDP packet is recieved on port 9101, then a reply
packet containing the status is returned to the originator's
address.
This packet contains an status indication,
in a <EM>undefined</EM> format.</LI>
<LI> To send a job to the printer,  a TCP/IP connection is opened to port
9100,
and a PostScript job is sent.
Only a single job can be sent at a time - a EOJ (CTRL-D)
will terminate input and flush all following jobs.</LI>
<LI>Return status will be sent in the reverse direction until the job
has completed,
at which point the connection will be closed.</LI>
</OL>
<P>To use this protocol,
the printer TCP/IP address and port must be specified using the
<CODE>-Tdev=host%port</CODE> option;
usually port is 9100.
Also,
the printer device in the printcap entry should be <CODE>lp=/dev/null</CODE>.
<P>When using the Appsocket protocol,
the <CODE>ifhp</CODE> filter will open a UDP port and use it to send
query packets to the printer UDP port 9101.
In addition,
it will try to open a connection to port 9100.
When a connection has been established,
and pagecount has been determined,
the connection will be close and reopened.
<P>After job transfer,
the connecion will be <CODE>half-closed</CODE>.
That is,
the <CODE>shutdown()</CODE> facility will be used to cause the TCP/IP connection
to be set to closed for transmission but open for reception.
The printer will send status information until the job is completed,
and then close the connection.
<P>If page count information is needed,
the <CODE>ifhp</CODE> filter will then reopen the connection and get the page count information.
<HR>
<A HREF="ifhp-5.html">Next</A>
<A HREF="ifhp-3.html">Previous</A>
<A HREF="ifhp.html#toc4">Contents</A>
</BODY>
</HTML>
