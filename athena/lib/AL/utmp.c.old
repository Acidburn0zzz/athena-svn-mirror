#include <unistd.h>
#include <AL/AL.h>

long
ALinitUtmp(ALsession session)
{
  ALutFlagClear(session, ALflagAll);
  memset(session->ut, 0, sizeof(session->ut));
}

/* Type is ALutLOGIN or ALutUSER. I believe telnetd, dm, and nanny
   would use LOGIN, while xlogin and login would use USER.

   id seems to be open to interpretation; everyone does something
   different.

	Irix uses the last two characters of the pty (q9).
	Solaris uses tn**, where ** is generated by makeutx.
	What AIX does I don't know yet.
	What we are doing under AIX is unmentionable.

   No children appear to actually search on the id field; they
   all search on the line field.

   When overwriting a parent entry (ALutUSER) and no ID has been
   set, the id field of the overwritten entry is preserved.

   Pass tty name without /dev/ into line.

   Pass DISPLAY into host if doing an X login on the local host,
   or nothing if the host is local and not X, the host if the
   login is remote.
*/
long
ALsetUtmpInfo(ALsession session, ALflag_t flags, ALut *ut)
{
  if (flags & ALutUSER)
    strncpy(ALut_user(session), ut->user, sizeof(ALut_user(session)));

  if (flags & ALutHOST)
    {
      strncpy(ALut_host(session), ut->host, sizeof(ALut_host(session)));
#ifdef UTMPX_FILE
      ALut_syslen(session) = strlen(ALut_host(session)) + 1;
      if (ALut_syslen(session) == 1)
	ALut_syslen(session) = 0;
#endif
    }

  if (flags & ALutLINE)
    strncpy(ALut_line(session), ut->line, sizeof(ALut_line(session)));

#ifndef ultrix
  if (flags & ALutID)
    strncpy(ALut_id(session), ut->id, sizeof(ALut_id(session)));

  if (flags & ALutTYPE)
    ALut_type(session) = ut->type;
#endif

  /* All platforms need this variable; we need to be able to tell
     whether or not we should write to wtmp. */
  if (flags & ALutTYPE)
    ALut_auxtype(session) = ut->type;

  ALutFlagSet(session, flags);
  return 0L;
}

long
ALputUtmp(ALsession sess)
{
#ifdef UTMPX_FILE
  struct utmpx *utx;
  char line[sizeof(utx->ut_line)];
#endif
  struct utmp utwrite;
  struct utmp *ut, *utsrc;
  int f, t;

  /*
   * This code supports setting entries for specific lines only.
   * If there isn't one set, give up.
   */
  if (!ALutIsSet(sess, ALutLINE))
    return(ALerrNoLineSet);

  /*
   * Set default values for the common case.
   *   The user field is lifted from the session structure.
   *   The type field is set to USER_PROCESS.
   *   The id field is set to "XX" if the device was ttyXX,
   *     "  co" if console, if the type is ALutLOGIN_PROC.
   *
   * Other fields don't really have appropriate default values.
   */
  if (!ALutIsSet(sess, ALutUSER))
    strncpy(ALut_user(sess), ALpw_name(sess), sizeof(ALut_user(sess)));

  if (!ALutIsSet(sess, ALutTYPE))
    ALut_auxtype(sess) = ALutUSER_PROC;

#ifndef ultrix
  if (!ALutIsSet(sess, ALutTYPE))
    ALut_type(sess) = ALutUSER_PROC;

  if (!ALutIsSet(sess, ALutID) && ALut_type(sess) == ALutLOGIN_PROC)
    {
      if (!strcmp("console", ALut_line(sess)))
	{
	  strncpy(ALut_id(sess), "co", sizeof(ALut_id(sess)));
	  ALutFlagSet(sess, ALutID);
	}
      else
	if (!strncmp("tty", ALut_line(sess), 3))
	  {
	    strncpy(ALut_id(sess), ALut_line(sess)+3, sizeof(ALut_id(sess)));
	    ALutFlagSet(sess, ALutID);
	  }
    }
#endif

  /*
   * Fill in the current time and pid.
   */

#ifdef UTMPX_FILE
  gettimeofday(&ALut_tv(sess));
#else
  time(&ALut_time(sess));
#endif

#ifndef ultrix
  ALut_pid(sess) = getpid();
#endif

  /*
   * Now all of the fields of whatever utmp type structure
   * we're using have been initialized as far as possible.
   * It's time to talk to the utmp file.
   *
   * The first block of code handles writing to BSD type utmps
   * (with ttyslot). Later we handle the SYSV type.
   */

#ifdef ultrix
  /* Ultrix has no mapping for LOGIN_PROC. */
  if (ALut_auxtype(sess) == ALutUSER_PROC ||
      ALut_auxtype(sess) == ALutDEAD_PROC)
    {
      if (ALut_auxtype(sess) == ALutDEAD_PROC)
	{
	  memcpy(&utwrite, utsrc, sizeof(utwrite));
	  memset(&utwrite.name, 0, sizeof(utwrite.name));
	}

      t = ttyslot();
      if (t > 0 && (f = open(UTMP_FILE, O_WRONLY)) >= 0)
	{
	  lseek(f, (long)(t * sizeof(*utsrc)), SEEK_SET);
	  write(f, (char *)utsrc, sizeof(*utsrc));
	  close(f);
	}
    }
#else /* ultrix */
  /*
   * Find the location we want to write to.
   */
#ifdef UTMPX_FILE

#ifdef SOLARIS
  /* Of course, Solaris is different from everyone else. It
   * searches for /dev/pts/0 instead of pts/0. */
  strncpy(line, ALut_line(sess), sizeof(line));
  strcpy(ALut_line(sess), "/dev/");
  strncat(ALut_line(sess) + 5, line, sizeof(ALut_line(sess) - 5));
#endif

  setutxent();
  utx = getutxline(&(sess->ut));
  utsrc = &utwrite;
  getutmp(&(sess->ut), utsrc);
#else
  utsrc = &(sess->ut);
#endif

  ut = getutline(utsrc);

  /*
   * We've got it. Copy the ID field from the entry we're going to
   * overwrite, unless we plan to set it ourselves.
   */
  if (!ALutIsSet(sess, ALutID) && ut != NULL)
    {
      strncpy(utsrc->ut_id, ut->ut_id, sizeof(utsrc->ut_id));
#ifdef UTMPX_FILE
      strncpy(ALut_id(sess), utx->ut_id, sizeof(utx->ut_id));
#endif
    }

#ifdef SOLARIS
  /* Fix /dev/pts/0 to be pts/0 again. */
  strncpy(ALut_line(sess), line, sizeof(ALut_line(sess)));
  strncpy(utsrc->ut.line, line, sizeof(utsrc->ut.line));
#endif

  /*
   * All set... Write it out to utmp.
   */
#ifdef UTMPX_FILE
  pututxline(&(sess->ut));
  endutxent();
#endif
/*   pututline(utsrc); */
  endutent();

#endif /* !ultrix */

  /*
   * Append to wtmp... Note updwtmpx writes to both wtmp and wtmpx.
   */
  if (ALut_auxtype(sess) == ALutUSER_PROC ||
      ALut_auxtype(sess) == ALutDEAD_PROC)
#ifdef SYSV
    updwtmpx(WTMPX_FILE, &(sess->ut));
#else
    if ((f = open(WTMP_FILE, O_WRONLY|O_APPEND)) >= 0)
      {
	write(f, (char *)utsrc, sizeof(*utsrc));
	close(f);
      }
#endif

  return 0L;
}
